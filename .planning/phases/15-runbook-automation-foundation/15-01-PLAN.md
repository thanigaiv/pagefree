---
phase: 15-runbook-automation-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/types/runbook.ts
  - src/services/runbook/runbook.service.ts
autonomous: true

must_haves:
  truths:
    - "Runbook model exists with approval status (DRAFT, APPROVED, DEPRECATED)"
    - "RunbookVersion tracks full definition history"
    - "RunbookExecution records execution state with definition snapshot"
    - "PLATFORM_ADMIN can approve/deprecate runbooks"
    - "Editing an APPROVED runbook reverts it to DRAFT"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Runbook, RunbookVersion, RunbookExecution models with enums"
      contains: "model Runbook"
    - path: "src/types/runbook.ts"
      provides: "TypeScript interfaces for runbook definitions"
      exports: ["RunbookParameterSchema", "RunbookDefinition", "RunbookExecutionStatus"]
    - path: "src/services/runbook/runbook.service.ts"
      provides: "Runbook CRUD with approval state machine"
      exports: ["runbookService", "createRunbookSchema"]
  key_links:
    - from: "src/services/runbook/runbook.service.ts"
      to: "prisma.runbook"
      via: "database operations"
      pattern: "prisma\\.runbook\\.(create|update|findUnique)"
    - from: "src/services/runbook/runbook.service.ts"
      to: "prisma.runbookVersion"
      via: "version snapshots"
      pattern: "prisma\\.runbookVersion\\.create"
---

<objective>
Create Runbook database models and CRUD service with approval state machine.

Purpose: Establish the foundation for runbook management with versioning and PLATFORM_ADMIN approval gates, mirroring the proven Workflow model patterns.

Output: Database models (Runbook, RunbookVersion, RunbookExecution), TypeScript types, and runbook.service.ts with full CRUD and approval operations.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-runbook-automation-foundation/15-RESEARCH.md

# Pattern references (mirror these exactly)
@prisma/schema.prisma (Workflow, WorkflowVersion, WorkflowExecution models - lines 768-863)
@src/services/workflow/workflow.service.ts (CRUD pattern, version snapshots, permission checks)
@src/types/workflow.ts (type patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Runbook Prisma Models</name>
  <files>prisma/schema.prisma</files>
  <action>
Add RunbookApprovalStatus enum and three new models to prisma/schema.prisma:

1. **RunbookApprovalStatus enum** (add near other enums ~line 60):
```prisma
enum RunbookApprovalStatus {
  DRAFT       // Initial state, can be edited
  APPROVED    // Platform admin approved, executable
  DEPRECATED  // Soft-delete, preserved for audit
}
```

2. **Runbook model** (follows Workflow pattern):
```prisma
model Runbook {
  id               String                @id @default(cuid())
  name             String
  description      String
  version          Int                   @default(1)

  // Webhook execution target
  webhookUrl       String                // URL to POST to (Ansible Tower, SSM, custom)
  webhookMethod    String                @default("POST")
  webhookHeaders   Json                  @default("{}")
  webhookAuth      Json?                 // Auth config (same as WorkflowWebhookAuth)

  // Parameters defined as JSON Schema
  parameters       Json                  @default("{}")

  // Payload template (Handlebars)
  payloadTemplate  String

  // Timeout (in seconds)
  timeoutSeconds   Int                   @default(300)

  // Approval workflow
  approvalStatus   RunbookApprovalStatus @default(DRAFT)
  approvedById     String?
  approvedBy       User?                 @relation("RunbookApprovedBy", fields: [approvedById], references: [id])
  approvedAt       DateTime?             @db.Timestamptz

  // Scope (team or global)
  teamId           String?
  team             Team?                 @relation(fields: [teamId], references: [id])

  // Ownership
  createdById      String
  createdBy        User                  @relation("RunbookCreatedBy", fields: [createdById], references: [id])

  // Timestamps
  createdAt        DateTime              @default(now()) @db.Timestamptz
  updatedAt        DateTime              @updatedAt @db.Timestamptz

  // Relations
  versions         RunbookVersion[]
  executions       RunbookExecution[]

  @@index([teamId, approvalStatus])
  @@index([approvalStatus])
  @@index([createdById])
}
```

3. **RunbookVersion model**:
```prisma
model RunbookVersion {
  id          String   @id @default(cuid())
  runbookId   String
  runbook     Runbook  @relation(fields: [runbookId], references: [id], onDelete: Cascade)
  version     Int
  definition  Json     // Snapshot of runbook at this version
  changedById String
  changedBy   User     @relation(fields: [changedById], references: [id])
  changeNote  String?
  createdAt   DateTime @default(now()) @db.Timestamptz

  @@unique([runbookId, version])
  @@index([runbookId, version])
}
```

4. **RunbookExecution model**:
```prisma
model RunbookExecution {
  id                 String   @id @default(cuid())
  runbookId          String
  runbook            Runbook  @relation(fields: [runbookId], references: [id])
  runbookVersion     Int

  // Frozen definition at execution time
  definitionSnapshot Json

  // Incident link (optional - can be manual trigger without incident)
  incidentId         String?
  incident           Incident? @relation(fields: [incidentId], references: [id])

  // Parameters used for this execution
  parameters         Json     @default("{}")

  // Execution state
  status             String   // PENDING, RUNNING, SUCCESS, FAILED
  result             Json?    // Response payload from webhook
  error              String?

  // Who triggered
  triggeredBy        String   // 'workflow' | 'manual'
  executedById       String?
  executedBy         User?    @relation(fields: [executedById], references: [id])

  // Timestamps
  startedAt          DateTime? @db.Timestamptz
  completedAt        DateTime? @db.Timestamptz
  createdAt          DateTime  @default(now()) @db.Timestamptz

  @@index([runbookId, status])
  @@index([incidentId])
  @@index([status, createdAt])
}
```

5. Add User model relations (add near other User relations):
```prisma
runbooksCreated       Runbook[]          @relation("RunbookCreatedBy")
runbooksApproved      Runbook[]          @relation("RunbookApprovedBy")
runbookVersions       RunbookVersion[]
runbookExecutions     RunbookExecution[]
```

6. Add Team model relation:
```prisma
runbooks              Runbook[]
```

7. Add Incident model relation:
```prisma
runbookExecutions     RunbookExecution[]
```

After adding models, run `npx prisma generate` to update Prisma client, then `npx prisma db push` to apply schema changes.
  </action>
  <verify>
Run `npx prisma generate` - should complete without errors.
Run `npx prisma db push` - should apply schema changes.
Run `npx tsc --noEmit` - should compile without errors.
  </verify>
  <done>
Prisma schema includes Runbook, RunbookVersion, RunbookExecution models with proper relations, indexes, and RunbookApprovalStatus enum. Database schema applied successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Runbook TypeScript Types</name>
  <files>src/types/runbook.ts</files>
  <action>
Create `src/types/runbook.ts` with TypeScript interfaces for runbook definitions.

Follow the pattern from `src/types/workflow.ts`:

```typescript
/**
 * Runbook Type Definitions
 *
 * Provides TypeScript types for runbook definitions, parameters,
 * and execution status tracking.
 *
 * @module types/runbook
 */

// ============================================================================
// Enums
// ============================================================================

/**
 * Runbook approval status lifecycle
 * DRAFT -> APPROVED -> DEPRECATED
 */
export type RunbookApprovalStatus = 'DRAFT' | 'APPROVED' | 'DEPRECATED';

/**
 * Runbook execution status
 */
export type RunbookExecutionStatus = 'PENDING' | 'RUNNING' | 'SUCCESS' | 'FAILED';

/**
 * How the runbook was triggered
 */
export type RunbookTriggerType = 'workflow' | 'manual';

// ============================================================================
// Parameter Schema Types
// ============================================================================

/**
 * Supported parameter types (flat object only per research recommendation)
 */
export type RunbookParameterType = 'string' | 'number' | 'boolean';

/**
 * Individual parameter definition
 */
export interface RunbookParameterDefinition {
  type: RunbookParameterType;
  description?: string;
  default?: string | number | boolean;
  enum?: (string | number)[];  // For select/dropdown inputs
}

/**
 * JSON Schema-like parameter schema for runbooks
 * Per research: start with flat object (string/number/boolean properties only)
 */
export interface RunbookParameterSchema {
  type: 'object';
  properties: Record<string, RunbookParameterDefinition>;
  required?: string[];
}

// ============================================================================
// Webhook Configuration Types
// ============================================================================

/**
 * Webhook authentication configuration
 * Reuses pattern from workflow webhook actions
 */
export interface RunbookWebhookAuth {
  type: 'none' | 'bearer' | 'basic' | 'oauth2' | 'custom';
  token?: string;
  username?: string;
  password?: string;
  clientId?: string;
  clientSecret?: string;
  tokenUrl?: string;
  customHeaders?: Record<string, string>;
}

// ============================================================================
// Runbook Definition Types
// ============================================================================

/**
 * Complete runbook definition stored in database JSON fields
 * Used for version snapshots and execution snapshots
 */
export interface RunbookDefinition {
  name: string;
  description: string;
  webhookUrl: string;
  webhookMethod: 'POST' | 'PUT';
  webhookHeaders: Record<string, string>;
  webhookAuth?: RunbookWebhookAuth;
  parameters: RunbookParameterSchema;
  payloadTemplate: string;
  timeoutSeconds: number;
}

// ============================================================================
// Execution Types
// ============================================================================

/**
 * Result of a runbook webhook execution
 */
export interface RunbookExecutionResult {
  success: boolean;
  statusCode?: number;
  responseBody?: string;
  error?: string;
  duration: number;
}

/**
 * Parameters to trigger a runbook execution
 */
export interface TriggerRunbookParams {
  runbookId: string;
  incidentId?: string;
  parameters: Record<string, unknown>;
  triggeredBy: RunbookTriggerType;
  executedById?: string;
}
```

Export all types from `src/types/index.ts` if that barrel file exists, or create it if it doesn't.
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Check that types are properly exported and can be imported.
  </verify>
  <done>
TypeScript type definitions created for RunbookParameterSchema, RunbookDefinition, RunbookExecutionStatus, and related types. Types match Prisma schema structure.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Runbook Service with Approval State Machine</name>
  <files>src/services/runbook/runbook.service.ts</files>
  <action>
Create `src/services/runbook/runbook.service.ts` mirroring `workflow.service.ts` pattern.

Key functionality:
1. **CRUD operations** (create, get, list, update, delete)
2. **Approval state machine** (approve, deprecate)
3. **Version history** (getVersionHistory, rollback)
4. **Team/global scoping** with permission checks

Critical per-research decisions:
- Editing an APPROVED runbook sets status back to DRAFT
- Only PLATFORM_ADMIN can call approve() or deprecate()
- Version snapshot created on every definition change
- Version snapshot created on approval

```typescript
/**
 * Runbook CRUD Service with Approval State Machine
 *
 * Provides runbook management with versioning and PLATFORM_ADMIN approval gates.
 * Mirrors workflow.service.ts pattern exactly.
 *
 * Per AUTO-07 requirements:
 * - CRUD with versioning
 * - Approval status: DRAFT -> APPROVED -> DEPRECATED
 * - Only PLATFORM_ADMIN can approve
 * - Editing APPROVED runbook reverts to DRAFT
 *
 * @module services/runbook/runbook.service
 */

import { z } from 'zod';
import { Prisma, RunbookApprovalStatus } from '@prisma/client';
import { prisma } from '../../config/database.js';
import { auditService } from '../audit.service.js';
import { permissionService } from '../permission.service.js';
import { logger } from '../../config/logger.js';
import type { AuthenticatedUser } from '../../types/auth.js';
import type { RunbookParameterSchema, RunbookWebhookAuth, RunbookDefinition } from '../../types/runbook.js';

// =============================================================================
// VALIDATION SCHEMAS
// =============================================================================

/**
 * Parameter schema validation
 */
const parameterSchemaValidator = z.object({
  type: z.literal('object'),
  properties: z.record(z.object({
    type: z.enum(['string', 'number', 'boolean']),
    description: z.string().optional(),
    default: z.union([z.string(), z.number(), z.boolean()]).optional(),
    enum: z.array(z.union([z.string(), z.number()])).optional()
  })),
  required: z.array(z.string()).optional()
});

/**
 * Webhook auth validation
 */
const webhookAuthValidator = z.object({
  type: z.enum(['none', 'bearer', 'basic', 'oauth2', 'custom']),
  token: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  clientId: z.string().optional(),
  clientSecret: z.string().optional(),
  tokenUrl: z.string().optional(),
  customHeaders: z.record(z.string()).optional()
}).optional();

/**
 * Runbook creation validation schema
 */
export const createRunbookSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100, 'Name must be 100 characters or less'),
  description: z.string().min(1, 'Description is required').max(500, 'Description must be 500 characters or less'),
  webhookUrl: z.string().url('Valid URL required'),
  webhookMethod: z.enum(['POST', 'PUT']).default('POST'),
  webhookHeaders: z.record(z.string()).optional(),
  webhookAuth: webhookAuthValidator,
  parameters: parameterSchemaValidator.default({ type: 'object', properties: {} }),
  payloadTemplate: z.string().min(1, 'Payload template is required'),
  timeoutSeconds: z.number().int().min(30).max(900).default(300),
  teamId: z.string().optional()
});

export const updateRunbookSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  description: z.string().min(1).max(500).optional(),
  webhookUrl: z.string().url().optional(),
  webhookMethod: z.enum(['POST', 'PUT']).optional(),
  webhookHeaders: z.record(z.string()).optional(),
  webhookAuth: webhookAuthValidator,
  parameters: parameterSchemaValidator.optional(),
  payloadTemplate: z.string().min(1).optional(),
  timeoutSeconds: z.number().int().min(30).max(900).optional()
});

export type CreateRunbookInput = z.infer<typeof createRunbookSchema>;
export type UpdateRunbookInput = z.infer<typeof updateRunbookSchema>;

// =============================================================================
// HELPER: Build definition snapshot
// =============================================================================

function buildDefinitionSnapshot(runbook: {
  name: string;
  description: string;
  webhookUrl: string;
  webhookMethod: string;
  webhookHeaders: unknown;
  webhookAuth: unknown;
  parameters: unknown;
  payloadTemplate: string;
  timeoutSeconds: number;
}): RunbookDefinition {
  return {
    name: runbook.name,
    description: runbook.description,
    webhookUrl: runbook.webhookUrl,
    webhookMethod: runbook.webhookMethod as 'POST' | 'PUT',
    webhookHeaders: (runbook.webhookHeaders as Record<string, string>) ?? {},
    webhookAuth: runbook.webhookAuth as RunbookWebhookAuth | undefined,
    parameters: runbook.parameters as RunbookParameterSchema,
    payloadTemplate: runbook.payloadTemplate,
    timeoutSeconds: runbook.timeoutSeconds
  };
}

// =============================================================================
// RUNBOOK SERVICE
// =============================================================================

export const runbookService = {
  /**
   * Create a new runbook (starts as DRAFT)
   */
  async create(data: CreateRunbookInput, user: AuthenticatedUser) {
    const validated = createRunbookSchema.parse(data);

    // Permission check: team admin for team-scoped, platform admin for global
    if (validated.teamId) {
      const canManage = permissionService.canManageTeam(user, validated.teamId);
      if (!canManage.allowed) {
        throw new Error('Team admin permissions required to create team runbooks');
      }
    } else {
      if (!permissionService.isPlatformAdmin(user)) {
        throw new Error('Platform admin permissions required to create global runbooks');
      }
    }

    const runbook = await prisma.$transaction(async (tx) => {
      const created = await tx.runbook.create({
        data: {
          name: validated.name,
          description: validated.description,
          webhookUrl: validated.webhookUrl,
          webhookMethod: validated.webhookMethod,
          webhookHeaders: validated.webhookHeaders ?? {},
          webhookAuth: validated.webhookAuth ?? null,
          parameters: validated.parameters,
          payloadTemplate: validated.payloadTemplate,
          timeoutSeconds: validated.timeoutSeconds,
          teamId: validated.teamId ?? null,
          version: 1,
          approvalStatus: 'DRAFT',
          createdById: user.id
        },
        include: {
          team: true,
          createdBy: {
            select: { id: true, email: true, firstName: true, lastName: true }
          }
        }
      });

      // Create initial version snapshot
      await tx.runbookVersion.create({
        data: {
          runbookId: created.id,
          version: 1,
          definition: buildDefinitionSnapshot(created) as unknown as Prisma.InputJsonValue,
          changedById: user.id,
          changeNote: 'Initial version'
        }
      });

      return created;
    });

    await auditService.log({
      action: 'runbook.created',
      userId: user.id,
      teamId: runbook.teamId ?? undefined,
      resourceType: 'runbook',
      resourceId: runbook.id,
      metadata: { name: runbook.name }
    });

    logger.info(
      { runbookId: runbook.id, name: runbook.name, userId: user.id },
      'Runbook created'
    );

    return runbook;
  },

  /**
   * Get a runbook by ID
   */
  async get(id: string, user: AuthenticatedUser) {
    const runbook = await prisma.runbook.findUnique({
      where: { id },
      include: {
        team: true,
        createdBy: {
          select: { id: true, email: true, firstName: true, lastName: true }
        },
        approvedBy: {
          select: { id: true, email: true, firstName: true, lastName: true }
        },
        versions: {
          orderBy: { version: 'desc' },
          take: 5,
          include: {
            changedBy: {
              select: { id: true, email: true, firstName: true, lastName: true }
            }
          }
        },
        executions: {
          orderBy: { createdAt: 'desc' },
          take: 10
        }
      }
    });

    if (!runbook) {
      throw new Error('Runbook not found');
    }

    // Permission check: team member or platform admin for global
    if (runbook.teamId) {
      const canView = permissionService.canViewTeam(user, runbook.teamId);
      if (!canView.allowed) {
        throw new Error('Permission denied to view runbook');
      }
    }

    return runbook;
  },

  /**
   * List runbooks with filters and pagination
   */
  async list(
    filters: {
      teamId?: string;
      approvalStatus?: RunbookApprovalStatus;
      page?: number;
      limit?: number;
    },
    user: AuthenticatedUser
  ) {
    const page = filters.page ?? 1;
    const limit = Math.min(filters.limit ?? 20, 100);
    const skip = (page - 1) * limit;

    const where: Prisma.RunbookWhereInput = {};

    if (filters.teamId) {
      where.teamId = filters.teamId;
    }

    if (filters.approvalStatus) {
      where.approvalStatus = filters.approvalStatus;
    }

    // For non-platform admins, filter to accessible runbooks
    if (!permissionService.isPlatformAdmin(user)) {
      const teamIds = user.teamMembers.map((m) => m.teamId);
      where.OR = [{ teamId: null }, { teamId: { in: teamIds } }];
    }

    const [runbooks, total] = await Promise.all([
      prisma.runbook.findMany({
        where,
        include: {
          team: true,
          createdBy: {
            select: { id: true, email: true, firstName: true, lastName: true }
          },
          _count: {
            select: { executions: true }
          }
        },
        orderBy: { updatedAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.runbook.count({ where })
    ]);

    return {
      runbooks,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    };
  },

  /**
   * Update a runbook
   *
   * IMPORTANT: If runbook is APPROVED, editing reverts it to DRAFT
   */
  async update(
    id: string,
    data: UpdateRunbookInput,
    user: AuthenticatedUser,
    changeNote?: string
  ) {
    const runbook = await prisma.runbook.findUnique({
      where: { id },
      include: { team: true }
    });

    if (!runbook) {
      throw new Error('Runbook not found');
    }

    // Permission check
    if (runbook.teamId) {
      const canManage = permissionService.canManageTeam(user, runbook.teamId);
      if (!canManage.allowed) {
        throw new Error('Team admin permissions required to update runbook');
      }
    } else {
      if (!permissionService.isPlatformAdmin(user)) {
        throw new Error('Platform admin permissions required to update global runbook');
      }
    }

    const validated = updateRunbookSchema.parse(data);

    // Check if any definition field changed
    const definitionChanged = Object.keys(validated).length > 0;
    const newVersion = definitionChanged ? runbook.version + 1 : runbook.version;

    // Per research: editing APPROVED runbook reverts to DRAFT
    const wasApproved = runbook.approvalStatus === 'APPROVED';
    const newStatus = definitionChanged && wasApproved ? 'DRAFT' : runbook.approvalStatus;

    const updated = await prisma.$transaction(async (tx) => {
      const result = await tx.runbook.update({
        where: { id },
        data: {
          name: validated.name ?? runbook.name,
          description: validated.description ?? runbook.description,
          webhookUrl: validated.webhookUrl ?? runbook.webhookUrl,
          webhookMethod: validated.webhookMethod ?? runbook.webhookMethod,
          webhookHeaders: validated.webhookHeaders ?? runbook.webhookHeaders,
          webhookAuth: validated.webhookAuth ?? runbook.webhookAuth,
          parameters: validated.parameters ?? runbook.parameters,
          payloadTemplate: validated.payloadTemplate ?? runbook.payloadTemplate,
          timeoutSeconds: validated.timeoutSeconds ?? runbook.timeoutSeconds,
          version: newVersion,
          approvalStatus: newStatus,
          // Clear approval info if reverted to DRAFT
          approvedById: newStatus === 'DRAFT' ? null : runbook.approvedById,
          approvedAt: newStatus === 'DRAFT' ? null : runbook.approvedAt
        },
        include: {
          team: true,
          createdBy: {
            select: { id: true, email: true, firstName: true, lastName: true }
          }
        }
      });

      // Create version snapshot if definition changed
      if (definitionChanged) {
        await tx.runbookVersion.create({
          data: {
            runbookId: id,
            version: newVersion,
            definition: buildDefinitionSnapshot(result) as unknown as Prisma.InputJsonValue,
            changedById: user.id,
            changeNote: wasApproved
              ? `${changeNote ?? 'Updated'} (reverted from APPROVED to DRAFT)`
              : changeNote
          }
        });
      }

      return result;
    });

    await auditService.log({
      action: 'runbook.updated',
      userId: user.id,
      teamId: updated.teamId ?? undefined,
      resourceType: 'runbook',
      resourceId: id,
      metadata: {
        version: newVersion,
        changeNote,
        fieldsChanged: Object.keys(validated),
        statusChanged: wasApproved && newStatus === 'DRAFT'
      }
    });

    if (wasApproved && newStatus === 'DRAFT') {
      logger.warn(
        { runbookId: id, userId: user.id },
        'Runbook reverted from APPROVED to DRAFT due to edit'
      );
    }

    logger.info(
      { runbookId: id, version: newVersion, userId: user.id },
      'Runbook updated'
    );

    return updated;
  },

  /**
   * Delete a runbook
   *
   * Fails if there are active (RUNNING) executions.
   */
  async delete(id: string, user: AuthenticatedUser) {
    const runbook = await prisma.runbook.findUnique({
      where: { id },
      include: { team: true }
    });

    if (!runbook) {
      throw new Error('Runbook not found');
    }

    // Permission check
    if (runbook.teamId) {
      const canManage = permissionService.canManageTeam(user, runbook.teamId);
      if (!canManage.allowed) {
        throw new Error('Team admin permissions required to delete runbook');
      }
    } else {
      if (!permissionService.isPlatformAdmin(user)) {
        throw new Error('Platform admin permissions required to delete global runbook');
      }
    }

    // Check for active executions
    const activeExecutions = await prisma.runbookExecution.count({
      where: {
        runbookId: id,
        status: 'RUNNING'
      }
    });

    if (activeExecutions > 0) {
      throw new Error(
        `Cannot delete runbook with ${activeExecutions} active execution(s)`
      );
    }

    await prisma.runbook.delete({
      where: { id }
    });

    await auditService.log({
      action: 'runbook.deleted',
      userId: user.id,
      teamId: runbook.teamId ?? undefined,
      resourceType: 'runbook',
      resourceId: id,
      severity: 'HIGH',
      metadata: { name: runbook.name }
    });

    logger.info(
      { runbookId: id, name: runbook.name, userId: user.id },
      'Runbook deleted'
    );

    return { success: true };
  },

  /**
   * Approve a runbook (PLATFORM_ADMIN only)
   *
   * Transitions: DRAFT -> APPROVED
   * Creates version snapshot on approval.
   */
  async approve(id: string, user: AuthenticatedUser) {
    if (!permissionService.isPlatformAdmin(user)) {
      throw new Error('Only platform admins can approve runbooks');
    }

    const runbook = await prisma.runbook.findUnique({ where: { id } });
    if (!runbook) {
      throw new Error('Runbook not found');
    }

    if (runbook.approvalStatus !== 'DRAFT') {
      throw new Error('Only DRAFT runbooks can be approved');
    }

    const newVersion = runbook.version + 1;

    const updated = await prisma.$transaction(async (tx) => {
      const result = await tx.runbook.update({
        where: { id },
        data: {
          approvalStatus: 'APPROVED',
          approvedById: user.id,
          approvedAt: new Date(),
          version: newVersion
        },
        include: {
          team: true,
          createdBy: {
            select: { id: true, email: true, firstName: true, lastName: true }
          },
          approvedBy: {
            select: { id: true, email: true, firstName: true, lastName: true }
          }
        }
      });

      // Create version snapshot for approval
      await tx.runbookVersion.create({
        data: {
          runbookId: id,
          version: newVersion,
          definition: buildDefinitionSnapshot(result) as unknown as Prisma.InputJsonValue,
          changedById: user.id,
          changeNote: 'Approved for production'
        }
      });

      return result;
    });

    await auditService.log({
      action: 'runbook.approved',
      userId: user.id,
      teamId: updated.teamId ?? undefined,
      resourceType: 'runbook',
      resourceId: id,
      severity: 'HIGH',
      metadata: { name: runbook.name, version: newVersion }
    });

    logger.info(
      { runbookId: id, name: runbook.name, approvedById: user.id, version: newVersion },
      'Runbook approved'
    );

    return updated;
  },

  /**
   * Deprecate a runbook (PLATFORM_ADMIN only)
   *
   * Transitions: APPROVED -> DEPRECATED
   * Deprecated runbooks cannot be executed.
   */
  async deprecate(id: string, user: AuthenticatedUser, reason?: string) {
    if (!permissionService.isPlatformAdmin(user)) {
      throw new Error('Only platform admins can deprecate runbooks');
    }

    const runbook = await prisma.runbook.findUnique({ where: { id } });
    if (!runbook) {
      throw new Error('Runbook not found');
    }

    if (runbook.approvalStatus !== 'APPROVED') {
      throw new Error('Only APPROVED runbooks can be deprecated');
    }

    const newVersion = runbook.version + 1;

    const updated = await prisma.$transaction(async (tx) => {
      const result = await tx.runbook.update({
        where: { id },
        data: {
          approvalStatus: 'DEPRECATED',
          version: newVersion
        },
        include: {
          team: true,
          createdBy: {
            select: { id: true, email: true, firstName: true, lastName: true }
          }
        }
      });

      // Create version snapshot for deprecation
      await tx.runbookVersion.create({
        data: {
          runbookId: id,
          version: newVersion,
          definition: buildDefinitionSnapshot(result) as unknown as Prisma.InputJsonValue,
          changedById: user.id,
          changeNote: reason ?? 'Deprecated'
        }
      });

      return result;
    });

    await auditService.log({
      action: 'runbook.deprecated',
      userId: user.id,
      teamId: updated.teamId ?? undefined,
      resourceType: 'runbook',
      resourceId: id,
      severity: 'HIGH',
      metadata: { name: runbook.name, reason, version: newVersion }
    });

    logger.info(
      { runbookId: id, name: runbook.name, deprecatedById: user.id, reason },
      'Runbook deprecated'
    );

    return updated;
  },

  /**
   * Get version history for a runbook
   */
  async getVersionHistory(id: string) {
    const versions = await prisma.runbookVersion.findMany({
      where: { runbookId: id },
      orderBy: { version: 'desc' },
      include: {
        changedBy: {
          select: { id: true, email: true, firstName: true, lastName: true }
        }
      }
    });

    return versions;
  },

  /**
   * Rollback to a previous version
   *
   * Creates new version with rolled-back definition.
   * NOTE: Rollback sets status to DRAFT (requires re-approval).
   */
  async rollback(id: string, toVersion: number, user: AuthenticatedUser) {
    const runbook = await prisma.runbook.findUnique({
      where: { id },
      include: { team: true }
    });

    if (!runbook) {
      throw new Error('Runbook not found');
    }

    // Permission check
    if (runbook.teamId) {
      const canManage = permissionService.canManageTeam(user, runbook.teamId);
      if (!canManage.allowed) {
        throw new Error('Team admin permissions required to rollback runbook');
      }
    } else {
      if (!permissionService.isPlatformAdmin(user)) {
        throw new Error('Platform admin permissions required to rollback global runbook');
      }
    }

    const targetVersion = await prisma.runbookVersion.findUnique({
      where: {
        runbookId_version: {
          runbookId: id,
          version: toVersion
        }
      }
    });

    if (!targetVersion) {
      throw new Error(`Version ${toVersion} not found`);
    }

    const definition = targetVersion.definition as unknown as RunbookDefinition;
    const newVersion = runbook.version + 1;

    const updated = await prisma.$transaction(async (tx) => {
      const result = await tx.runbook.update({
        where: { id },
        data: {
          name: definition.name,
          description: definition.description,
          webhookUrl: definition.webhookUrl,
          webhookMethod: definition.webhookMethod,
          webhookHeaders: definition.webhookHeaders,
          webhookAuth: definition.webhookAuth ?? null,
          parameters: definition.parameters,
          payloadTemplate: definition.payloadTemplate,
          timeoutSeconds: definition.timeoutSeconds,
          version: newVersion,
          // Rollback reverts to DRAFT (requires re-approval)
          approvalStatus: 'DRAFT',
          approvedById: null,
          approvedAt: null
        },
        include: {
          team: true,
          createdBy: {
            select: { id: true, email: true, firstName: true, lastName: true }
          }
        }
      });

      await tx.runbookVersion.create({
        data: {
          runbookId: id,
          version: newVersion,
          definition: targetVersion.definition as Prisma.InputJsonValue,
          changedById: user.id,
          changeNote: `Rolled back to version ${toVersion}`
        }
      });

      return result;
    });

    await auditService.log({
      action: 'runbook.rolledBack',
      userId: user.id,
      teamId: updated.teamId ?? undefined,
      resourceType: 'runbook',
      resourceId: id,
      metadata: {
        fromVersion: runbook.version,
        toVersion,
        newVersion
      }
    });

    logger.info(
      { runbookId: id, fromVersion: runbook.version, toVersion, userId: user.id },
      'Runbook rolled back'
    );

    return updated;
  }
};
```

Create directory structure: `mkdir -p src/services/runbook`
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Run `npm test -- --testPathPattern=runbook` - if tests exist, they should pass.
Verify imports work: service should import successfully.
  </verify>
  <done>
runbook.service.ts provides complete CRUD operations, approval state machine (approve, deprecate), version history, and rollback. Editing APPROVED runbooks reverts to DRAFT. Only PLATFORM_ADMIN can approve/deprecate.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma generate && npx prisma db push` - database schema applied
2. `npx tsc --noEmit` - no TypeScript errors
3. Runbook models exist in Prisma schema with proper relations
4. runbook.service.ts exports runbookService with create, get, list, update, delete, approve, deprecate, getVersionHistory, rollback
</verification>

<success_criteria>
- Prisma schema includes Runbook, RunbookVersion, RunbookExecution models
- RunbookApprovalStatus enum has DRAFT, APPROVED, DEPRECATED values
- TypeScript types defined for parameter schemas and execution
- runbook.service.ts provides full CRUD with approval state machine
- Version snapshots created on definition changes and approval
- Editing APPROVED runbook reverts to DRAFT status
- PLATFORM_ADMIN check enforced for approve/deprecate operations
</success_criteria>

<output>
After completion, create `.planning/phases/15-runbook-automation-foundation/15-01-SUMMARY.md`
</output>

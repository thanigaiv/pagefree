---
phase: 15-runbook-automation-foundation
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - src/routes/runbook.routes.ts
  - src/services/runbook/runbook-executor.service.ts
  - src/queues/runbook.queue.ts
  - src/workers/runbook.worker.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "REST API endpoints allow CRUD operations on runbooks"
    - "Only APPROVED runbooks can be executed"
    - "Runbook execution posts to configured webhook with templated payload"
    - "Failed webhook requests retry 3 times with exponential backoff"
    - "Every execution creates audit trail entry"
    - "Parameters are validated against JSON schema before execution"
  artifacts:
    - path: "src/routes/runbook.routes.ts"
      provides: "REST API endpoints for runbooks"
      exports: ["runbookRoutes"]
    - path: "src/services/runbook/runbook-executor.service.ts"
      provides: "Webhook execution with retry logic"
      exports: ["runbookExecutor"]
    - path: "src/queues/runbook.queue.ts"
      provides: "BullMQ queue for runbook jobs"
      exports: ["runbookQueue", "scheduleRunbook"]
    - path: "src/workers/runbook.worker.ts"
      provides: "Worker processing runbook jobs"
      exports: ["runbookWorker"]
  key_links:
    - from: "src/routes/runbook.routes.ts"
      to: "src/services/runbook/runbook.service.ts"
      via: "service calls"
      pattern: "runbookService\\."
    - from: "src/services/runbook/runbook-executor.service.ts"
      to: "src/services/actions/webhook.action.ts"
      via: "webhook execution"
      pattern: "executeWebhookWithRetry"
    - from: "src/workers/runbook.worker.ts"
      to: "src/services/runbook/runbook-executor.service.ts"
      via: "job processing"
      pattern: "runbookExecutor\\.execute"
---

<objective>
Create REST API routes, webhook executor, and BullMQ queue infrastructure for runbook execution.

Purpose: Enable users to manage runbooks via API and execute approved runbooks against webhook endpoints with retry logic, completing the AUTO-07 and AUTO-08 requirements.

Output: runbook.routes.ts (REST API), runbook-executor.service.ts (webhook execution with retry), runbook.queue.ts and runbook.worker.ts (async processing), and app wiring.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-runbook-automation-foundation/15-RESEARCH.md

# Prior plan context
@.planning/phases/15-runbook-automation-foundation/15-01-SUMMARY.md

# Pattern references (mirror these exactly)
@src/routes/workflow.routes.ts (REST API pattern)
@src/services/actions/webhook.action.ts (executeWebhookWithRetry pattern)
@src/services/workflow/template.service.ts (Handlebars templating)
@src/queues/workflow.queue.ts (BullMQ queue pattern)
@src/workers/workflow.worker.ts (worker pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Runbook REST API Routes</name>
  <files>src/routes/runbook.routes.ts</files>
  <action>
Create `src/routes/runbook.routes.ts` following the `workflow.routes.ts` pattern exactly.

Endpoints to implement:
- `POST /api/runbooks` - Create runbook (DRAFT)
- `GET /api/runbooks` - List runbooks with filters
- `GET /api/runbooks/:id` - Get runbook details
- `PUT /api/runbooks/:id` - Update runbook
- `DELETE /api/runbooks/:id` - Delete runbook
- `POST /api/runbooks/:id/approve` - Approve runbook (PLATFORM_ADMIN only)
- `POST /api/runbooks/:id/deprecate` - Deprecate runbook (PLATFORM_ADMIN only)
- `GET /api/runbooks/:id/versions` - Get version history
- `POST /api/runbooks/:id/rollback` - Rollback to version
- `POST /api/runbooks/:id/execute` - Trigger execution

```typescript
/**
 * Runbook REST API Routes
 *
 * Provides REST API endpoints for runbook CRUD operations,
 * approval workflow, version history, and execution trigger.
 *
 * Per AUTO-07/AUTO-08 requirements:
 * - Team admin for team-scoped runbooks
 * - Platform admin for global runbooks and approval
 * - Only APPROVED runbooks can be executed
 * - Parameter validation before execution
 *
 * @module routes/runbook.routes
 */

import { Router, Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { RunbookApprovalStatus } from '@prisma/client';
import { requireAuth } from '../middleware/auth.js';
import { runbookService, createRunbookSchema, updateRunbookSchema } from '../services/runbook/runbook.service.js';
import { runbookExecutor, validateParameters } from '../services/runbook/runbook-executor.service.js';
import { scheduleRunbook } from '../queues/runbook.queue.js';
import { prisma } from '../config/database.js';
import { auditService } from '../services/audit.service.js';
import { logger } from '../config/logger.js';
import type { AuthenticatedUser } from '../types/auth.js';
import type { RunbookParameterSchema } from '../types/runbook.js';

export const runbookRoutes = Router();

// All runbook routes require authentication
runbookRoutes.use(requireAuth);

// =============================================================================
// VALIDATION SCHEMAS
// =============================================================================

const listRunbooksSchema = z.object({
  teamId: z.string().optional(),
  approvalStatus: z.enum(['DRAFT', 'APPROVED', 'DEPRECATED']).optional(),
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20)
});

const rollbackSchema = z.object({
  toVersion: z.number().int().min(1)
});

const executeRunbookSchema = z.object({
  incidentId: z.string().optional(),
  parameters: z.record(z.unknown()).default({})
});

const deprecateSchema = z.object({
  reason: z.string().max(500).optional()
});

// =============================================================================
// CRUD ROUTES
// =============================================================================

/**
 * POST /api/runbooks - Create runbook
 */
runbookRoutes.post('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const input = createRunbookSchema.parse(req.body);
    const user = req.user as AuthenticatedUser;

    const runbook = await runbookService.create(input, user);

    return res.status(201).json({ runbook });
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.issues
      });
    }
    if (error instanceof Error) {
      if (error.message.includes('permissions required')) {
        return res.status(403).json({ error: error.message });
      }
      if (error.message.includes('required')) {
        return res.status(400).json({ error: error.message });
      }
    }
    return next(error);
  }
});

/**
 * GET /api/runbooks - List runbooks
 */
runbookRoutes.get('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const filters = listRunbooksSchema.parse(req.query);
    const user = req.user as AuthenticatedUser;

    const result = await runbookService.list(
      {
        ...filters,
        approvalStatus: filters.approvalStatus as RunbookApprovalStatus | undefined
      },
      user
    );

    return res.json(result);
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Invalid query parameters',
        details: error.issues
      });
    }
    return next(error);
  }
});

/**
 * GET /api/runbooks/:id - Get runbook details
 */
runbookRoutes.get('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const user = req.user as AuthenticatedUser;
    const runbook = await runbookService.get(req.params.id, user);

    return res.json({ runbook });
  } catch (error: unknown) {
    if (error instanceof Error) {
      if (error.message === 'Runbook not found') {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('Permission denied')) {
        return res.status(403).json({ error: error.message });
      }
    }
    return next(error);
  }
});

/**
 * PUT /api/runbooks/:id - Update runbook
 */
runbookRoutes.put('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const input = updateRunbookSchema.parse(req.body);
    const user = req.user as AuthenticatedUser;
    const changeNote = req.body.changeNote as string | undefined;

    const runbook = await runbookService.update(req.params.id, input, user, changeNote);

    return res.json({ runbook });
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.issues
      });
    }
    if (error instanceof Error) {
      if (error.message === 'Runbook not found') {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('permissions required')) {
        return res.status(403).json({ error: error.message });
      }
    }
    return next(error);
  }
});

/**
 * DELETE /api/runbooks/:id - Delete runbook
 */
runbookRoutes.delete('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const user = req.user as AuthenticatedUser;
    await runbookService.delete(req.params.id, user);

    return res.status(204).send();
  } catch (error: unknown) {
    if (error instanceof Error) {
      if (error.message === 'Runbook not found') {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('permissions required')) {
        return res.status(403).json({ error: error.message });
      }
      if (error.message.includes('active execution')) {
        return res.status(409).json({ error: error.message });
      }
    }
    return next(error);
  }
});

// =============================================================================
// APPROVAL ROUTES
// =============================================================================

/**
 * POST /api/runbooks/:id/approve - Approve runbook (PLATFORM_ADMIN only)
 */
runbookRoutes.post('/:id/approve', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const user = req.user as AuthenticatedUser;
    const runbook = await runbookService.approve(req.params.id, user);

    return res.json({ runbook });
  } catch (error: unknown) {
    if (error instanceof Error) {
      if (error.message === 'Runbook not found') {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('platform admin')) {
        return res.status(403).json({ error: error.message });
      }
      if (error.message.includes('Only DRAFT')) {
        return res.status(400).json({ error: error.message });
      }
    }
    return next(error);
  }
});

/**
 * POST /api/runbooks/:id/deprecate - Deprecate runbook (PLATFORM_ADMIN only)
 */
runbookRoutes.post('/:id/deprecate', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { reason } = deprecateSchema.parse(req.body);
    const user = req.user as AuthenticatedUser;
    const runbook = await runbookService.deprecate(req.params.id, user, reason);

    return res.json({ runbook });
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.issues
      });
    }
    if (error instanceof Error) {
      if (error.message === 'Runbook not found') {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('platform admin')) {
        return res.status(403).json({ error: error.message });
      }
      if (error.message.includes('Only APPROVED')) {
        return res.status(400).json({ error: error.message });
      }
    }
    return next(error);
  }
});

// =============================================================================
// VERSION ROUTES
// =============================================================================

/**
 * GET /api/runbooks/:id/versions - Get version history
 */
runbookRoutes.get('/:id/versions', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const versions = await runbookService.getVersionHistory(req.params.id);

    return res.json({ versions });
  } catch (error) {
    return next(error);
  }
});

/**
 * POST /api/runbooks/:id/rollback - Rollback to version
 */
runbookRoutes.post('/:id/rollback', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { toVersion } = rollbackSchema.parse(req.body);
    const user = req.user as AuthenticatedUser;

    const runbook = await runbookService.rollback(req.params.id, toVersion, user);

    return res.json({ runbook });
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.issues
      });
    }
    if (error instanceof Error) {
      if (error.message === 'Runbook not found') {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('Version') && error.message.includes('not found')) {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('permissions required')) {
        return res.status(403).json({ error: error.message });
      }
    }
    return next(error);
  }
});

// =============================================================================
// EXECUTION ROUTES
// =============================================================================

/**
 * POST /api/runbooks/:id/execute - Trigger execution
 *
 * Only APPROVED runbooks can be executed.
 * Parameters are validated against the runbook's JSON schema before queuing.
 */
runbookRoutes.post('/:id/execute', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { incidentId, parameters } = executeRunbookSchema.parse(req.body);
    const user = req.user as AuthenticatedUser;

    // Load runbook
    const runbook = await runbookService.get(req.params.id, user);

    // Check approval status (per research pitfall #1)
    if (runbook.approvalStatus !== 'APPROVED') {
      return res.status(400).json({
        error: 'Only APPROVED runbooks can be executed',
        currentStatus: runbook.approvalStatus
      });
    }

    // Validate parameters against schema (per research pitfall #3)
    const paramSchema = runbook.parameters as unknown as RunbookParameterSchema;
    const validation = validateParameters(paramSchema, parameters);
    if (!validation.valid) {
      return res.status(400).json({
        error: 'Invalid parameters',
        details: validation.errors
      });
    }

    // If incidentId provided, verify incident exists
    if (incidentId) {
      const incident = await prisma.incident.findUnique({
        where: { id: incidentId }
      });
      if (!incident) {
        return res.status(404).json({ error: 'Incident not found' });
      }
    }

    // Create execution record (per research pitfall #2 - snapshot definition)
    const execution = await prisma.runbookExecution.create({
      data: {
        runbookId: runbook.id,
        runbookVersion: runbook.version,
        definitionSnapshot: {
          name: runbook.name,
          description: runbook.description,
          webhookUrl: runbook.webhookUrl,
          webhookMethod: runbook.webhookMethod,
          webhookHeaders: runbook.webhookHeaders,
          webhookAuth: runbook.webhookAuth,
          parameters: runbook.parameters,
          payloadTemplate: runbook.payloadTemplate,
          timeoutSeconds: runbook.timeoutSeconds
        },
        incidentId: incidentId ?? null,
        parameters,
        status: 'PENDING',
        triggeredBy: 'manual',
        executedById: user.id
      }
    });

    // Queue for async execution
    await scheduleRunbook(execution.id, runbook.id, incidentId);

    // Audit log
    await auditService.log({
      action: 'runbook.execution.triggered',
      userId: user.id,
      teamId: runbook.teamId ?? undefined,
      resourceType: 'runbook',
      resourceId: runbook.id,
      metadata: {
        executionId: execution.id,
        incidentId,
        triggeredBy: 'manual',
        parameters
      }
    });

    logger.info(
      {
        executionId: execution.id,
        runbookId: runbook.id,
        incidentId,
        userId: user.id
      },
      'Runbook execution triggered'
    );

    return res.status(202).json({
      execution: {
        id: execution.id,
        status: 'PENDING'
      }
    });
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation failed',
        details: error.issues
      });
    }
    if (error instanceof Error) {
      if (error.message === 'Runbook not found') {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('Permission denied')) {
        return res.status(403).json({ error: error.message });
      }
    }
    return next(error);
  }
});

/**
 * GET /api/runbooks/:id/executions - List executions for a runbook
 */
runbookRoutes.get('/:id/executions', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const user = req.user as AuthenticatedUser;

    // Verify access to runbook
    await runbookService.get(req.params.id, user);

    const executions = await prisma.runbookExecution.findMany({
      where: { runbookId: req.params.id },
      orderBy: { createdAt: 'desc' },
      take: 50,
      include: {
        executedBy: {
          select: { id: true, email: true, firstName: true, lastName: true }
        },
        incident: {
          select: { id: true, status: true, priority: true }
        }
      }
    });

    return res.json({ executions });
  } catch (error: unknown) {
    if (error instanceof Error) {
      if (error.message === 'Runbook not found') {
        return res.status(404).json({ error: error.message });
      }
      if (error.message.includes('Permission denied')) {
        return res.status(403).json({ error: error.message });
      }
    }
    return next(error);
  }
});

/**
 * GET /api/runbooks/executions/:executionId - Get execution details
 */
runbookRoutes.get('/executions/:executionId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const execution = await prisma.runbookExecution.findUnique({
      where: { id: req.params.executionId },
      include: {
        runbook: {
          select: { id: true, name: true, teamId: true }
        },
        executedBy: {
          select: { id: true, email: true, firstName: true, lastName: true }
        },
        incident: {
          select: { id: true, status: true, priority: true }
        }
      }
    });

    if (!execution) {
      return res.status(404).json({ error: 'Execution not found' });
    }

    return res.json({ execution });
  } catch (error) {
    return next(error);
  }
});
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Routes should be properly typed and follow error handling patterns.
  </verify>
  <done>
REST API routes created for all CRUD operations, approval workflow, version history, and execution trigger. Parameter validation enforced before execution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Runbook Executor Service with Parameter Validation</name>
  <files>src/services/runbook/runbook-executor.service.ts</files>
  <action>
Create `src/services/runbook/runbook-executor.service.ts` that handles webhook execution with retry logic.

Key responsibilities:
1. Validate parameters against JSON Schema using Zod
2. Build template context (reuse buildTemplateContext from template.service.ts)
3. Execute webhook with retry (reuse executeWebhookWithRetry from webhook.action.ts)
4. Update execution status and store result

```typescript
/**
 * Runbook Executor Service
 *
 * Handles runbook webhook execution with:
 * - Parameter validation against JSON Schema
 * - Handlebars template interpolation
 * - Webhook execution with exponential backoff retry
 * - Execution status tracking and audit logging
 *
 * Per AUTO-08 requirements:
 * - 3 retries with exponential backoff
 * - Full audit trail
 * - Definition snapshot at execution time
 *
 * @module services/runbook/runbook-executor.service
 */

import { z } from 'zod';
import { Prisma } from '@prisma/client';
import { prisma } from '../../config/database.js';
import { auditService } from '../audit.service.js';
import { logger } from '../../config/logger.js';
import { buildTemplateContext, interpolateTemplate, type TemplateContext } from '../workflow/template.service.js';
import { executeWebhookWithRetry, type WebhookConfig, type WebhookAuth } from '../actions/webhook.action.js';
import type {
  RunbookParameterSchema,
  RunbookDefinition,
  RunbookExecutionResult,
  RunbookWebhookAuth
} from '../../types/runbook.js';

// =============================================================================
// PARAMETER VALIDATION
// =============================================================================

/**
 * Validate parameters against a JSON Schema-like definition using Zod.
 *
 * @param schema - Parameter schema from runbook definition
 * @param values - Parameter values to validate
 * @returns Validation result with errors if invalid
 */
export function validateParameters(
  schema: RunbookParameterSchema,
  values: Record<string, unknown>
): { valid: boolean; errors?: string[] } {
  try {
    // Build Zod schema from JSON Schema definition
    const zodSchema = z.object(
      Object.fromEntries(
        Object.entries(schema.properties).map(([key, prop]) => {
          let fieldSchema: z.ZodTypeAny;

          switch (prop.type) {
            case 'string':
              if (prop.enum && prop.enum.length > 0) {
                // Type assertion needed for Zod enum
                const enumValues = prop.enum as [string, ...string[]];
                fieldSchema = z.enum(enumValues);
              } else {
                fieldSchema = z.string();
              }
              break;
            case 'number':
              if (prop.enum && prop.enum.length > 0) {
                const enumValues = prop.enum as number[];
                fieldSchema = z.number().refine(
                  (val) => enumValues.includes(val),
                  { message: `Must be one of: ${enumValues.join(', ')}` }
                );
              } else {
                fieldSchema = z.number();
              }
              break;
            case 'boolean':
              fieldSchema = z.boolean();
              break;
            default:
              fieldSchema = z.unknown();
          }

          // Handle default values
          if (prop.default !== undefined) {
            fieldSchema = fieldSchema.default(prop.default);
          }

          // Handle optional vs required
          const isRequired = schema.required?.includes(key) ?? false;
          return [key, isRequired ? fieldSchema : fieldSchema.optional()];
        })
      )
    );

    const result = zodSchema.safeParse(values);

    if (result.success) {
      return { valid: true };
    }

    return {
      valid: false,
      errors: result.error.issues.map((i) => `${i.path.join('.')}: ${i.message}`)
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown validation error';
    return {
      valid: false,
      errors: [errorMessage]
    };
  }
}

// =============================================================================
// CONTEXT BUILDING
// =============================================================================

/**
 * Extended template context for runbooks.
 * Adds runbook-specific fields and user parameters.
 */
interface RunbookTemplateContext extends TemplateContext {
  runbook: {
    id: string;
    name: string;
    version: number;
  };
  params: Record<string, unknown>;
}

/**
 * Build extended template context for runbook execution.
 *
 * @param incidentId - Optional incident ID for context
 * @param runbookId - Runbook ID
 * @param executionId - Execution ID
 * @param runbookName - Runbook name
 * @param runbookVersion - Runbook version
 * @param parameters - User-provided parameters
 * @returns Extended template context
 */
async function buildRunbookContext(
  incidentId: string | null,
  runbookId: string,
  executionId: string,
  runbookName: string,
  runbookVersion: number,
  parameters: Record<string, unknown>
): Promise<RunbookTemplateContext> {
  // If we have an incident, use the standard context builder
  if (incidentId) {
    const baseContext = await buildTemplateContext(
      incidentId,
      runbookId,
      executionId,
      runbookName
    );

    return {
      ...baseContext,
      runbook: {
        id: runbookId,
        name: runbookName,
        version: runbookVersion
      },
      params: parameters
    };
  }

  // For manual execution without incident, build minimal context
  return {
    incident: {
      id: '',
      title: 'Manual Execution',
      priority: 'MEDIUM',
      status: 'OPEN',
      createdAt: new Date().toISOString(),
      teamName: '',
      metadata: {}
    },
    team: {
      id: '',
      name: ''
    },
    workflow: {
      id: runbookId,
      name: runbookName,
      executionId
    },
    runbook: {
      id: runbookId,
      name: runbookName,
      version: runbookVersion
    },
    params: parameters
  };
}

// =============================================================================
// EXECUTOR SERVICE
// =============================================================================

export const runbookExecutor = {
  /**
   * Execute a runbook against its webhook endpoint.
   *
   * Per AUTO-08 requirements:
   * - Validates runbook is still APPROVED before executing
   * - Builds execution context with incident data + parameters
   * - Posts to webhook with 3 retries + exponential backoff
   * - Stores execution result
   *
   * @param executionId - ID of the RunbookExecution record
   * @returns Execution result
   */
  async execute(executionId: string): Promise<RunbookExecutionResult> {
    const startTime = Date.now();

    // Load execution record
    const execution = await prisma.runbookExecution.findUnique({
      where: { id: executionId },
      include: {
        runbook: true
      }
    });

    if (!execution) {
      throw new Error(`Execution not found: ${executionId}`);
    }

    // Per research pitfall #1: Re-check approval status
    // (Status may have changed between queue add and worker processing)
    if (execution.runbook.approvalStatus !== 'APPROVED') {
      logger.warn(
        { executionId, runbookId: execution.runbookId, status: execution.runbook.approvalStatus },
        'Runbook no longer APPROVED, skipping execution'
      );

      await prisma.runbookExecution.update({
        where: { id: executionId },
        data: {
          status: 'FAILED',
          error: `Runbook is ${execution.runbook.approvalStatus}, not APPROVED`,
          completedAt: new Date()
        }
      });

      return {
        success: false,
        error: `Runbook is ${execution.runbook.approvalStatus}, not APPROVED`,
        duration: Date.now() - startTime
      };
    }

    // Update status to RUNNING
    await prisma.runbookExecution.update({
      where: { id: executionId },
      data: {
        status: 'RUNNING',
        startedAt: new Date()
      }
    });

    try {
      // Use snapshotted definition (per research pitfall #2)
      const definition = execution.definitionSnapshot as unknown as RunbookDefinition;
      const parameters = execution.parameters as Record<string, unknown>;

      // Build template context
      const context = await buildRunbookContext(
        execution.incidentId,
        execution.runbookId,
        executionId,
        definition.name,
        execution.runbookVersion,
        parameters
      );

      // Interpolate payload template
      const payload = interpolateTemplate(definition.payloadTemplate, context as TemplateContext);

      // Build webhook config
      const webhookConfig: WebhookConfig = {
        url: definition.webhookUrl,
        method: definition.webhookMethod as 'POST' | 'PUT' | 'PATCH',
        headers: definition.webhookHeaders,
        body: payload,
        auth: (definition.webhookAuth ?? { type: 'none' }) as WebhookAuth
      };

      // Execute with retry (3 attempts per AUTO-08)
      // Use runbook timeout or default 30s per request
      const result = await executeWebhookWithRetry(
        webhookConfig,
        context as TemplateContext,
        3,  // maxAttempts per AUTO-08 requirement
        1000  // initialDelayMs (1s, 2s, 4s backoff)
      );

      const duration = Date.now() - startTime;

      // Update execution record with result
      await prisma.runbookExecution.update({
        where: { id: executionId },
        data: {
          status: result.success ? 'SUCCESS' : 'FAILED',
          result: result.success ? {
            statusCode: result.statusCode,
            responseBody: result.responseBody
          } : null,
          error: result.error ?? null,
          completedAt: new Date()
        }
      });

      // Audit log
      await auditService.log({
        action: result.success ? 'runbook.execution.succeeded' : 'runbook.execution.failed',
        resourceType: 'runbook',
        resourceId: execution.runbookId,
        severity: result.success ? 'INFO' : 'HIGH',
        metadata: {
          executionId,
          incidentId: execution.incidentId,
          duration,
          statusCode: result.statusCode,
          error: result.error
        }
      });

      logger.info(
        {
          executionId,
          runbookId: execution.runbookId,
          success: result.success,
          duration,
          statusCode: result.statusCode
        },
        result.success ? 'Runbook execution succeeded' : 'Runbook execution failed'
      );

      return {
        ...result,
        duration
      };
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      // Update execution record with error
      await prisma.runbookExecution.update({
        where: { id: executionId },
        data: {
          status: 'FAILED',
          error: errorMessage,
          completedAt: new Date()
        }
      });

      // Audit log
      await auditService.log({
        action: 'runbook.execution.failed',
        resourceType: 'runbook',
        resourceId: execution.runbookId,
        severity: 'HIGH',
        metadata: {
          executionId,
          incidentId: execution.incidentId,
          duration,
          error: errorMessage
        }
      });

      logger.error(
        {
          executionId,
          runbookId: execution.runbookId,
          error: errorMessage,
          duration
        },
        'Runbook execution error'
      );

      return {
        success: false,
        error: errorMessage,
        duration
      };
    }
  }
};
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Verify validateParameters function handles all parameter types.
Verify executor reuses existing webhook action and template services.
  </verify>
  <done>
runbook-executor.service.ts provides parameter validation via Zod, template context building, and webhook execution with 3-retry exponential backoff. Full audit trail on success/failure.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Runbook Queue and Worker</name>
  <files>src/queues/runbook.queue.ts, src/workers/runbook.worker.ts</files>
  <action>
Create BullMQ queue and worker for async runbook execution, following the workflow queue patterns.

**src/queues/runbook.queue.ts:**
```typescript
/**
 * Runbook BullMQ Queue
 *
 * Manages runbook execution jobs.
 * Follows workflow.queue.ts pattern for consistency.
 *
 * @module queues/runbook.queue
 */

import { Queue } from 'bullmq';
import { getRedisConnectionOptions } from '../config/redis.js';
import { logger } from '../config/logger.js';

// ============================================================================
// Types
// ============================================================================

/**
 * Runbook job data passed to the worker
 */
export interface RunbookJobData {
  /** ID of the RunbookExecution record */
  executionId: string;
  /** ID of the runbook being executed */
  runbookId: string;
  /** ID of the incident (optional) */
  incidentId?: string;
}

// ============================================================================
// Queue
// ============================================================================

/**
 * Runbook execution queue
 *
 * Jobs are processed with:
 * - No automatic retry (executor has its own retry logic)
 * - Failed jobs kept for debugging
 * - Completed jobs removed
 */
export const runbookQueue = new Queue<RunbookJobData>('runbook', {
  connection: getRedisConnectionOptions(),
  defaultJobOptions: {
    removeOnComplete: true,
    removeOnFail: false, // Keep failed jobs for debugging
    attempts: 1 // No retry at job level - executor has its own retry
  }
});

// ============================================================================
// Queue Operations
// ============================================================================

/**
 * Schedule a runbook for execution.
 *
 * @param executionId - ID of the RunbookExecution record
 * @param runbookId - ID of the runbook to execute
 * @param incidentId - Optional incident ID
 * @returns Job ID (same as executionId)
 */
export async function scheduleRunbook(
  executionId: string,
  runbookId: string,
  incidentId?: string
): Promise<string> {
  await runbookQueue.add(
    'execute',
    {
      executionId,
      runbookId,
      incidentId
    },
    {
      jobId: executionId // Use execution ID as job ID for idempotency
    }
  );

  logger.info(
    { executionId, runbookId, incidentId },
    'Scheduled runbook for execution'
  );

  return executionId;
}

/**
 * Cancel a pending runbook execution.
 *
 * @param executionId - ID of the execution to cancel
 * @returns True if job was found and removed
 */
export async function cancelRunbook(executionId: string): Promise<boolean> {
  try {
    const job = await runbookQueue.getJob(executionId);
    if (job) {
      await job.remove();
      logger.info({ executionId }, 'Cancelled runbook execution');
      return true;
    }
    return false;
  } catch (error) {
    logger.error({ executionId, error }, 'Failed to cancel runbook execution');
    return false;
  }
}

/**
 * Get runbook queue statistics for health checks.
 *
 * @returns Queue metrics
 */
export async function getRunbookQueueStats() {
  const [waiting, active, delayed, failed] = await Promise.all([
    runbookQueue.getWaitingCount(),
    runbookQueue.getActiveCount(),
    runbookQueue.getDelayedCount(),
    runbookQueue.getFailedCount()
  ]);

  return { waiting, active, delayed, failed };
}
```

**src/workers/runbook.worker.ts:**
```typescript
/**
 * Runbook BullMQ Worker
 *
 * Processes runbook execution jobs from the queue.
 * Follows workflow.worker.ts pattern for consistency.
 *
 * @module workers/runbook.worker
 */

import { Worker, Job } from 'bullmq';
import { getRedisConnectionOptions } from '../config/redis.js';
import { logger } from '../config/logger.js';
import { runbookExecutor } from '../services/runbook/runbook-executor.service.js';
import type { RunbookJobData } from '../queues/runbook.queue.js';

// ============================================================================
// Worker
// ============================================================================

/**
 * Process a runbook execution job
 */
async function processRunbookJob(job: Job<RunbookJobData>): Promise<void> {
  const { executionId, runbookId, incidentId } = job.data;

  logger.info(
    { executionId, runbookId, incidentId, jobId: job.id },
    'Processing runbook execution job'
  );

  try {
    const result = await runbookExecutor.execute(executionId);

    if (!result.success) {
      logger.warn(
        { executionId, runbookId, error: result.error },
        'Runbook execution completed with failure'
      );
      // Don't throw - failure is recorded in execution record
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.error(
      { executionId, runbookId, error: errorMessage },
      'Runbook job processing error'
    );
    // Re-throw to mark job as failed (for debugging)
    throw error;
  }
}

/**
 * Runbook worker instance
 */
export const runbookWorker = new Worker<RunbookJobData>(
  'runbook',
  processRunbookJob,
  {
    connection: getRedisConnectionOptions(),
    concurrency: 5 // Process up to 5 runbooks in parallel
  }
);

// Event handlers for logging
runbookWorker.on('completed', (job) => {
  logger.debug(
    { jobId: job.id, executionId: job.data.executionId },
    'Runbook job completed'
  );
});

runbookWorker.on('failed', (job, error) => {
  logger.error(
    { jobId: job?.id, executionId: job?.data?.executionId, error: error.message },
    'Runbook job failed'
  );
});

runbookWorker.on('error', (error) => {
  logger.error({ error: error.message }, 'Runbook worker error');
});

/**
 * Graceful shutdown
 */
export async function closeRunbookWorker(): Promise<void> {
  await runbookWorker.close();
  logger.info('Runbook worker closed');
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Verify queue and worker follow established patterns from workflow.queue.ts and workflow.worker.ts.
  </verify>
  <done>
BullMQ queue (runbook.queue.ts) and worker (runbook.worker.ts) created for async runbook execution. Worker calls runbookExecutor.execute() to process jobs with concurrency of 5.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire Routes and Worker into Application</name>
  <files>src/index.ts</files>
  <action>
Add runbook routes and worker to the Express application following the pattern for workflow wiring.

1. Import runbook routes and worker at the top of `src/index.ts`:
```typescript
import { runbookRoutes } from './routes/runbook.routes.js';
import { runbookWorker, closeRunbookWorker } from './workers/runbook.worker.js';
```

2. Mount runbook routes (add near other API routes):
```typescript
app.use('/api/runbooks', runbookRoutes);
```

3. Add worker shutdown to graceful shutdown handler (find the existing shutdown code and add):
```typescript
// In shutdown handler, add:
await closeRunbookWorker();
```

4. Log worker startup (near other worker startups):
```typescript
logger.info('Runbook worker started');
```

The exact location will depend on the current structure of index.ts, but follow the patterns used for workflow routes and worker.
  </action>
  <verify>
Run `npx tsc --noEmit` - should compile without errors.
Run `npm run dev` - server should start with "Runbook worker started" in logs.
Test `curl http://localhost:3001/api/runbooks` - should return empty list (not 404).
  </verify>
  <done>
Runbook routes mounted at /api/runbooks. Runbook worker starts with application. Graceful shutdown includes worker cleanup.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - no TypeScript errors
2. `npm run dev` - server starts with runbook worker running
3. `curl http://localhost:3001/api/runbooks` - returns `{"runbooks":[],"total":0,...}`
4. Create test runbook via API, verify CRUD operations work
5. Approve runbook as platform admin, verify execution trigger works
</verification>

<success_criteria>
- REST API endpoints functional for all runbook operations
- Only APPROVED runbooks can be triggered for execution
- Parameter validation occurs before queueing execution
- Webhook execution uses 3-retry exponential backoff
- Every execution creates audit log entries
- Worker processes jobs asynchronously
- Routes and worker properly wired into application
</success_criteria>

<output>
After completion, create `.planning/phases/15-runbook-automation-foundation/15-02-SUMMARY.md`
</output>

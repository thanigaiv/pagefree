---
phase: 14-production-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/socket.ts
  - src/config/database.ts
  - src/services/audit.service.ts
autonomous: true

must_haves:
  truths:
    - "Socket.IO connections validate session against PostgreSQL session store"
    - "Invalid or expired sessions are rejected with 401-equivalent error"
    - "User ID is extracted from validated session, not passed from client"
    - "Socket auth failures are logged to audit system"
  artifacts:
    - path: "src/lib/socket.ts"
      provides: "Session-validated Socket.IO middleware"
      contains: "connect-pg-simple"
    - path: "src/lib/socket.ts"
      provides: "Session validation logic"
      contains: "session.sess"
  key_links:
    - from: "src/lib/socket.ts"
      to: "session table"
      via: "prisma.$queryRaw"
      pattern: "SELECT.*sess.*FROM.*session"
    - from: "src/lib/socket.ts"
      to: "src/services/audit.service.ts"
      via: "audit logging"
      pattern: "auditService\\.log"
---

<objective>
Implement proper session validation for Socket.IO connections by querying the connect-pg-simple session store instead of trusting client-provided tokens.

Purpose: Current socket authentication accepts any token from the client without validation. Production security requires verifying the session exists in PostgreSQL and extracting the user ID from the stored session data.

Output: Socket.IO middleware that validates sessions against the database and rejects invalid/expired connections.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing socket implementation
@src/lib/socket.ts
# Session configuration (connect-pg-simple)
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement session validation middleware for Socket.IO</name>
  <files>
    src/lib/socket.ts
  </files>
  <action>
    Refactor the Socket.IO authentication middleware in src/lib/socket.ts:

    1. Extract session ID from client:
       - Client sends session cookie value in socket.handshake.auth.sessionId
       - Or extract from socket.handshake.headers.cookie (parse connect.sid cookie)
       - Session ID format: s%3A{actualId}.{signature} (URL encoded, signed)
       - Use cookie-signature to verify signature (SESSION_SECRET)
       - Extract actual session ID after signature verification

    2. Query session from PostgreSQL:
       ```typescript
       const sessionResult = await prisma.$queryRaw<Array<{sess: any, expire: Date}>>`
         SELECT sess, expire FROM session WHERE sid = ${sessionId}
       `;
       ```

    3. Validate session:
       - Check session exists (result.length > 0)
       - Check not expired (expire > now)
       - Extract user from sess JSON: sess.passport.user (standard passport serialization)

    4. Attach validated user to socket:
       ```typescript
       (socket as any).userId = sess.passport.user;
       (socket as any).sessionId = sessionId;
       (socket as any).authenticated = true;
       ```

    5. Reject invalid sessions:
       - No session ID: next(new Error('Authentication required'))
       - Invalid signature: next(new Error('Invalid session'))
       - Session not found: next(new Error('Session expired'))
       - Session expired: next(new Error('Session expired'))

    6. Install cookie-signature if not present: `npm install cookie-signature`
       And @types: `npm install -D @types/cookie-signature`

    Note: connect-pg-simple stores sessions in "session" table with columns:
    - sid: session ID (varchar)
    - sess: session data (json)
    - expire: expiration timestamp
  </action>
  <verify>
    Run `npm run build` - no TypeScript errors
    Check socket.ts imports cookie-signature
    Check socket.ts queries session table
  </verify>
  <done>
    Socket.IO middleware validates sessions against PostgreSQL session store.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session refresh handling and audit logging</name>
  <files>
    src/lib/socket.ts
    src/services/audit.service.ts
  </files>
  <action>
    1. Add audit logging for socket authentication:
       - Log successful socket auth: action='socket.authenticated', userId, socketId
       - Log failed socket auth: action='socket.auth_failed', reason, ip, headers (sanitized)
       - Severity: INFO for success, WARN for failure

    2. Handle session expiration during active connection:
       - Add periodic session check (every 5 minutes) for active sockets
       - If session expired, emit 'session_expired' event and disconnect
       - Use setInterval on socket connection, clear on disconnect

    3. Add session refresh mechanism:
       - When session is within 5 minutes of expiry and still valid
       - Extend session by updating expire column
       - Only refresh if user is actively connected (not on every check)

    4. Add socket-level error handler:
       ```typescript
       socket.on('error', (error) => {
         logger.error({ socketId: socket.id, error: error.message }, 'Socket error');
       });
       ```

    5. Update disconnect handler to log reason with session context
  </action>
  <verify>
    Run `npm run build` - no TypeScript errors
    Check socket.ts imports auditService
    Verify audit logging calls exist for both success and failure paths
  </verify>
  <done>
    Socket authentication logs to audit system. Session refresh and expiration handled during active connections.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update frontend socket client to send session cookie</name>
  <files>
    frontend/src/lib/socket.ts
  </files>
  <action>
    Note: The frontend socket client may need updating to properly send credentials.

    1. Check frontend/src/lib/socket.ts (if exists) or socket initialization in React
    2. Ensure socket.io-client is configured with:
       ```typescript
       const socket = io(BACKEND_URL, {
         withCredentials: true,  // Send cookies
         // Remove auth.token if it was passing session ID manually
       });
       ```

    3. The withCredentials: true ensures cookies are sent with the WebSocket handshake.
       The server extracts session from the Cookie header, not from auth payload.

    4. If frontend was passing auth.token with session ID, that approach can remain as fallback,
       but server should prefer cookie-based auth when available.

    5. Add reconnection handling:
       - On 'connect_error' with auth message, redirect to login
       - On 'session_expired' event, show notification and redirect to login

    If frontend socket file doesn't exist, search for socket.io-client usage:
    `grep -r "io(" frontend/src/`
  </action>
  <verify>
    Run `cd frontend && npm run build` - no errors
    Check frontend socket config includes withCredentials: true
  </verify>
  <done>
    Frontend socket client sends credentials. Handles session expiration gracefully.
  </done>
</task>

</tasks>

<verification>
1. Socket middleware queries PostgreSQL session table
2. Invalid sessions rejected with appropriate error
3. Audit logs created for auth success and failure
4. TypeScript builds without errors (both backend and frontend)
5. Session refresh mechanism prevents mid-connection expiry
</verification>

<success_criteria>
- [ ] Socket.IO validates session against PostgreSQL session store
- [ ] User ID extracted from session, not trusted from client
- [ ] Invalid/expired sessions rejected with error
- [ ] Auth failures logged to audit system
- [ ] Frontend handles session expiration gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/14-production-hardening/14-03-SUMMARY.md`
</output>

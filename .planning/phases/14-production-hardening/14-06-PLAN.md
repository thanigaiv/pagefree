---
phase: 14-production-hardening
plan: 06
type: execute
wave: 2
depends_on:
  - 14-03
files_modified:
  - src/lib/socket.ts
  - src/services/socket.service.ts
autonomous: true

must_haves:
  truths:
    - "Socket events rate limited to 100 events/min per connection"
    - "Clients at 80 events/min receive warning event"
    - "Clients exceeding 100 events/min are disconnected"
    - "Rate limit violations logged with user ID and socket ID"
    - "System events (incident.created, etc.) exempt from limits"
  artifacts:
    - path: "src/lib/socket.ts"
      provides: "Socket event rate limiting"
      contains: "eventRateLimiter"
    - path: "src/lib/socket.ts"
      provides: "Grace warning at 80%"
      contains: "rate_limit_warning"
  key_links:
    - from: "src/lib/socket.ts"
      to: "socket middleware"
      via: "event interceptor"
      pattern: "socket\\.use"
---

<objective>
Add rate limiting to WebSocket events to prevent abuse of real-time connections, with grace warnings before disconnection.

Purpose: Without event rate limiting, a malicious or buggy client could flood the server with events. Production requires protection against WebSocket abuse.

Output: Socket.IO event rate limiting with 100 events/min limit, warning at 80 events/min, and audit logging.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Socket implementation (updated by 14-03)
@src/lib/socket.ts
@src/services/socket.service.ts
@src/types/socket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement per-connection event rate limiter</name>
  <files>
    src/lib/socket.ts
  </files>
  <action>
    Add event rate limiting to Socket.IO connections:

    1. Create per-socket rate tracking (in-memory, per connection):
       ```typescript
       // Track events per socket (no Redis needed - per-connection state)
       const socketEventCounts = new Map<string, {count: number, resetAt: number, warned: boolean}>();

       const EVENT_LIMIT = 100;        // events per minute
       const WARNING_THRESHOLD = 80;   // warn at 80%
       const WINDOW_MS = 60 * 1000;    // 1 minute window
       ```

    2. Create socket middleware to intercept incoming events:
       ```typescript
       socket.use((packet, next) => {
         const eventName = packet[0];

         // Skip rate limiting for internal/system events
         if (isSystemEvent(eventName)) {
           return next();
         }

         const socketId = socket.id;
         const now = Date.now();
         let tracker = socketEventCounts.get(socketId);

         // Reset counter if window expired
         if (!tracker || now > tracker.resetAt) {
           tracker = { count: 0, resetAt: now + WINDOW_MS, warned: false };
           socketEventCounts.set(socketId, tracker);
         }

         tracker.count++;

         // Check thresholds
         if (tracker.count >= EVENT_LIMIT) {
           // Rate limit exceeded - disconnect
           handleRateLimitExceeded(socket, tracker.count);
           return next(new Error('Rate limit exceeded'));
         }

         if (tracker.count >= WARNING_THRESHOLD && !tracker.warned) {
           // Warning threshold - notify client
           emitWarning(socket, tracker.count, EVENT_LIMIT);
           tracker.warned = true;
         }

         next();
       });
       ```

    3. Define system events that are exempt:
       ```typescript
       const SYSTEM_EVENTS = new Set([
         'ping',
         'pong',
         'disconnect',
         'error',
         // Server-to-client events (won't trigger this middleware)
       ]);

       function isSystemEvent(eventName: string): boolean {
         return SYSTEM_EVENTS.has(eventName);
       }
       ```

    4. Clean up tracker on disconnect:
       ```typescript
       socket.on('disconnect', () => {
         socketEventCounts.delete(socket.id);
         // existing disconnect handling...
       });
       ```
  </action>
  <verify>
    Run `npm run build` - no TypeScript errors
    Check socket.ts has event rate limiting middleware
    Verify system events set defined
  </verify>
  <done>
    Per-connection event rate limiter tracks events and enforces 100/min limit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add warning emission and disconnect handling</name>
  <files>
    src/lib/socket.ts
    src/types/socket.ts
  </files>
  <action>
    1. Add rate limit warning event to socket types (src/types/socket.ts):
       ```typescript
       interface ServerToClientEvents {
         // existing events...
         rate_limit_warning: (data: {
           current: number;
           limit: number;
           message: string;
         }) => void;
       }
       ```

    2. Implement warning emission:
       ```typescript
       function emitWarning(socket: TypedSocket, current: number, limit: number) {
         socket.emit('rate_limit_warning', {
           current,
           limit,
           message: `You are sending ${current} events/min. Limit is ${limit}. Slow down to avoid disconnection.`
         });

         logger.warn({
           socketId: socket.id,
           userId: (socket as any).userId,
           eventCount: current,
           limit
         }, 'Socket rate limit warning threshold reached');
       }
       ```

    3. Implement disconnect handling:
       ```typescript
       async function handleRateLimitExceeded(socket: TypedSocket, eventCount: number) {
         const userId = (socket as any).userId;

         // Audit log
         await auditService.log({
           action: 'socket.rate_limit_exceeded',
           severity: 'WARN',
           userId,
           metadata: {
             socketId: socket.id,
             eventCount,
             limit: EVENT_LIMIT
           }
         });

         logger.warn({
           socketId: socket.id,
           userId,
           eventCount
         }, 'Socket disconnected for rate limit violation');

         // Emit final warning before disconnect
         socket.emit('rate_limit_warning', {
           current: eventCount,
           limit: EVENT_LIMIT,
           message: 'Rate limit exceeded. Connection terminated.'
         });

         // Give client a moment to receive the message
         setTimeout(() => {
           socket.disconnect(true);
         }, 100);
       }
       ```

    4. Update socket service to handle rate-limited reconnections:
       - After disconnect for rate limit, client can reconnect
       - New connection gets fresh counter
       - No permanent ban (just temporary protection)
  </action>
  <verify>
    Run `npm run build` - no TypeScript errors
    Check types include rate_limit_warning event
    Verify audit logging on disconnect
  </verify>
  <done>
    Warning emitted at 80 events/min. Clients disconnected at 100 events/min with audit logging.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update frontend to handle rate limit warnings</name>
  <files>
    frontend/src/lib/socket.ts
  </files>
  <action>
    Update frontend socket client to handle rate limit events:

    1. Find frontend socket initialization (likely in frontend/src/lib/socket.ts or hooks)

    2. Add handler for rate_limit_warning:
       ```typescript
       socket.on('rate_limit_warning', (data) => {
         console.warn('Socket rate limit warning:', data);

         // Show user-friendly notification (using toast system)
         toast.warning(data.message, {
           duration: 5000,
           id: 'socket-rate-limit'  // Prevent duplicate toasts
         });
       });
       ```

    3. Handle disconnect due to rate limit:
       - Connection will close after limit exceeded
       - Socket.io-client auto-reconnects by default
       - Log reconnection for debugging

    4. If no frontend socket file exists, add TODO comment in backend for future implementation

    Note: Most legitimate clients won't hit 100 events/min. This is protection against:
    - Buggy code with infinite loops
    - Malicious clients attempting to flood
    - Runaway automated tests
  </action>
  <verify>
    Run `cd frontend && npm run build` - no errors
    Check frontend handles rate_limit_warning event (if applicable)
  </verify>
  <done>
    Frontend displays rate limit warnings to users. Handles disconnection gracefully.
  </done>
</task>

</tasks>

<verification>
1. Socket middleware intercepts and counts events
2. System events exempt from counting
3. Warning emitted at 80 events/min
4. Disconnect triggered at 100 events/min
5. Audit log created on disconnect
6. TypeScript builds without errors
</verification>

<success_criteria>
- [ ] 100 events/min limit per socket connection
- [ ] Warning at 80 events/min (rate_limit_warning event)
- [ ] Disconnect at 100 events/min
- [ ] System events exempt (ping, pong, disconnect)
- [ ] Violations logged with userId and socketId
- [ ] Frontend handles warnings (if applicable)
</success_criteria>

<output>
After completion, create `.planning/phases/14-production-hardening/14-06-SUMMARY.md`
</output>

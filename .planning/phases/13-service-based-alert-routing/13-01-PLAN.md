---
phase: 13-service-based-alert-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/services/routing.service.ts
  - src/services/deduplication.service.ts
  - src/services/incident.service.ts
  - src/routes/integration.routes.ts
  - src/services/integration.service.ts
  - src/webhooks/alert-receiver.ts
autonomous: true

must_haves:
  truths:
    - "Alert with routing_key in payload routes to matching service's owning team"
    - "Alert without routing_key falls back to TeamTag routing"
    - "Incident created via service routing has serviceId populated"
    - "Integration can have defaultServiceId configured"
    - "Service escalation policy used when configured, team default otherwise"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Incident.serviceId and Integration.defaultServiceId fields"
      contains: "serviceId   String?"
    - path: "src/services/routing.service.ts"
      provides: "Service-first routing with TeamTag fallback"
      contains: "routeViaService"
    - path: "src/services/deduplication.service.ts"
      provides: "serviceId in incident creation"
      contains: "serviceId: routing.serviceId"
  key_links:
    - from: "src/services/routing.service.ts"
      to: "src/services/service.service.ts"
      via: "getByRoutingKey lookup"
      pattern: "getByRoutingKey"
    - from: "src/services/deduplication.service.ts"
      to: "src/services/routing.service.ts"
      via: "routeAlertToTeam with integration param"
      pattern: "routeAlertToTeam.*integration"
---

<objective>
Backend service-based alert routing with schema extensions and routing logic modifications

Purpose: Enable alerts to route to teams via service routing keys while maintaining backward compatibility with existing TeamTag routing
Output: Extended Prisma schema, modified routing service with service-first logic, integration default service support
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-service-based-alert-routing/13-RESEARCH.md
@.planning/phases/11-service-model-foundation/11-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema with serviceId on Incident and defaultServiceId on Integration</name>
  <files>prisma/schema.prisma</files>
  <action>
Add serviceId field to Incident model:
- `serviceId String?` - optional foreign key to Service
- `service Service? @relation(fields: [serviceId], references: [id])` - relation
- `@@index([serviceId])` - index for efficient lookups

Add defaultServiceId field to Integration model:
- `defaultServiceId String?` - optional foreign key to Service
- `defaultService Service? @relation("IntegrationDefaultService", fields: [defaultServiceId], references: [id])` - named relation to avoid conflict

Add reverse relations to Service model:
- `incidents Incident[]` - incidents routed via this service
- `integrationsDefaulting Integration[] @relation("IntegrationDefaultService")` - integrations using as default

Run `npx prisma db push` to apply schema changes (no migration needed for nullable additions).
  </action>
  <verify>`npx prisma db push` succeeds without errors. `npx prisma generate` creates updated client. Check schema.prisma has serviceId on Incident and defaultServiceId on Integration.</verify>
  <done>Incident model has optional serviceId relation to Service. Integration model has optional defaultServiceId relation to Service. Database schema updated.</done>
</task>

<task type="auto">
  <name>Task 2: Extend routing.service.ts with service-first routing logic</name>
  <files>src/services/routing.service.ts</files>
  <action>
Modify RoutingResult interface:
- Add `serviceId?: string` - present when routed via service (ROUTE-03)

Modify routeAlertToTeam signature to accept optional integration parameter:
```typescript
async routeAlertToTeam(
  alert: any,
  integration?: { defaultServiceId?: string | null }
): Promise<RoutingResult>
```

Implement service-first routing logic (ROUTE-01, ROUTE-02, ROUTE-04, ROUTE-05):

1. Extract routing_key from alert metadata (check multiple field names: `routing_key`, `routingKey`)
2. If routing_key found, call serviceService.getByRoutingKey(routingKey)
   - Filter to only ACTIVE or DEPRECATED services (skip ARCHIVED per research pitfall)
3. If service found via routing_key, call new routeViaService(service) method
4. If no routing_key or no service match, check integration?.defaultServiceId
   - If set, look up service and call routeViaService if found
5. Fall back to existing determineTeamFromAlert (TeamTag routing, unchanged)

Add new private routeViaService method:
```typescript
private async routeViaService(service: ServiceWithTeam): Promise<RoutingResult>
```
- Get escalation policy: service.escalationPolicyId if set, else team default (ROUTE-05)
- If service policy doesn't exist or is inactive, fall back to team default (per research pitfall)
- Resolve first escalation target same as existing logic
- Return { teamId, escalationPolicyId, assignedUserId, serviceId: service.id }

Import serviceService from './service.service.js'. Use existing logger for debug/warn on routing decisions.
  </action>
  <verify>TypeScript compiles without errors. grep for 'routeViaService' and 'getByRoutingKey' in routing.service.ts confirms new methods exist.</verify>
  <done>Routing service prioritizes service routing_key, checks integration default, then falls back to TeamTag. Service escalation policy precedence implemented.</done>
</task>

<task type="auto">
  <name>Task 3: Update deduplication, incident service, integration routes for service routing</name>
  <files>src/services/deduplication.service.ts, src/services/incident.service.ts, src/webhooks/alert-receiver.ts, src/routes/integration.routes.ts, src/services/integration.service.ts</files>
  <action>
**deduplication.service.ts:**
- Modify deduplicateAndCreateIncident signature to accept optional integration:
  ```typescript
  async deduplicateAndCreateIncident(
    alertId: string,
    fingerprint: string,
    alert: any,
    windowMinutes?: number,
    integration?: { defaultServiceId?: string | null }
  ): Promise<DeduplicationResult>
  ```
- Pass integration to routingService.routeAlertToTeam(alert, integration)
- Add serviceId to incident create data: `serviceId: routing.serviceId`
- Include service in fullIncident fetch for WebSocket broadcast:
  ```typescript
  service: { select: { id: true, name: true, routingKey: true } }
  ```
- Add service to socketService.broadcastIncidentCreated payload (optional field)

**alert-receiver.ts:**
- When calling deduplicationService.deduplicateAndCreateIncident, pass integration object:
  ```typescript
  { defaultServiceId: integration.defaultServiceId }
  ```
  (Requires fetching defaultServiceId with integration lookup - check if already included, if not add to select)

**incident.service.ts:**
- In getById method, add service to include:
  ```typescript
  service: {
    select: {
      id: true,
      name: true,
      routingKey: true,
      team: { select: { id: true, name: true } }
    }
  }
  ```
- In list method, add service to include (same select as above)

**integration.routes.ts:**
- Add defaultServiceId to updateIntegrationSchema:
  ```typescript
  defaultServiceId: z.string().uuid().nullable().optional()
  ```

**integration.service.ts:**
- Include defaultServiceId in getById and list responses (already should be returned by Prisma, just ensure not filtered)
- In update method, allow setting defaultServiceId:
  ```typescript
  defaultServiceId: input.defaultServiceId
  ```
  </action>
  <verify>TypeScript compiles. curl POST to webhook endpoint with routing_key in payload routes to correct service team. curl PATCH integration with defaultServiceId succeeds.</verify>
  <done>Full backend routing pipeline passes integration through, incident creation includes serviceId, incident queries return service data, integration can set default service.</done>
</task>

</tasks>

<verification>
1. Create a test service with routingKey "test-svc-routing"
2. Send webhook with `{ "routing_key": "test-svc-routing", ... }` in payload
3. Verify incident created with serviceId set to the test service
4. Verify incident detail API returns service object
5. Set integration defaultServiceId, send webhook without routing_key
6. Verify incident routes to default service
7. Send webhook without routing_key and no default - verify falls back to TeamTag
</verification>

<success_criteria>
- Alert with routing_key routes to service's team (ROUTE-01)
- Alert without match falls back to TeamTag (ROUTE-02)
- Incident.serviceId populated for service-routed incidents (ROUTE-03)
- Integration.defaultServiceId can be set via PATCH (ROUTE-04)
- Service escalation policy used when set, team default otherwise (ROUTE-05)
- All existing alert routing continues working (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/13-service-based-alert-routing/13-01-SUMMARY.md`
</output>

---
phase: 04-alert-routing-and-deduplication
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/services/escalation-policy.service.ts
  - src/routes/escalation-policy.routes.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Team admin can create escalation policies with multiple levels"
    - "Each team has one default escalation policy"
    - "Levels have ordered precedence and configurable timeouts"
  artifacts:
    - path: "src/services/escalation-policy.service.ts"
      provides: "EscalationPolicy CRUD with validation"
      exports: ["escalationPolicyService"]
    - path: "src/routes/escalation-policy.routes.ts"
      provides: "REST API for escalation policy management"
      exports: ["escalationPolicyRoutes"]
  key_links:
    - from: "src/routes/escalation-policy.routes.ts"
      to: "src/services/escalation-policy.service.ts"
      via: "service method calls"
      pattern: "escalationPolicyService\\."
    - from: "src/index.ts"
      to: "src/routes/escalation-policy.routes.ts"
      via: "app.use mount"
      pattern: "escalationPolicyRoutes"
---

<objective>
Create escalation policy management service and API

Purpose: Teams need to configure escalation policies that define who gets notified and when. This is the configuration layer that incidents will use.
Output: EscalationPolicyService with CRUD operations, REST API endpoints, validation for level ordering and timeouts
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-alert-routing-and-deduplication/04-RESEARCH.md

# For authentication patterns
@src/middleware/auth.middleware.ts

# For RBAC patterns
@src/services/rbac.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create escalation policy service</name>
  <files>src/services/escalation-policy.service.ts</files>
  <action>
Create src/services/escalation-policy.service.ts with these methods:

```typescript
import { Prisma } from '@prisma/client';
import { prisma } from '../config/database.js';
import { auditService } from './audit.service.js';
import { logger } from '../config/logger.js';

// Types
interface CreateEscalationPolicyInput {
  teamId: string;
  name: string;
  description?: string;
  isDefault?: boolean;
  repeatCount?: number;
  levels: CreateEscalationLevelInput[];
}

interface CreateEscalationLevelInput {
  levelNumber: number;
  targetType: 'user' | 'schedule' | 'entire_team';
  targetId?: string;
  timeoutMinutes?: number;
}

interface UpdateEscalationPolicyInput {
  name?: string;
  description?: string;
  isDefault?: boolean;
  repeatCount?: number;
  isActive?: boolean;
}

class EscalationPolicyService {
  // Validation constants per PagerDuty patterns
  private readonly MIN_TIMEOUT_SINGLE_TARGET = 1;    // 1 minute for single target
  private readonly MIN_TIMEOUT_MULTI_TARGET = 3;     // 3 minutes for multiple targets
  private readonly MAX_REPEAT_COUNT = 9;
  private readonly MAX_LEVELS = 10;

  async create(
    input: CreateEscalationPolicyInput,
    userId: string
  ): Promise<any> {
    // Validate levels
    this.validateLevels(input.levels);

    // If setting as default, unset other defaults
    if (input.isDefault) {
      await prisma.escalationPolicy.updateMany({
        where: { teamId: input.teamId, isDefault: true },
        data: { isDefault: false }
      });
    }

    const policy = await prisma.escalationPolicy.create({
      data: {
        teamId: input.teamId,
        name: input.name,
        description: input.description,
        isDefault: input.isDefault ?? false,
        repeatCount: Math.min(input.repeatCount ?? 1, this.MAX_REPEAT_COUNT),
        levels: {
          create: input.levels.map(level => ({
            levelNumber: level.levelNumber,
            targetType: level.targetType,
            targetId: level.targetId,
            timeoutMinutes: level.timeoutMinutes ?? 30
          }))
        }
      },
      include: { levels: { orderBy: { levelNumber: 'asc' } } }
    });

    await auditService.log({
      action: 'escalation.policy.created',
      userId,
      teamId: input.teamId,
      resourceType: 'escalation_policy',
      resourceId: policy.id,
      severity: 'HIGH',
      metadata: { name: input.name, levelCount: input.levels.length }
    });

    logger.info({ policyId: policy.id, teamId: input.teamId }, 'Escalation policy created');
    return policy;
  }

  async getById(id: string): Promise<any> {
    return prisma.escalationPolicy.findUnique({
      where: { id },
      include: {
        levels: { orderBy: { levelNumber: 'asc' } },
        team: { select: { id: true, name: true } }
      }
    });
  }

  async getByTeam(teamId: string, includeInactive = false): Promise<any[]> {
    return prisma.escalationPolicy.findMany({
      where: {
        teamId,
        ...(includeInactive ? {} : { isActive: true })
      },
      include: { levels: { orderBy: { levelNumber: 'asc' } } },
      orderBy: [{ isDefault: 'desc' }, { name: 'asc' }]
    });
  }

  async getDefaultForTeam(teamId: string): Promise<any> {
    return prisma.escalationPolicy.findFirst({
      where: { teamId, isDefault: true, isActive: true },
      include: { levels: { orderBy: { levelNumber: 'asc' } } }
    });
  }

  async update(
    id: string,
    input: UpdateEscalationPolicyInput,
    userId: string
  ): Promise<any> {
    const existing = await prisma.escalationPolicy.findUnique({
      where: { id },
      select: { teamId: true }
    });

    if (!existing) {
      throw new Error('Escalation policy not found');
    }

    // If setting as default, unset other defaults
    if (input.isDefault) {
      await prisma.escalationPolicy.updateMany({
        where: { teamId: existing.teamId, isDefault: true, id: { not: id } },
        data: { isDefault: false }
      });
    }

    const policy = await prisma.escalationPolicy.update({
      where: { id },
      data: {
        ...(input.name && { name: input.name }),
        ...(input.description !== undefined && { description: input.description }),
        ...(input.isDefault !== undefined && { isDefault: input.isDefault }),
        ...(input.repeatCount !== undefined && {
          repeatCount: Math.min(input.repeatCount, this.MAX_REPEAT_COUNT)
        }),
        ...(input.isActive !== undefined && { isActive: input.isActive })
      },
      include: { levels: { orderBy: { levelNumber: 'asc' } } }
    });

    await auditService.log({
      action: 'escalation.policy.updated',
      userId,
      teamId: existing.teamId,
      resourceType: 'escalation_policy',
      resourceId: id,
      severity: 'INFO',
      metadata: { changes: Object.keys(input) }
    });

    return policy;
  }

  async addLevel(
    policyId: string,
    input: CreateEscalationLevelInput,
    userId: string
  ): Promise<any> {
    const policy = await prisma.escalationPolicy.findUnique({
      where: { id: policyId },
      include: { levels: true }
    });

    if (!policy) {
      throw new Error('Escalation policy not found');
    }

    if (policy.levels.length >= this.MAX_LEVELS) {
      throw new Error(`Maximum ${this.MAX_LEVELS} levels allowed`);
    }

    // Validate level number is sequential
    const existingNumbers = policy.levels.map(l => l.levelNumber);
    if (existingNumbers.includes(input.levelNumber)) {
      throw new Error(`Level ${input.levelNumber} already exists`);
    }

    const level = await prisma.escalationLevel.create({
      data: {
        escalationPolicyId: policyId,
        levelNumber: input.levelNumber,
        targetType: input.targetType,
        targetId: input.targetId,
        timeoutMinutes: input.timeoutMinutes ?? 30
      }
    });

    await auditService.log({
      action: 'escalation.level.added',
      userId,
      teamId: policy.teamId,
      resourceType: 'escalation_level',
      resourceId: level.id,
      severity: 'INFO',
      metadata: { policyId, levelNumber: input.levelNumber }
    });

    return level;
  }

  async updateLevel(
    levelId: string,
    input: Partial<CreateEscalationLevelInput>,
    userId: string
  ): Promise<any> {
    const level = await prisma.escalationLevel.findUnique({
      where: { id: levelId },
      include: { escalationPolicy: { select: { teamId: true } } }
    });

    if (!level) {
      throw new Error('Escalation level not found');
    }

    const updated = await prisma.escalationLevel.update({
      where: { id: levelId },
      data: {
        ...(input.targetType && { targetType: input.targetType }),
        ...(input.targetId !== undefined && { targetId: input.targetId }),
        ...(input.timeoutMinutes && { timeoutMinutes: input.timeoutMinutes })
      }
    });

    await auditService.log({
      action: 'escalation.level.updated',
      userId,
      teamId: level.escalationPolicy.teamId,
      resourceType: 'escalation_level',
      resourceId: levelId,
      severity: 'INFO',
      metadata: { changes: Object.keys(input) }
    });

    return updated;
  }

  async removeLevel(levelId: string, userId: string): Promise<void> {
    const level = await prisma.escalationLevel.findUnique({
      where: { id: levelId },
      include: { escalationPolicy: { select: { id: true, teamId: true } } }
    });

    if (!level) {
      throw new Error('Escalation level not found');
    }

    await prisma.escalationLevel.delete({ where: { id: levelId } });

    await auditService.log({
      action: 'escalation.level.removed',
      userId,
      teamId: level.escalationPolicy.teamId,
      resourceType: 'escalation_level',
      resourceId: levelId,
      severity: 'INFO',
      metadata: { policyId: level.escalationPolicy.id, levelNumber: level.levelNumber }
    });
  }

  async delete(id: string, userId: string): Promise<void> {
    const policy = await prisma.escalationPolicy.findUnique({
      where: { id },
      include: { _count: { select: { incidents: true } } }
    });

    if (!policy) {
      throw new Error('Escalation policy not found');
    }

    // Check for active incidents using this policy
    if (policy._count.incidents > 0) {
      const activeIncidents = await prisma.incident.count({
        where: { escalationPolicyId: id, status: { in: ['OPEN', 'ACKNOWLEDGED'] } }
      });

      if (activeIncidents > 0) {
        throw new Error(`Cannot delete policy with ${activeIncidents} active incidents`);
      }
    }

    // Hard delete (cascade deletes levels)
    await prisma.escalationPolicy.delete({ where: { id } });

    await auditService.log({
      action: 'escalation.policy.deleted',
      userId,
      teamId: policy.teamId,
      resourceType: 'escalation_policy',
      resourceId: id,
      severity: 'HIGH',
      metadata: { name: policy.name }
    });

    logger.info({ policyId: id }, 'Escalation policy deleted');
  }

  // Validation helpers
  private validateLevels(levels: CreateEscalationLevelInput[]): void {
    if (levels.length === 0) {
      throw new Error('At least one escalation level is required');
    }

    if (levels.length > this.MAX_LEVELS) {
      throw new Error(`Maximum ${this.MAX_LEVELS} levels allowed`);
    }

    // Check level numbers are sequential starting from 1
    const numbers = levels.map(l => l.levelNumber).sort((a, b) => a - b);
    for (let i = 0; i < numbers.length; i++) {
      if (numbers[i] !== i + 1) {
        throw new Error('Level numbers must be sequential starting from 1');
      }
    }

    // Validate timeouts
    for (const level of levels) {
      if (level.timeoutMinutes !== undefined) {
        const minTimeout = level.targetType === 'entire_team'
          ? this.MIN_TIMEOUT_MULTI_TARGET
          : this.MIN_TIMEOUT_SINGLE_TARGET;

        if (level.timeoutMinutes < minTimeout) {
          throw new Error(
            `Level ${level.levelNumber}: minimum timeout is ${minTimeout} minutes for ${level.targetType}`
          );
        }
      }

      // Validate targetId is provided for user/schedule types
      if ((level.targetType === 'user' || level.targetType === 'schedule') && !level.targetId) {
        throw new Error(`Level ${level.levelNumber}: targetId required for ${level.targetType}`);
      }
    }
  }
}

export const escalationPolicyService = new EscalationPolicyService();
```
  </action>
  <verify>npm run build</verify>
  <done>Service compiles with all CRUD methods and validation</done>
</task>

<task type="auto">
  <name>Task 2: Create escalation policy routes</name>
  <files>src/routes/escalation-policy.routes.ts, src/index.ts</files>
  <action>
Create src/routes/escalation-policy.routes.ts:

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { escalationPolicyService } from '../services/escalation-policy.service.js';
import { rbacService } from '../services/rbac.service.js';
import { logger } from '../config/logger.js';

const router = Router();

// All routes require authentication (via auth middleware in index.ts)

// GET /api/escalation-policies/teams/:teamId - List team's policies
router.get('/teams/:teamId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { teamId } = req.params;
    const includeInactive = req.query.includeInactive === 'true';

    // Any team member can view policies
    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      teamId,
      'view'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const policies = await escalationPolicyService.getByTeam(teamId, includeInactive);
    res.json({ policies });
  } catch (error) {
    next(error);
  }
});

// GET /api/escalation-policies/:id - Get policy by ID
router.get('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const policy = await escalationPolicyService.getById(req.params.id);

    if (!policy) {
      return res.status(404).json({ error: 'Escalation policy not found' });
    }

    // Check team membership
    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      policy.teamId,
      'view'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    res.json({ policy });
  } catch (error) {
    next(error);
  }
});

// POST /api/escalation-policies - Create policy
router.post('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { teamId, name, description, isDefault, repeatCount, levels } = req.body;

    if (!teamId || !name || !levels || !Array.isArray(levels)) {
      return res.status(400).json({
        error: 'teamId, name, and levels array are required'
      });
    }

    // Team admin required to create policies
    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      teamId,
      'manage'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const policy = await escalationPolicyService.create(
      { teamId, name, description, isDefault, repeatCount, levels },
      (req as any).user.id
    );

    res.status(201).json({ policy });
  } catch (error: any) {
    if (error.message.includes('required') || error.message.includes('validation')) {
      return res.status(400).json({ error: error.message });
    }
    next(error);
  }
});

// PATCH /api/escalation-policies/:id - Update policy
router.patch('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const existing = await escalationPolicyService.getById(req.params.id);

    if (!existing) {
      return res.status(404).json({ error: 'Escalation policy not found' });
    }

    // Team admin required
    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      existing.teamId,
      'manage'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const { name, description, isDefault, repeatCount, isActive } = req.body;
    const policy = await escalationPolicyService.update(
      req.params.id,
      { name, description, isDefault, repeatCount, isActive },
      (req as any).user.id
    );

    res.json({ policy });
  } catch (error: any) {
    if (error.message.includes('not found')) {
      return res.status(404).json({ error: error.message });
    }
    next(error);
  }
});

// DELETE /api/escalation-policies/:id - Delete policy
router.delete('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const existing = await escalationPolicyService.getById(req.params.id);

    if (!existing) {
      return res.status(404).json({ error: 'Escalation policy not found' });
    }

    // Team admin required
    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      existing.teamId,
      'manage'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    await escalationPolicyService.delete(req.params.id, (req as any).user.id);
    res.status(204).send();
  } catch (error: any) {
    if (error.message.includes('Cannot delete') || error.message.includes('active incidents')) {
      return res.status(409).json({ error: error.message });
    }
    next(error);
  }
});

// POST /api/escalation-policies/:id/levels - Add level
router.post('/:id/levels', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const existing = await escalationPolicyService.getById(req.params.id);

    if (!existing) {
      return res.status(404).json({ error: 'Escalation policy not found' });
    }

    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      existing.teamId,
      'manage'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const { levelNumber, targetType, targetId, timeoutMinutes } = req.body;

    if (!levelNumber || !targetType) {
      return res.status(400).json({ error: 'levelNumber and targetType are required' });
    }

    const level = await escalationPolicyService.addLevel(
      req.params.id,
      { levelNumber, targetType, targetId, timeoutMinutes },
      (req as any).user.id
    );

    res.status(201).json({ level });
  } catch (error: any) {
    if (error.message.includes('already exists') || error.message.includes('Maximum')) {
      return res.status(400).json({ error: error.message });
    }
    next(error);
  }
});

// PATCH /api/escalation-policies/levels/:levelId - Update level
router.patch('/levels/:levelId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { targetType, targetId, timeoutMinutes } = req.body;

    const level = await escalationPolicyService.updateLevel(
      req.params.levelId,
      { targetType, targetId, timeoutMinutes },
      (req as any).user.id
    );

    res.json({ level });
  } catch (error: any) {
    if (error.message.includes('not found')) {
      return res.status(404).json({ error: error.message });
    }
    next(error);
  }
});

// DELETE /api/escalation-policies/levels/:levelId - Remove level
router.delete('/levels/:levelId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    await escalationPolicyService.removeLevel(req.params.levelId, (req as any).user.id);
    res.status(204).send();
  } catch (error: any) {
    if (error.message.includes('not found')) {
      return res.status(404).json({ error: error.message });
    }
    next(error);
  }
});

export const escalationPolicyRoutes = router;
```

Update src/index.ts to mount the routes (add with other API routes):

```typescript
// Add import at top
import { escalationPolicyRoutes } from './routes/escalation-policy.routes.js';

// Add after other authenticated routes (in the authenticated section)
app.use('/api/escalation-policies', escalationPolicyRoutes);
```
  </action>
  <verify>npm run build</verify>
  <done>Routes compile, mounted in index.ts</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` succeeds
- [ ] src/services/escalation-policy.service.ts exports escalationPolicyService
- [ ] src/routes/escalation-policy.routes.ts exports escalationPolicyRoutes
- [ ] Routes mounted at /api/escalation-policies in index.ts
</verification>

<success_criteria>
Escalation policy management complete:
- CRUD operations for policies and levels
- Validation for level ordering, timeouts, and target requirements
- Team admin permission required for mutations
- Audit logging for all changes
- Prevents deletion of policies with active incidents
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-routing-and-deduplication/04-03-SUMMARY.md`
</output>

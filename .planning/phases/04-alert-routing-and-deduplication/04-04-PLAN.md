---
phase: 04-alert-routing-and-deduplication
plan: 04
type: tdd
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/services/deduplication.service.ts
  - src/services/routing.service.ts
  - src/tests/deduplication.test.ts
autonomous: true

must_haves:
  truths:
    - "Duplicate alerts within window are grouped into same incident"
    - "Concurrent webhooks with same fingerprint create only one incident"
    - "Alerts route to team based on service metadata"
    - "First available on-call user is assigned to incident"
  artifacts:
    - path: "src/services/deduplication.service.ts"
      provides: "Transactional deduplication with Serializable isolation"
      exports: ["deduplicationService", "deduplicateAndCreateIncident"]
    - path: "src/services/routing.service.ts"
      provides: "Alert to team routing logic"
      exports: ["routingService"]
    - path: "src/tests/deduplication.test.ts"
      provides: "Tests for deduplication race conditions"
  key_links:
    - from: "src/services/deduplication.service.ts"
      to: "prisma.$transaction"
      via: "Serializable isolation"
      pattern: "TransactionIsolationLevel\\.Serializable"
    - from: "src/services/routing.service.ts"
      to: "src/services/oncall.service.ts"
      via: "getCurrentOnCall call"
      pattern: "onCallService\\.getCurrentOnCall"
---

<objective>
Implement alert deduplication with race condition prevention and routing logic (TDD)

Purpose: Critical business logic - prevents duplicate incidents during alert storms. Uses Serializable transactions per STATE.md warning about race conditions.
Output: Deduplication service with tested race condition handling, routing service connecting to Phase 3 on-call lookup
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-alert-routing-and-deduplication/04-RESEARCH.md

# Phase 3 on-call service for routing
@src/services/oncall.service.ts

# Phase 2 fingerprinting for deduplication
@src/utils/content-fingerprint.ts

# Test patterns
@src/tests/setup.ts
</context>

<feature>
  <name>Alert Deduplication and Routing</name>
  <files>
    src/services/deduplication.service.ts
    src/services/routing.service.ts
    src/tests/deduplication.test.ts
  </files>
  <behavior>
    **Deduplication behavior:**
    - Given alert with fingerprint "abc123" and no existing incident within 15 minutes
    - When deduplicateAndCreateIncident is called
    - Then new Incident is created, alert linked, isDuplicate=false returned

    - Given alert with fingerprint "abc123" and existing OPEN incident with same fingerprint
    - When deduplicateAndCreateIncident is called
    - Then existing Incident returned, alert linked, alertCount incremented, isDuplicate=true

    - Given two concurrent deduplicateAndCreateIncident calls with same fingerprint
    - When both transactions run simultaneously
    - Then exactly one Incident is created (transaction serialization prevents race)

    **Routing behavior:**
    - Given alert with metadata.service="payments-api"
    - When routeAlertToTeam is called
    - Then team with matching tag is found, default escalation policy selected, on-call user assigned

    - Given alert with no service metadata but integration.defaultTeamId set
    - When routeAlertToTeam is called
    - Then integration's default team is used for routing

    **Test cases:**
    1. New fingerprint creates incident -> { incident, isDuplicate: false }
    2. Existing fingerprint groups to incident -> { incident, isDuplicate: true, alertCount: 2 }
    3. Concurrent calls race condition -> exactly 1 incident created
    4. P2034 serialization error -> retry succeeds
    5. Route by service tag -> correct team found
    6. Route by integration default -> fallback team used
    7. No on-call user -> incident created with null assignedUserId
  </behavior>
  <implementation>
    **Deduplication service (src/services/deduplication.service.ts):**

    ```typescript
    import { Prisma } from '@prisma/client';
    import { prisma } from '../config/database.js';
    import { routingService } from './routing.service.js';
    import { logger } from '../config/logger.js';

    interface DeduplicationResult {
      incident: any;
      isDuplicate: boolean;
    }

    class DeduplicationService {
      private readonly MAX_RETRIES = 3;

      async deduplicateAndCreateIncident(
        alertId: string,
        fingerprint: string,
        alert: any, // Full alert object for routing
        windowMinutes: number = 15
      ): Promise<DeduplicationResult> {
        // Retry loop for serialization failures
        for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
          try {
            return await this.executeTransaction(alertId, fingerprint, alert, windowMinutes);
          } catch (error: any) {
            if (error.code === 'P2034' && attempt < this.MAX_RETRIES) {
              // Serialization failure, retry with exponential backoff
              const delay = Math.pow(2, attempt) * 100;
              logger.warn(
                { attempt, delay, fingerprint },
                'Serialization conflict, retrying...'
              );
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            }
            throw error;
          }
        }
        throw new Error('Deduplication failed after max retries');
      }

      private async executeTransaction(
        alertId: string,
        fingerprint: string,
        alert: any,
        windowMinutes: number
      ): Promise<DeduplicationResult> {
        return await prisma.$transaction(
          async (tx) => {
            const windowStart = new Date(Date.now() - windowMinutes * 60 * 1000);

            // Check for existing incident with same fingerprint in window
            const existing = await tx.incident.findFirst({
              where: {
                fingerprint,
                status: { in: ['OPEN', 'ACKNOWLEDGED'] },
                createdAt: { gte: windowStart }
              }
            });

            if (existing) {
              // Link alert to existing incident, increment count
              await tx.alert.update({
                where: { id: alertId },
                data: { incidentId: existing.id }
              });

              const updated = await tx.incident.update({
                where: { id: existing.id },
                data: { alertCount: { increment: 1 } }
              });

              logger.info(
                { incidentId: existing.id, alertId, alertCount: updated.alertCount },
                'Alert grouped to existing incident'
              );

              return { incident: updated, isDuplicate: true };
            }

            // Route to team and get on-call user
            const routing = await routingService.routeAlertToTeam(alert);

            // Create new incident
            const incident = await tx.incident.create({
              data: {
                fingerprint,
                status: 'OPEN',
                priority: alert.severity,
                teamId: routing.teamId,
                escalationPolicyId: routing.escalationPolicyId,
                assignedUserId: routing.assignedUserId,
                currentLevel: 1,
                currentRepeat: 1,
                alertCount: 1
              }
            });

            // Link alert
            await tx.alert.update({
              where: { id: alertId },
              data: { incidentId: incident.id }
            });

            logger.info(
              { incidentId: incident.id, alertId, teamId: routing.teamId },
              'New incident created from alert'
            );

            return { incident, isDuplicate: false };
          },
          { isolationLevel: Prisma.TransactionIsolationLevel.Serializable }
        );
      }
    }

    export const deduplicationService = new DeduplicationService();
    ```

    **Routing service (src/services/routing.service.ts):**

    ```typescript
    import { prisma } from '../config/database.js';
    import { onCallService } from './oncall.service.js';
    import { logger } from '../config/logger.js';

    interface RoutingResult {
      teamId: string;
      escalationPolicyId: string;
      assignedUserId: string | null;
    }

    class RoutingService {
      async routeAlertToTeam(alert: any): Promise<RoutingResult> {
        // 1. Determine team from alert metadata
        const team = await this.determineTeamFromAlert(alert);

        if (!team) {
          throw new Error(`No team found for alert routing (alertId: ${alert.id})`);
        }

        // 2. Get team's default escalation policy
        const policy = await prisma.escalationPolicy.findFirst({
          where: { teamId: team.id, isDefault: true, isActive: true },
          include: { levels: { orderBy: { levelNumber: 'asc' } } }
        });

        if (!policy || policy.levels.length === 0) {
          throw new Error(`Team ${team.name} has no active escalation policy`);
        }

        // 3. Determine first target from level 1
        const firstLevel = policy.levels[0];
        const assignedUserId = await this.resolveEscalationTarget(firstLevel, team.id);

        logger.info(
          { alertId: alert.id, teamId: team.id, policyId: policy.id, assignedUserId },
          'Alert routed to team'
        );

        return {
          teamId: team.id,
          escalationPolicyId: policy.id,
          assignedUserId
        };
      }

      private async determineTeamFromAlert(alert: any): Promise<any | null> {
        const metadata = alert.metadata as any;

        // Try service name from metadata
        const serviceName = metadata?.service || metadata?.service_name || metadata?.serviceName;

        if (serviceName) {
          // Find team with matching technical tag
          const teamTag = await prisma.teamTag.findFirst({
            where: {
              tagType: 'TECHNICAL',
              tagValue: serviceName
            },
            include: { team: true }
          });

          if (teamTag) {
            logger.debug({ serviceName, teamId: teamTag.team.id }, 'Routed by service tag');
            return teamTag.team;
          }
        }

        // Fallback: integration default team (requires schema update)
        // For now, get integration and check if it has a team association
        const integration = await prisma.integration.findUnique({
          where: { id: alert.integrationId }
        });

        // Note: Integration model doesn't have defaultTeamId yet
        // This will be added if needed, for now return null to throw error
        logger.warn({ alertId: alert.id }, 'No team found for alert');
        return null;
      }

      async resolveEscalationTarget(
        level: any,
        teamId: string
      ): Promise<string | null> {
        if (level.targetType === 'user') {
          // Direct user assignment
          const user = await prisma.user.findUnique({
            where: { id: level.targetId, isActive: true }
          });
          return user?.id || null;
        }

        if (level.targetType === 'schedule') {
          // Use Phase 3 on-call lookup
          const onCall = await onCallService.getCurrentOnCall({
            scheduleId: level.targetId
          });

          if (onCall?.user) {
            // Verify user is still active team member
            const membership = await prisma.teamMember.findFirst({
              where: {
                userId: onCall.user.id,
                teamId,
                role: { in: ['RESPONDER', 'TEAM_ADMIN'] }
              }
            });

            if (membership) {
              return onCall.user.id;
            }
          }
          return null;
        }

        if (level.targetType === 'entire_team') {
          // Get all team responders, return first available
          const members = await prisma.teamMember.findMany({
            where: {
              teamId,
              role: { in: ['RESPONDER', 'TEAM_ADMIN'] },
              user: { isActive: true }
            },
            include: { user: true },
            orderBy: { joinedAt: 'asc' }
          });

          return members[0]?.userId || null;
        }

        return null;
      }
    }

    export const routingService = new RoutingService();
    ```

    **Tests (src/tests/deduplication.test.ts):**

    Test that concurrent calls with same fingerprint create exactly one incident.
    Test that P2034 errors trigger retry.
    Test routing by service tag.
    Test fallback to no assigned user when on-call unavailable.
  </implementation>
</feature>

<verification>
- [ ] `npm test` passes all deduplication tests
- [ ] Concurrent test demonstrates race condition prevention
- [ ] src/services/deduplication.service.ts uses Serializable isolation
- [ ] src/services/routing.service.ts calls onCallService.getCurrentOnCall
- [ ] `npm run build` succeeds
</verification>

<success_criteria>
Deduplication and routing critical path complete:
- Serializable transactions prevent duplicate incidents
- P2034 retry logic handles contention
- Routing resolves team from service tags
- On-call lookup integrates with Phase 3
- Audit-worthy logging throughout
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-routing-and-deduplication/04-04-SUMMARY.md`
</output>

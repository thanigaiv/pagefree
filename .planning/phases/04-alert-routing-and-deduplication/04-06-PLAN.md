---
phase: 04-alert-routing-and-deduplication
plan: 06
type: execute
wave: 3
depends_on: ["04-03", "04-04", "04-05"]
files_modified:
  - src/workers/escalation.worker.ts
  - src/services/escalation.service.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "System escalates to next level if incident not acknowledged"
    - "Worker checks incident status before notifying (race prevention)"
    - "Escalation stops when policy repeat count reached"
    - "Escalation jobs are rescheduled on server restart"
  artifacts:
    - path: "src/workers/escalation.worker.ts"
      provides: "BullMQ worker processing escalation jobs"
      exports: ["startEscalationWorker", "stopEscalationWorker"]
    - path: "src/services/escalation.service.ts"
      provides: "Escalation orchestration logic"
      exports: ["escalationService"]
  key_links:
    - from: "src/workers/escalation.worker.ts"
      to: "src/services/incident.service.ts"
      via: "status check before escalating"
      pattern: "incident\\.status.*!==.*OPEN"
    - from: "src/services/escalation.service.ts"
      to: "src/queues/escalation.queue.ts"
      via: "scheduleEscalation call"
      pattern: "scheduleEscalation"
---

<objective>
Create escalation worker and orchestration service for multi-level escalation

Purpose: When incident is not acknowledged within timeout, escalate to next level. This is the heart of on-call reliability - ensuring someone always responds.
Output: BullMQ worker that processes escalation jobs, escalation service that orchestrates level progression, server startup reconciliation for stale escalations
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-alert-routing-and-deduplication/04-RESEARCH.md

# Queue infrastructure
@src/queues/escalation.queue.ts

# Services for routing and incident management
@src/services/routing.service.ts
@src/services/incident.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create escalation orchestration service</name>
  <files>src/services/escalation.service.ts</files>
  <action>
Create src/services/escalation.service.ts:

```typescript
import { prisma } from '../config/database.js';
import { scheduleEscalation, cancelEscalation } from '../queues/escalation.queue.js';
import { queueNotification } from '../queues/notification.queue.js';
import { routingService } from './routing.service.js';
import { auditService } from './audit.service.js';
import { logger } from '../config/logger.js';

class EscalationService {
  // Start escalation for a new incident
  async startEscalation(incidentId: string): Promise<void> {
    const incident = await prisma.incident.findUnique({
      where: { id: incidentId },
      include: {
        escalationPolicy: {
          include: { levels: { orderBy: { levelNumber: 'asc' } } }
        }
      }
    });

    if (!incident || !incident.escalationPolicy) {
      logger.error({ incidentId }, 'Cannot start escalation - incident or policy not found');
      return;
    }

    const firstLevel = incident.escalationPolicy.levels[0];
    if (!firstLevel) {
      logger.error({ incidentId }, 'Escalation policy has no levels');
      return;
    }

    // Schedule first escalation
    const bullJobId = await scheduleEscalation(
      incidentId,
      0, // Current level 0, will escalate to level 1
      1, // First repeat
      firstLevel.timeoutMinutes
    );

    // Track the job
    await prisma.escalationJob.create({
      data: {
        incidentId,
        bullJobId,
        scheduledLevel: 1,
        scheduledFor: new Date(Date.now() + firstLevel.timeoutMinutes * 60 * 1000)
      }
    });

    // Queue initial notification to assigned user
    if (incident.assignedUserId) {
      await queueNotification({
        userId: incident.assignedUserId,
        incidentId,
        type: 'new_incident'
      });
    }

    logger.info(
      { incidentId, scheduledLevel: 1, timeoutMinutes: firstLevel.timeoutMinutes },
      'Escalation started'
    );
  }

  // Process an escalation (called by worker)
  async processEscalation(
    incidentId: string,
    toLevel: number,
    repeatNumber: number
  ): Promise<void> {
    const incident = await prisma.incident.findUnique({
      where: { id: incidentId },
      include: {
        escalationPolicy: {
          include: { levels: { orderBy: { levelNumber: 'asc' } } }
        }
      }
    });

    // CRITICAL: Check incident is still open
    if (!incident || incident.status !== 'OPEN') {
      logger.info(
        { incidentId, status: incident?.status },
        'Escalation skipped - incident no longer open'
      );
      return;
    }

    // Check if already at higher level (stale job)
    if (incident.currentLevel >= toLevel && incident.currentRepeat >= repeatNumber) {
      logger.info(
        { incidentId, currentLevel: incident.currentLevel, toLevel },
        'Escalation skipped - already at higher level'
      );
      return;
    }

    const policy = incident.escalationPolicy!;
    const nextLevel = policy.levels.find(l => l.levelNumber === toLevel);

    // Check if we need to repeat or we're done
    if (!nextLevel) {
      // No more levels - check if we should repeat
      if (repeatNumber < policy.repeatCount) {
        // Repeat from level 1
        logger.info(
          { incidentId, repeatNumber, repeatCount: policy.repeatCount },
          'Restarting escalation policy from level 1'
        );
        await this.escalateToLevel(incident, policy.levels[0], repeatNumber + 1);
        return;
      }

      // Policy exhausted - log and stop
      logger.warn(
        { incidentId, repeatCount: policy.repeatCount },
        'Escalation policy exhausted - no more levels or repeats'
      );

      await auditService.log({
        action: 'incident.escalation.exhausted',
        userId: null,
        teamId: incident.teamId,
        resourceType: 'incident',
        resourceId: incidentId,
        severity: 'HIGH',
        metadata: { repeatCount: policy.repeatCount, levelCount: policy.levels.length }
      });

      return;
    }

    // Escalate to next level
    await this.escalateToLevel(incident, nextLevel, repeatNumber);
  }

  private async escalateToLevel(
    incident: any,
    level: any,
    repeatNumber: number
  ): Promise<void> {
    // Resolve target user for this level
    const newAssignee = await routingService.resolveEscalationTarget(
      level,
      incident.teamId
    );

    // Update incident
    await prisma.incident.update({
      where: { id: incident.id },
      data: {
        currentLevel: level.levelNumber,
        currentRepeat: repeatNumber,
        assignedUserId: newAssignee,
        lastEscalatedAt: new Date()
      }
    });

    // Audit log
    await auditService.log({
      action: 'incident.escalated',
      userId: null, // System action
      teamId: incident.teamId,
      resourceType: 'incident',
      resourceId: incident.id,
      severity: 'HIGH',
      metadata: {
        toLevel: level.levelNumber,
        repeatNumber,
        targetType: level.targetType,
        newAssignee
      }
    });

    // Notify new assignee
    if (newAssignee) {
      await queueNotification({
        userId: newAssignee,
        incidentId: incident.id,
        type: 'escalation'
      });
    }

    logger.info(
      { incidentId: incident.id, level: level.levelNumber, repeatNumber, newAssignee },
      'Incident escalated'
    );

    // Schedule next escalation
    const policy = incident.escalationPolicy;
    const nextLevelNumber = level.levelNumber + 1;
    const nextLevel = policy.levels.find((l: any) => l.levelNumber === nextLevelNumber);

    if (nextLevel) {
      // Schedule escalation to next level
      const bullJobId = await scheduleEscalation(
        incident.id,
        level.levelNumber,
        repeatNumber,
        nextLevel.timeoutMinutes
      );

      await prisma.escalationJob.create({
        data: {
          incidentId: incident.id,
          bullJobId,
          scheduledLevel: nextLevelNumber,
          scheduledFor: new Date(Date.now() + nextLevel.timeoutMinutes * 60 * 1000)
        }
      });
    } else if (repeatNumber < policy.repeatCount) {
      // No more levels, but can repeat - schedule repeat
      const firstLevel = policy.levels[0];
      const bullJobId = await scheduleEscalation(
        incident.id,
        level.levelNumber,
        repeatNumber,
        firstLevel.timeoutMinutes
      );

      await prisma.escalationJob.create({
        data: {
          incidentId: incident.id,
          bullJobId,
          scheduledLevel: 1,
          scheduledFor: new Date(Date.now() + firstLevel.timeoutMinutes * 60 * 1000)
        }
      });
    }
    // else: policy exhausted, don't schedule more
  }

  // Reconcile stale escalations on server startup
  async reconcileStaleEscalations(): Promise<number> {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);

    const staleIncidents = await prisma.incident.findMany({
      where: {
        status: 'OPEN',
        lastEscalatedAt: { lt: oneHourAgo },
        escalationJobs: {
          none: { completed: false }
        }
      },
      include: {
        escalationPolicy: {
          include: { levels: { orderBy: { levelNumber: 'asc' } } }
        }
      }
    });

    let rescheduled = 0;

    for (const incident of staleIncidents) {
      if (!incident.escalationPolicy) continue;

      const nextLevelNumber = incident.currentLevel + 1;
      const nextLevel = incident.escalationPolicy.levels.find(
        l => l.levelNumber === nextLevelNumber
      );

      if (nextLevel || incident.currentRepeat < incident.escalationPolicy.repeatCount) {
        // Reschedule immediately (0 timeout - overdue)
        const bullJobId = await scheduleEscalation(
          incident.id,
          incident.currentLevel,
          incident.currentRepeat,
          0 // Immediate
        );

        await prisma.escalationJob.create({
          data: {
            incidentId: incident.id,
            bullJobId,
            scheduledLevel: nextLevel?.levelNumber || 1,
            scheduledFor: new Date()
          }
        });

        logger.warn(
          { incidentId: incident.id, currentLevel: incident.currentLevel },
          'Rescheduled stale escalation'
        );

        rescheduled++;
      }
    }

    if (rescheduled > 0) {
      logger.info({ rescheduled }, 'Reconciled stale escalations on startup');
    }

    return rescheduled;
  }
}

export const escalationService = new EscalationService();
```
  </action>
  <verify>npm run build</verify>
  <done>Service compiles with escalation logic and reconciliation</done>
</task>

<task type="auto">
  <name>Task 2: Create escalation worker</name>
  <files>src/workers/escalation.worker.ts</files>
  <action>
Create src/workers/ directory and src/workers/escalation.worker.ts:

```typescript
import { Worker, Job } from 'bullmq';
import { getRedisConnectionOptions } from '../config/redis.js';
import { escalationService } from '../services/escalation.service.js';
import { prisma } from '../config/database.js';
import { logger } from '../config/logger.js';
import type { EscalationJobData } from '../queues/escalation.queue.js';

let worker: Worker<EscalationJobData> | null = null;

async function processEscalationJob(job: Job<EscalationJobData>): Promise<void> {
  const { incidentId, toLevel, repeatNumber } = job.data;

  logger.info(
    { jobId: job.id, incidentId, toLevel, repeatNumber },
    'Processing escalation job'
  );

  try {
    // Mark job as executing in database
    await prisma.escalationJob.updateMany({
      where: { bullJobId: job.id! },
      data: { executedAt: new Date() }
    });

    // Process escalation
    await escalationService.processEscalation(incidentId, toLevel, repeatNumber);

    // Mark job as completed
    await prisma.escalationJob.updateMany({
      where: { bullJobId: job.id! },
      data: { completed: true }
    });

    logger.info(
      { jobId: job.id, incidentId },
      'Escalation job completed'
    );
  } catch (error) {
    logger.error(
      { jobId: job.id, incidentId, error },
      'Escalation job failed'
    );
    throw error; // Let BullMQ handle retry
  }
}

export async function startEscalationWorker(): Promise<void> {
  if (worker) {
    logger.warn('Escalation worker already running');
    return;
  }

  worker = new Worker<EscalationJobData>(
    'escalation',
    processEscalationJob,
    {
      connection: getRedisConnectionOptions(),
      concurrency: 5, // Process up to 5 escalations in parallel
      limiter: {
        max: 100, // Max 100 jobs per minute (prevent runaway)
        duration: 60000
      }
    }
  );

  worker.on('completed', (job) => {
    logger.debug({ jobId: job.id }, 'Escalation job completed');
  });

  worker.on('failed', (job, error) => {
    logger.error({ jobId: job?.id, error: error.message }, 'Escalation job failed');
  });

  worker.on('error', (error) => {
    logger.error({ error: error.message }, 'Escalation worker error');
  });

  logger.info('Escalation worker started');

  // Reconcile any stale escalations
  const rescheduled = await escalationService.reconcileStaleEscalations();
  if (rescheduled > 0) {
    logger.info({ rescheduled }, 'Reconciled stale escalations');
  }
}

export async function stopEscalationWorker(): Promise<void> {
  if (worker) {
    await worker.close();
    worker = null;
    logger.info('Escalation worker stopped');
  }
}

// Graceful shutdown handler
export function setupGracefulShutdown(): void {
  const signals = ['SIGINT', 'SIGTERM'];

  signals.forEach((signal) => {
    process.on(signal, async () => {
      logger.info({ signal }, 'Received shutdown signal');
      await stopEscalationWorker();
      process.exit(0);
    });
  });
}
```

Create index file:

**src/workers/index.ts:**
```typescript
export * from './escalation.worker.js';
```
  </action>
  <verify>npm run build</verify>
  <done>Worker compiles with job processing and graceful shutdown</done>
</task>

<task type="auto">
  <name>Task 3: Integrate worker startup in application</name>
  <files>src/index.ts</files>
  <action>
Update src/index.ts to start the escalation worker:

Add imports at top:
```typescript
import { startEscalationWorker, setupGracefulShutdown } from './workers/escalation.worker.js';
```

Add worker startup after server starts (inside the async IIFE or server.listen callback):
```typescript
// Start background workers
if (process.env.NODE_ENV !== 'test') {
  try {
    await startEscalationWorker();
    setupGracefulShutdown();
    logger.info('Background workers started');
  } catch (error) {
    logger.error({ error }, 'Failed to start background workers - continuing without escalation');
    // Don't crash server if Redis unavailable, just log
  }
}
```

The check for `NODE_ENV !== 'test'` prevents worker startup during tests.
The try-catch ensures server starts even if Redis is unavailable (degraded mode).
  </action>
  <verify>npm run build</verify>
  <done>Worker integrated into server startup with graceful degradation</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` succeeds
- [ ] src/services/escalation.service.ts exports escalationService
- [ ] src/workers/escalation.worker.ts exports startEscalationWorker, stopEscalationWorker
- [ ] Worker checks incident status before escalating
- [ ] Reconciliation reschedules stale escalations on startup
- [ ] Graceful shutdown stops worker cleanly
</verification>

<success_criteria>
Escalation system complete:
- Worker processes delayed escalation jobs
- Status check prevents race with acknowledgment
- Multi-level progression with repeat support
- Stale escalation reconciliation on startup
- Graceful shutdown for clean deployments
- Server continues if Redis unavailable (degraded mode)
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-routing-and-deduplication/04-06-SUMMARY.md`
</output>

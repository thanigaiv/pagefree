---
phase: 04-alert-routing-and-deduplication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/config/redis.ts
  - src/queues/escalation.queue.ts
  - src/queues/notification.queue.ts
autonomous: true

must_haves:
  truths:
    - "BullMQ and ioredis are installed"
    - "Redis connection is configured with reconnect logic"
    - "Escalation queue accepts delayed jobs"
    - "Notification queue accepts jobs for future Phase 5"
  artifacts:
    - path: "package.json"
      provides: "bullmq and ioredis dependencies"
      contains: "bullmq"
    - path: "src/config/redis.ts"
      provides: "Redis connection singleton"
      exports: ["redisConnection", "getRedisClient"]
    - path: "src/queues/escalation.queue.ts"
      provides: "BullMQ escalation queue"
      exports: ["escalationQueue", "scheduleEscalation", "cancelEscalation"]
    - path: "src/queues/notification.queue.ts"
      provides: "BullMQ notification queue"
      exports: ["notificationQueue"]
  key_links:
    - from: "src/queues/escalation.queue.ts"
      to: "src/config/redis.ts"
      via: "import redisConnection"
      pattern: "import.*redis"
---

<objective>
Install BullMQ and configure Redis-backed job queues for escalation timers

Purpose: Escalation requires reliable delayed job execution that survives server restarts. BullMQ with Redis provides this.
Output: BullMQ installed, Redis connection configured, escalation and notification queues ready for use
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-alert-routing-and-deduplication/04-RESEARCH.md
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install BullMQ and ioredis dependencies</name>
  <files>package.json</files>
  <action>
Install BullMQ and ioredis:
```bash
npm install bullmq ioredis
npm install --save-dev @types/ioredis
```

BullMQ version 5.x is the target (current latest). It includes TypeScript types natively.
ioredis is the Redis client that BullMQ uses internally and we'll use for the connection.

After install, verify packages in package.json dependencies section.
  </action>
  <verify>npm ls bullmq ioredis</verify>
  <done>BullMQ and ioredis appear in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create Redis connection configuration</name>
  <files>src/config/redis.ts</files>
  <action>
Create Redis connection configuration at src/config/redis.ts:

```typescript
import Redis from 'ioredis';
import { logger } from './logger.js';

// Redis connection options
const redisConfig = {
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379', 10),
  password: process.env.REDIS_PASSWORD || undefined,
  maxRetriesPerRequest: null, // Required for BullMQ
  enableReadyCheck: false,    // Required for BullMQ
  retryStrategy: (times: number) => {
    if (times > 10) {
      logger.error({ times }, 'Redis connection failed after 10 retries');
      return null; // Stop retrying
    }
    const delay = Math.min(times * 200, 2000); // Exponential backoff, max 2s
    logger.warn({ times, delay }, 'Redis reconnecting...');
    return delay;
  }
};

// Singleton connection for BullMQ (shared across queues/workers)
let redisConnection: Redis | null = null;

export function getRedisClient(): Redis {
  if (!redisConnection) {
    redisConnection = new Redis(redisConfig);

    redisConnection.on('connect', () => {
      logger.info('Redis connected');
    });

    redisConnection.on('error', (err) => {
      logger.error({ err }, 'Redis connection error');
    });

    redisConnection.on('close', () => {
      logger.warn('Redis connection closed');
    });
  }
  return redisConnection;
}

// For BullMQ - returns connection config object (not the client)
export function getRedisConnectionOptions() {
  return redisConfig;
}

// Graceful shutdown
export async function closeRedisConnection(): Promise<void> {
  if (redisConnection) {
    await redisConnection.quit();
    redisConnection = null;
    logger.info('Redis connection closed gracefully');
  }
}
```

Note: BullMQ requires `maxRetriesPerRequest: null` and `enableReadyCheck: false`.
  </action>
  <verify>npm run build</verify>
  <done>Redis config compiles, exports getRedisClient and getRedisConnectionOptions</done>
</task>

<task type="auto">
  <name>Task 3: Create escalation and notification queues</name>
  <files>src/queues/escalation.queue.ts, src/queues/notification.queue.ts</files>
  <action>
Create src/queues/ directory and queue files:

**src/queues/escalation.queue.ts:**
```typescript
import { Queue, Job } from 'bullmq';
import { getRedisConnectionOptions } from '../config/redis.js';
import { logger } from '../config/logger.js';

// Job data interfaces
export interface EscalationJobData {
  incidentId: string;
  toLevel: number;
  repeatNumber: number;
}

// Create escalation queue
export const escalationQueue = new Queue<EscalationJobData>('escalation', {
  connection: getRedisConnectionOptions(),
  defaultJobOptions: {
    removeOnComplete: true,
    removeOnFail: false, // Keep failed jobs for debugging
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 5000
    }
  }
});

// Schedule an escalation job
export async function scheduleEscalation(
  incidentId: string,
  currentLevel: number,
  repeatNumber: number,
  timeoutMinutes: number
): Promise<string> {
  const jobId = `incident:${incidentId}:level:${currentLevel + 1}:repeat:${repeatNumber}`;
  const delayMs = timeoutMinutes * 60 * 1000;

  await escalationQueue.add(
    'escalate',
    {
      incidentId,
      toLevel: currentLevel + 1,
      repeatNumber
    },
    {
      jobId,
      delay: delayMs
    }
  );

  logger.info(
    { incidentId, toLevel: currentLevel + 1, delayMs, jobId },
    'Scheduled escalation job'
  );

  return jobId;
}

// Cancel escalation jobs for an incident
export async function cancelEscalation(bullJobId: string): Promise<boolean> {
  try {
    const job = await escalationQueue.getJob(bullJobId);
    if (job) {
      await job.remove();
      logger.info({ bullJobId }, 'Cancelled escalation job');
      return true;
    }
    return false;
  } catch (error) {
    logger.error({ bullJobId, error }, 'Failed to cancel escalation job');
    return false;
  }
}

// Get queue metrics (for health checks)
export async function getEscalationQueueStats() {
  const [waiting, active, delayed, failed] = await Promise.all([
    escalationQueue.getWaitingCount(),
    escalationQueue.getActiveCount(),
    escalationQueue.getDelayedCount(),
    escalationQueue.getFailedCount()
  ]);

  return { waiting, active, delayed, failed };
}
```

**src/queues/notification.queue.ts:**
```typescript
import { Queue } from 'bullmq';
import { getRedisConnectionOptions } from '../config/redis.js';

// Job data interfaces
export interface NotificationJobData {
  userId: string;
  incidentId: string;
  type: 'new_incident' | 'escalation' | 'acknowledgment' | 'resolution';
  channels?: string[]; // Override user preferences
}

// Create notification queue (used by Phase 5)
export const notificationQueue = new Queue<NotificationJobData>('notification', {
  connection: getRedisConnectionOptions(),
  defaultJobOptions: {
    removeOnComplete: true,
    removeOnFail: false,
    attempts: 5, // More retries for notifications (critical path)
    backoff: {
      type: 'exponential',
      delay: 2000
    }
  }
});

// Queue notification job
export async function queueNotification(data: NotificationJobData): Promise<string> {
  const job = await notificationQueue.add('notify', data);
  return job.id!;
}

// Get queue metrics
export async function getNotificationQueueStats() {
  const [waiting, active, delayed, failed] = await Promise.all([
    notificationQueue.getWaitingCount(),
    notificationQueue.getActiveCount(),
    notificationQueue.getDelayedCount(),
    notificationQueue.getFailedCount()
  ]);

  return { waiting, active, delayed, failed };
}
```

Create index file for queues:

**src/queues/index.ts:**
```typescript
export * from './escalation.queue.js';
export * from './notification.queue.js';
```
  </action>
  <verify>npm run build</verify>
  <done>Queue files compile, exports are correct</done>
</task>

</tasks>

<verification>
- [ ] `npm ls bullmq ioredis` shows packages installed
- [ ] `npm run build` succeeds
- [ ] src/config/redis.ts exports getRedisClient, getRedisConnectionOptions
- [ ] src/queues/escalation.queue.ts exports escalationQueue, scheduleEscalation, cancelEscalation
- [ ] src/queues/notification.queue.ts exports notificationQueue, queueNotification
</verification>

<success_criteria>
BullMQ infrastructure ready:
- Redis connection configured with reconnect logic
- Escalation queue created with delayed job support
- Notification queue created for Phase 5
- Job scheduling and cancellation functions available
- Queue metrics functions for health checks
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-routing-and-deduplication/04-02-SUMMARY.md`
</output>

---
phase: 04-alert-routing-and-deduplication
plan: 07
type: execute
wave: 3
depends_on: ["04-04", "04-05"]
files_modified:
  - src/routes/alert.routes.ts
  - src/services/alert.service.ts
  - src/webhooks/alert-receiver.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can search alerts by status, severity, date range"
    - "Alert search supports pagination with cursor"
    - "Webhook receiver triggers deduplication and routing"
    - "Complete alert history maintained with audit trail"
  artifacts:
    - path: "src/services/alert.service.ts"
      provides: "Alert search and history service"
      exports: ["alertService"]
    - path: "src/routes/alert.routes.ts"
      provides: "Alert search API endpoints"
      exports: ["alertRoutes"]
  key_links:
    - from: "src/webhooks/alert-receiver.ts"
      to: "src/services/deduplication.service.ts"
      via: "deduplicateAndCreateIncident call"
      pattern: "deduplicationService\\.deduplicateAndCreateIncident"
    - from: "src/webhooks/alert-receiver.ts"
      to: "src/services/escalation.service.ts"
      via: "startEscalation call"
      pattern: "escalationService\\.startEscalation"
---

<objective>
Create alert search API and wire webhook receiver to deduplication/routing pipeline

Purpose: Complete the alert routing flow - webhooks trigger deduplication, routing, and escalation. Plus search API for ALERT-04 requirement.
Output: Alert search service, REST API with filters/pagination, webhook receiver integrated with incident pipeline
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-alert-routing-and-deduplication/04-RESEARCH.md

# Existing webhook receiver to extend
@src/webhooks/alert-receiver.ts

# Deduplication service
@src/services/deduplication.service.ts

# Escalation service
@src/services/escalation.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create alert search service</name>
  <files>src/services/alert.service.ts</files>
  <action>
Create src/services/alert.service.ts:

```typescript
import { prisma } from '../config/database.js';
import { logger } from '../config/logger.js';

interface AlertSearchQuery {
  teamId?: string;
  integrationId?: string;
  status?: string | string[];
  severity?: string | string[];
  searchTerm?: string;
  startDate?: Date;
  endDate?: Date;
  incidentId?: string;
  hasIncident?: boolean;
}

interface PaginationOptions {
  limit?: number;
  cursor?: string;
}

interface AlertSearchResult {
  alerts: any[];
  nextCursor: string | null;
  total?: number;
}

class AlertService {
  // Search alerts with filters (ALERT-04)
  async search(
    query: AlertSearchQuery,
    options: PaginationOptions = {}
  ): Promise<AlertSearchResult> {
    const { limit = 50, cursor } = options;

    const where: any = {};

    // Filter by integration
    if (query.integrationId) {
      where.integrationId = query.integrationId;
    }

    // Filter by status (via incident)
    if (query.status) {
      const statuses = Array.isArray(query.status) ? query.status : [query.status];
      where.incident = { status: { in: statuses } };
    }

    // Filter by severity
    if (query.severity) {
      const severities = Array.isArray(query.severity) ? query.severity : [query.severity];
      where.severity = { in: severities };
    }

    // Filter by team (via incident)
    if (query.teamId) {
      where.incident = { ...where.incident, teamId: query.teamId };
    }

    // Filter by incident
    if (query.incidentId) {
      where.incidentId = query.incidentId;
    }

    // Filter alerts with/without incidents
    if (query.hasIncident !== undefined) {
      where.incidentId = query.hasIncident ? { not: null } : null;
    }

    // Date range on triggeredAt
    if (query.startDate || query.endDate) {
      where.triggeredAt = {
        ...(query.startDate && { gte: query.startDate }),
        ...(query.endDate && { lte: query.endDate })
      };
    }

    // Full-text search on title and description
    if (query.searchTerm) {
      where.OR = [
        { title: { contains: query.searchTerm, mode: 'insensitive' } },
        { description: { contains: query.searchTerm, mode: 'insensitive' } }
      ];
    }

    // Execute query with cursor pagination
    const alerts = await prisma.alert.findMany({
      where,
      take: limit,
      ...(cursor && {
        skip: 1,
        cursor: { id: cursor }
      }),
      orderBy: { triggeredAt: 'desc' },
      include: {
        integration: { select: { id: true, name: true, type: true } },
        incident: {
          select: {
            id: true,
            status: true,
            priority: true,
            teamId: true,
            assignedUserId: true,
            createdAt: true,
            acknowledgedAt: true,
            resolvedAt: true
          }
        }
      }
    });

    return {
      alerts,
      nextCursor: alerts.length === limit ? alerts[alerts.length - 1].id : null
    };
  }

  // Get alert by ID with full details
  async getById(id: string): Promise<any> {
    return prisma.alert.findUnique({
      where: { id },
      include: {
        integration: { select: { id: true, name: true, type: true } },
        incident: {
          select: {
            id: true,
            status: true,
            priority: true,
            teamId: true,
            team: { select: { id: true, name: true } },
            assignedUserId: true,
            assignedUser: { select: { id: true, firstName: true, lastName: true } },
            alertCount: true,
            createdAt: true,
            acknowledgedAt: true,
            resolvedAt: true
          }
        },
        deliveries: {
          select: {
            id: true,
            statusCode: true,
            processedAt: true,
            errorMessage: true
          },
          orderBy: { processedAt: 'desc' },
          take: 5
        }
      }
    });
  }

  // Get alert history for a team (ALERT-05)
  async getHistory(
    teamId: string,
    options: {
      days?: number;
      limit?: number;
      includeResolved?: boolean;
    } = {}
  ): Promise<any[]> {
    const { days = 30, limit = 100, includeResolved = true } = options;

    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    const statuses = includeResolved
      ? ['OPEN', 'ACKNOWLEDGED', 'RESOLVED', 'CLOSED']
      : ['OPEN', 'ACKNOWLEDGED'];

    return prisma.alert.findMany({
      where: {
        incident: {
          teamId,
          status: { in: statuses }
        },
        triggeredAt: { gte: startDate }
      },
      take: limit,
      orderBy: { triggeredAt: 'desc' },
      include: {
        incident: {
          select: {
            id: true,
            status: true,
            priority: true,
            alertCount: true
          }
        }
      }
    });
  }

  // Get alert counts by severity for dashboard
  async getCountsBySeverity(
    teamId?: string,
    days: number = 7
  ): Promise<Record<string, number>> {
    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    const where: any = { triggeredAt: { gte: startDate } };

    if (teamId) {
      where.incident = { teamId };
    }

    const counts = await prisma.alert.groupBy({
      by: ['severity'],
      where,
      _count: { severity: true }
    });

    return counts.reduce((acc, { severity, _count }) => {
      acc[severity] = _count.severity;
      return acc;
    }, {} as Record<string, number>);
  }

  // Get alert trend data for charts
  async getAlertTrend(
    teamId?: string,
    days: number = 7,
    granularity: 'hour' | 'day' = 'day'
  ): Promise<Array<{ date: string; count: number }>> {
    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    // Use raw query for date grouping
    const result = await prisma.$queryRaw<Array<{ date: string; count: bigint }>>`
      SELECT
        DATE_TRUNC(${granularity}, "triggeredAt") as date,
        COUNT(*) as count
      FROM "Alert" a
      ${teamId ? prisma.$queryRaw`
        JOIN "Incident" i ON a."incidentId" = i.id
        WHERE i."teamId" = ${teamId}
        AND a."triggeredAt" >= ${startDate}
      ` : prisma.$queryRaw`
        WHERE a."triggeredAt" >= ${startDate}
      `}
      GROUP BY DATE_TRUNC(${granularity}, "triggeredAt")
      ORDER BY date ASC
    `;

    return result.map(row => ({
      date: row.date,
      count: Number(row.count)
    }));
  }
}

export const alertService = new AlertService();
```
  </action>
  <verify>npm run build</verify>
  <done>Service compiles with search and analytics methods</done>
</task>

<task type="auto">
  <name>Task 2: Create alert routes</name>
  <files>src/routes/alert.routes.ts, src/index.ts</files>
  <action>
Create src/routes/alert.routes.ts:

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { alertService } from '../services/alert.service.js';
import { rbacService } from '../services/rbac.service.js';
import { logger } from '../config/logger.js';

const router = Router();

// GET /api/alerts - Search alerts (ALERT-04)
router.get('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const {
      teamId,
      integrationId,
      status,
      severity,
      searchTerm,
      startDate,
      endDate,
      incidentId,
      hasIncident,
      limit,
      cursor
    } = req.query;

    // If teamId specified, check access
    if (teamId) {
      const permission = await rbacService.checkTeamPermission(
        (req as any).user.id,
        teamId as string,
        'view'
      );

      if (!permission.allowed) {
        return res.status(403).json({ error: permission.reason });
      }
    }

    const result = await alertService.search(
      {
        teamId: teamId as string,
        integrationId: integrationId as string,
        status: status as string,
        severity: severity as string,
        searchTerm: searchTerm as string,
        startDate: startDate ? new Date(startDate as string) : undefined,
        endDate: endDate ? new Date(endDate as string) : undefined,
        incidentId: incidentId as string,
        hasIncident: hasIncident === 'true' ? true : hasIncident === 'false' ? false : undefined
      },
      {
        limit: limit ? parseInt(limit as string, 10) : undefined,
        cursor: cursor as string
      }
    );

    res.json(result);
  } catch (error) {
    next(error);
  }
});

// GET /api/alerts/history - Team alert history (ALERT-05)
router.get('/history/:teamId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { teamId } = req.params;
    const { days, limit, includeResolved } = req.query;

    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      teamId,
      'view'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const alerts = await alertService.getHistory(teamId, {
      days: days ? parseInt(days as string, 10) : undefined,
      limit: limit ? parseInt(limit as string, 10) : undefined,
      includeResolved: includeResolved !== 'false'
    });

    res.json({ alerts });
  } catch (error) {
    next(error);
  }
});

// GET /api/alerts/stats - Alert statistics
router.get('/stats', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { teamId, days } = req.query;

    if (teamId) {
      const permission = await rbacService.checkTeamPermission(
        (req as any).user.id,
        teamId as string,
        'view'
      );

      if (!permission.allowed) {
        return res.status(403).json({ error: permission.reason });
      }
    }

    const counts = await alertService.getCountsBySeverity(
      teamId as string,
      days ? parseInt(days as string, 10) : undefined
    );

    res.json({ counts });
  } catch (error) {
    next(error);
  }
});

// GET /api/alerts/:id - Get alert details
router.get('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const alert = await alertService.getById(req.params.id);

    if (!alert) {
      return res.status(404).json({ error: 'Alert not found' });
    }

    // Check team access if alert has incident
    if (alert.incident?.teamId) {
      const permission = await rbacService.checkTeamPermission(
        (req as any).user.id,
        alert.incident.teamId,
        'view'
      );

      if (!permission.allowed) {
        return res.status(403).json({ error: permission.reason });
      }
    }

    res.json({ alert });
  } catch (error) {
    next(error);
  }
});

export const alertRoutes = router;
```

Update src/index.ts to mount routes:

```typescript
// Add import at top
import { alertRoutes } from './routes/alert.routes.js';

// Add after other authenticated routes
app.use('/api/alerts', alertRoutes);
```
  </action>
  <verify>npm run build</verify>
  <done>Routes compile, mounted in index.ts</done>
</task>

<task type="auto">
  <name>Task 3: Wire webhook receiver to incident pipeline</name>
  <files>src/webhooks/alert-receiver.ts</files>
  <action>
Update src/webhooks/alert-receiver.ts to integrate deduplication and escalation:

Add imports at top:
```typescript
import { deduplicationService } from '../services/deduplication.service.js';
import { escalationService } from '../services/escalation.service.js';
import { generateContentFingerprint } from '../utils/content-fingerprint.js';
```

Find the section where alerts are created (after validation and idempotency check passes).
After the alert is created successfully, add the deduplication and escalation logic:

```typescript
// After alert creation (pseudocode location - find the actual create call):
// const alert = await prisma.alert.create({ ... });

// Generate fingerprint for deduplication
const fingerprint = generateContentFingerprint({
  title: alert.title,
  source: alert.source,
  severity: alert.severity,
  // Include service metadata if present
  service: (alert.metadata as any)?.service || alert.source
});

// Deduplicate and create/link incident
const { incident, isDuplicate } = await deduplicationService.deduplicateAndCreateIncident(
  alert.id,
  fingerprint,
  alert,
  integration.deduplicationWindowMinutes
);

// If new incident, start escalation
if (!isDuplicate) {
  await escalationService.startEscalation(incident.id);
}

logger.info(
  {
    alertId: alert.id,
    incidentId: incident.id,
    isDuplicate,
    fingerprint: fingerprint.substring(0, 16)
  },
  isDuplicate ? 'Alert grouped to existing incident' : 'New incident created from alert'
);
```

The exact integration point depends on the current structure of alert-receiver.ts.
Key points:
1. Generate fingerprint from alert title + source + service metadata
2. Call deduplicationService which handles transaction + routing
3. Only start escalation for new incidents (not duplicates)
4. Log with incident ID for traceability
  </action>
  <verify>npm run build</verify>
  <done>Webhook receiver wired to deduplication and escalation</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` succeeds
- [ ] src/services/alert.service.ts exports alertService
- [ ] src/routes/alert.routes.ts exports alertRoutes
- [ ] Routes mounted at /api/alerts in index.ts
- [ ] Webhook receiver calls deduplicationService
- [ ] New incidents trigger escalationService.startEscalation
</verification>

<success_criteria>
Alert routing pipeline complete:
- Search API supports status, severity, date, text filters
- Pagination with cursor for large result sets
- Webhook receiver integrated with deduplication
- New incidents automatically start escalation
- Alert history tracked per team
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-routing-and-deduplication/04-07-SUMMARY.md`
</output>

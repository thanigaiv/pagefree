---
phase: 04-alert-routing-and-deduplication
plan: 08
type: execute
wave: 3
depends_on: ["04-03", "04-04", "04-05", "04-06", "04-07"]
files_modified:
  - src/tests/incident.test.ts
  - src/tests/escalation.test.ts
  - src/tests/alert-routing.test.ts
autonomous: true

must_haves:
  truths:
    - "Tests verify deduplication prevents duplicate incidents"
    - "Tests verify escalation flow and acknowledgment stops escalation"
    - "Tests verify alert routing to correct team"
    - "All Phase 4 requirements have test coverage"
  artifacts:
    - path: "src/tests/incident.test.ts"
      provides: "Incident lifecycle tests"
    - path: "src/tests/escalation.test.ts"
      provides: "Escalation policy and flow tests"
    - path: "src/tests/alert-routing.test.ts"
      provides: "Alert routing and deduplication tests"
  key_links:
    - from: "src/tests/*.test.ts"
      to: "src/services/*.service.ts"
      via: "service method calls"
      pattern: "describe.*Service"
---

<objective>
Create integration tests for Phase 4 functionality

Purpose: Verify all Phase 4 requirements work correctly - deduplication, routing, escalation, incident lifecycle. Tests provide regression safety.
Output: Integration tests covering ALERT-02, ALERT-04, ALERT-05, ROUTE-01 through ROUTE-05
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-alert-routing-and-deduplication/04-RESEARCH.md

# Test setup patterns
@src/tests/setup.ts

# Services to test
@src/services/incident.service.ts
@src/services/escalation.service.ts
@src/services/deduplication.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create incident lifecycle tests</name>
  <files>src/tests/incident.test.ts</files>
  <action>
Create src/tests/incident.test.ts:

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { prisma } from '../config/database.js';
import { incidentService } from '../services/incident.service.js';
import { escalationPolicyService } from '../services/escalation-policy.service.js';

describe('Incident Service', () => {
  let testTeam: any;
  let testUser: any;
  let testPolicy: any;
  let testIncident: any;

  beforeAll(async () => {
    // Create test team
    testTeam = await prisma.team.create({
      data: { name: `test-incident-team-${Date.now()}` }
    });

    // Create test user
    testUser = await prisma.user.create({
      data: {
        email: `incident-test-${Date.now()}@example.com`,
        firstName: 'Test',
        lastName: 'User'
      }
    });

    // Add user to team
    await prisma.teamMember.create({
      data: {
        userId: testUser.id,
        teamId: testTeam.id,
        role: 'RESPONDER'
      }
    });

    // Create escalation policy
    testPolicy = await escalationPolicyService.create({
      teamId: testTeam.id,
      name: 'Test Policy',
      isDefault: true,
      levels: [
        { levelNumber: 1, targetType: 'user', targetId: testUser.id, timeoutMinutes: 5 }
      ]
    }, testUser.id);
  });

  afterAll(async () => {
    // Cleanup
    await prisma.incident.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.escalationPolicy.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.teamMember.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.user.delete({ where: { id: testUser.id } });
    await prisma.team.delete({ where: { id: testTeam.id } });
  });

  beforeEach(async () => {
    // Create fresh incident for each test
    testIncident = await prisma.incident.create({
      data: {
        fingerprint: `test-fingerprint-${Date.now()}`,
        status: 'OPEN',
        priority: 'HIGH',
        teamId: testTeam.id,
        escalationPolicyId: testPolicy.id,
        assignedUserId: testUser.id
      }
    });
  });

  describe('acknowledge', () => {
    it('should update status to ACKNOWLEDGED', async () => {
      const result = await incidentService.acknowledge(
        testIncident.id,
        testUser.id
      );

      expect(result.status).toBe('ACKNOWLEDGED');
      expect(result.acknowledgedAt).toBeDefined();
    });

    it('should assign to acknowledging user', async () => {
      // Create another user
      const otherUser = await prisma.user.create({
        data: {
          email: `other-${Date.now()}@example.com`,
          firstName: 'Other',
          lastName: 'User'
        }
      });

      await prisma.teamMember.create({
        data: { userId: otherUser.id, teamId: testTeam.id, role: 'RESPONDER' }
      });

      const result = await incidentService.acknowledge(
        testIncident.id,
        otherUser.id
      );

      expect(result.assignedUserId).toBe(otherUser.id);

      // Cleanup
      await prisma.teamMember.deleteMany({ where: { userId: otherUser.id } });
      await prisma.user.delete({ where: { id: otherUser.id } });
    });

    it('should reject if already acknowledged', async () => {
      await incidentService.acknowledge(testIncident.id, testUser.id);

      await expect(
        incidentService.acknowledge(testIncident.id, testUser.id)
      ).rejects.toThrow('Cannot acknowledge');
    });
  });

  describe('resolve', () => {
    it('should update status to RESOLVED', async () => {
      const result = await incidentService.resolve(
        testIncident.id,
        testUser.id,
        { resolutionNote: 'Fixed by restarting service' }
      );

      expect(result.status).toBe('RESOLVED');
      expect(result.resolvedAt).toBeDefined();
    });

    it('should work on acknowledged incidents', async () => {
      await incidentService.acknowledge(testIncident.id, testUser.id);

      const result = await incidentService.resolve(
        testIncident.id,
        testUser.id,
        {}
      );

      expect(result.status).toBe('RESOLVED');
    });
  });

  describe('reassign', () => {
    it('should update assignedUserId', async () => {
      const otherUser = await prisma.user.create({
        data: {
          email: `reassign-${Date.now()}@example.com`,
          firstName: 'Reassign',
          lastName: 'Target'
        }
      });

      await prisma.teamMember.create({
        data: { userId: otherUser.id, teamId: testTeam.id, role: 'RESPONDER' }
      });

      const result = await incidentService.reassign(
        testIncident.id,
        otherUser.id,
        testUser.id,
        'Handing off to specialist'
      );

      expect(result.assignedUserId).toBe(otherUser.id);

      // Cleanup
      await prisma.teamMember.deleteMany({ where: { userId: otherUser.id } });
      await prisma.user.delete({ where: { id: otherUser.id } });
    });

    it('should reject non-team member as assignee', async () => {
      const nonMember = await prisma.user.create({
        data: {
          email: `nonmember-${Date.now()}@example.com`,
          firstName: 'Non',
          lastName: 'Member'
        }
      });

      await expect(
        incidentService.reassign(testIncident.id, nonMember.id, testUser.id)
      ).rejects.toThrow('must be an active team responder');

      await prisma.user.delete({ where: { id: nonMember.id } });
    });
  });

  describe('list', () => {
    it('should filter by team', async () => {
      const result = await incidentService.list({ teamId: testTeam.id });

      expect(result.incidents.length).toBeGreaterThan(0);
      expect(result.incidents.every((i: any) => i.teamId === testTeam.id)).toBe(true);
    });

    it('should filter by status', async () => {
      const result = await incidentService.list({
        teamId: testTeam.id,
        status: 'OPEN'
      });

      expect(result.incidents.every((i: any) => i.status === 'OPEN')).toBe(true);
    });

    it('should support pagination', async () => {
      const first = await incidentService.list({ teamId: testTeam.id }, { limit: 1 });
      expect(first.incidents.length).toBe(1);

      if (first.nextCursor) {
        const second = await incidentService.list(
          { teamId: testTeam.id },
          { limit: 1, cursor: first.nextCursor }
        );
        expect(second.incidents[0].id).not.toBe(first.incidents[0].id);
      }
    });
  });
});
```
  </action>
  <verify>npm test src/tests/incident.test.ts</verify>
  <done>Incident tests pass covering acknowledge, resolve, reassign, list</done>
</task>

<task type="auto">
  <name>Task 2: Create escalation policy and flow tests</name>
  <files>src/tests/escalation.test.ts</files>
  <action>
Create src/tests/escalation.test.ts:

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach, vi } from 'vitest';
import { prisma } from '../config/database.js';
import { escalationPolicyService } from '../services/escalation-policy.service.js';
import { escalationService } from '../services/escalation.service.js';

describe('Escalation Policy Service', () => {
  let testTeam: any;
  let testUser: any;

  beforeAll(async () => {
    testTeam = await prisma.team.create({
      data: { name: `test-escalation-team-${Date.now()}` }
    });

    testUser = await prisma.user.create({
      data: {
        email: `escalation-test-${Date.now()}@example.com`,
        firstName: 'Test',
        lastName: 'User'
      }
    });

    await prisma.teamMember.create({
      data: { userId: testUser.id, teamId: testTeam.id, role: 'TEAM_ADMIN' }
    });
  });

  afterAll(async () => {
    await prisma.escalationPolicy.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.teamMember.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.user.delete({ where: { id: testUser.id } });
    await prisma.team.delete({ where: { id: testTeam.id } });
  });

  describe('create', () => {
    it('should create policy with levels', async () => {
      const policy = await escalationPolicyService.create({
        teamId: testTeam.id,
        name: 'Test Policy',
        levels: [
          { levelNumber: 1, targetType: 'user', targetId: testUser.id, timeoutMinutes: 5 },
          { levelNumber: 2, targetType: 'entire_team', timeoutMinutes: 10 }
        ]
      }, testUser.id);

      expect(policy.name).toBe('Test Policy');
      expect(policy.levels.length).toBe(2);
      expect(policy.levels[0].levelNumber).toBe(1);
      expect(policy.levels[1].levelNumber).toBe(2);
    });

    it('should enforce minimum timeout for single target', async () => {
      await expect(
        escalationPolicyService.create({
          teamId: testTeam.id,
          name: 'Invalid Timeout',
          levels: [
            { levelNumber: 1, targetType: 'user', targetId: testUser.id, timeoutMinutes: 0 }
          ]
        }, testUser.id)
      ).rejects.toThrow('minimum timeout');
    });

    it('should require sequential level numbers', async () => {
      await expect(
        escalationPolicyService.create({
          teamId: testTeam.id,
          name: 'Skip Level',
          levels: [
            { levelNumber: 1, targetType: 'user', targetId: testUser.id },
            { levelNumber: 3, targetType: 'entire_team' } // Skips 2
          ]
        }, testUser.id)
      ).rejects.toThrow('sequential');
    });

    it('should set as default when specified', async () => {
      const policy = await escalationPolicyService.create({
        teamId: testTeam.id,
        name: 'Default Policy',
        isDefault: true,
        levels: [{ levelNumber: 1, targetType: 'entire_team' }]
      }, testUser.id);

      expect(policy.isDefault).toBe(true);

      const fetched = await escalationPolicyService.getDefaultForTeam(testTeam.id);
      expect(fetched?.id).toBe(policy.id);
    });
  });

  describe('update', () => {
    it('should update policy properties', async () => {
      const policy = await escalationPolicyService.create({
        teamId: testTeam.id,
        name: 'Update Test',
        levels: [{ levelNumber: 1, targetType: 'entire_team' }]
      }, testUser.id);

      const updated = await escalationPolicyService.update(
        policy.id,
        { name: 'Updated Name', repeatCount: 3 },
        testUser.id
      );

      expect(updated.name).toBe('Updated Name');
      expect(updated.repeatCount).toBe(3);
    });
  });

  describe('delete', () => {
    it('should delete policy without incidents', async () => {
      const policy = await escalationPolicyService.create({
        teamId: testTeam.id,
        name: 'Delete Test',
        levels: [{ levelNumber: 1, targetType: 'entire_team' }]
      }, testUser.id);

      await escalationPolicyService.delete(policy.id, testUser.id);

      const fetched = await escalationPolicyService.getById(policy.id);
      expect(fetched).toBeNull();
    });
  });
});

describe('Escalation Service', () => {
  let testTeam: any;
  let testUser: any;
  let testPolicy: any;

  beforeAll(async () => {
    testTeam = await prisma.team.create({
      data: { name: `test-esc-service-${Date.now()}` }
    });

    testUser = await prisma.user.create({
      data: {
        email: `esc-service-${Date.now()}@example.com`,
        firstName: 'Test',
        lastName: 'User'
      }
    });

    await prisma.teamMember.create({
      data: { userId: testUser.id, teamId: testTeam.id, role: 'RESPONDER' }
    });

    testPolicy = await escalationPolicyService.create({
      teamId: testTeam.id,
      name: 'Escalation Test Policy',
      isDefault: true,
      repeatCount: 2,
      levels: [
        { levelNumber: 1, targetType: 'user', targetId: testUser.id, timeoutMinutes: 1 },
        { levelNumber: 2, targetType: 'entire_team', timeoutMinutes: 1 }
      ]
    }, testUser.id);
  });

  afterAll(async () => {
    await prisma.escalationJob.deleteMany({
      where: { incident: { teamId: testTeam.id } }
    });
    await prisma.incident.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.escalationPolicy.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.teamMember.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.user.delete({ where: { id: testUser.id } });
    await prisma.team.delete({ where: { id: testTeam.id } });
  });

  describe('processEscalation', () => {
    it('should skip if incident already acknowledged', async () => {
      const incident = await prisma.incident.create({
        data: {
          fingerprint: `esc-ack-test-${Date.now()}`,
          status: 'ACKNOWLEDGED',
          priority: 'HIGH',
          teamId: testTeam.id,
          escalationPolicyId: testPolicy.id,
          currentLevel: 1
        }
      });

      // Should not throw or escalate
      await escalationService.processEscalation(incident.id, 2, 1);

      const updated = await prisma.incident.findUnique({ where: { id: incident.id } });
      expect(updated?.currentLevel).toBe(1); // Unchanged
    });

    it('should escalate OPEN incident to next level', async () => {
      const incident = await prisma.incident.create({
        data: {
          fingerprint: `esc-open-test-${Date.now()}`,
          status: 'OPEN',
          priority: 'HIGH',
          teamId: testTeam.id,
          escalationPolicyId: testPolicy.id,
          currentLevel: 1,
          currentRepeat: 1
        }
      });

      await escalationService.processEscalation(incident.id, 2, 1);

      const updated = await prisma.incident.findUnique({ where: { id: incident.id } });
      expect(updated?.currentLevel).toBe(2);
      expect(updated?.lastEscalatedAt).toBeDefined();
    });
  });
});
```
  </action>
  <verify>npm test src/tests/escalation.test.ts</verify>
  <done>Escalation tests pass covering policy CRUD and flow</done>
</task>

<task type="auto">
  <name>Task 3: Create alert routing and deduplication tests</name>
  <files>src/tests/alert-routing.test.ts</files>
  <action>
Create src/tests/alert-routing.test.ts:

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { prisma } from '../config/database.js';
import { deduplicationService } from '../services/deduplication.service.js';
import { alertService } from '../services/alert.service.js';
import { escalationPolicyService } from '../services/escalation-policy.service.js';

describe('Deduplication Service', () => {
  let testTeam: any;
  let testUser: any;
  let testPolicy: any;
  let testIntegration: any;

  beforeAll(async () => {
    testTeam = await prisma.team.create({
      data: { name: `test-dedup-team-${Date.now()}` }
    });

    // Add technical tag for routing
    await prisma.teamTag.create({
      data: {
        teamId: testTeam.id,
        tagType: 'TECHNICAL',
        tagValue: 'test-service'
      }
    });

    testUser = await prisma.user.create({
      data: {
        email: `dedup-test-${Date.now()}@example.com`,
        firstName: 'Test',
        lastName: 'User'
      }
    });

    await prisma.teamMember.create({
      data: { userId: testUser.id, teamId: testTeam.id, role: 'RESPONDER' }
    });

    testPolicy = await escalationPolicyService.create({
      teamId: testTeam.id,
      name: 'Dedup Test Policy',
      isDefault: true,
      levels: [{ levelNumber: 1, targetType: 'user', targetId: testUser.id }]
    }, testUser.id);

    testIntegration = await prisma.integration.create({
      data: {
        name: `test-integration-${Date.now()}`,
        type: 'generic',
        webhookSecret: 'test-secret-123',
        deduplicationWindowMinutes: 15
      }
    });
  });

  afterAll(async () => {
    await prisma.escalationJob.deleteMany({
      where: { incident: { teamId: testTeam.id } }
    });
    await prisma.alert.deleteMany({ where: { integrationId: testIntegration.id } });
    await prisma.incident.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.integration.delete({ where: { id: testIntegration.id } });
    await prisma.escalationPolicy.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.teamTag.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.teamMember.deleteMany({ where: { teamId: testTeam.id } });
    await prisma.user.delete({ where: { id: testUser.id } });
    await prisma.team.delete({ where: { id: testTeam.id } });
  });

  describe('deduplicateAndCreateIncident', () => {
    it('should create new incident for new fingerprint', async () => {
      const alert = await prisma.alert.create({
        data: {
          title: 'New Alert',
          severity: 'HIGH',
          source: testIntegration.name,
          integrationId: testIntegration.id,
          triggeredAt: new Date(),
          metadata: { service: 'test-service' }
        }
      });

      const fingerprint = `unique-${Date.now()}`;
      const result = await deduplicationService.deduplicateAndCreateIncident(
        alert.id,
        fingerprint,
        alert,
        15
      );

      expect(result.isDuplicate).toBe(false);
      expect(result.incident).toBeDefined();
      expect(result.incident.fingerprint).toBe(fingerprint);
      expect(result.incident.status).toBe('OPEN');
    });

    it('should group alert to existing incident with same fingerprint', async () => {
      const fingerprint = `dedup-test-${Date.now()}`;

      // Create first alert and incident
      const alert1 = await prisma.alert.create({
        data: {
          title: 'First Alert',
          severity: 'HIGH',
          source: testIntegration.name,
          integrationId: testIntegration.id,
          triggeredAt: new Date(),
          metadata: { service: 'test-service' }
        }
      });

      const result1 = await deduplicationService.deduplicateAndCreateIncident(
        alert1.id,
        fingerprint,
        alert1,
        15
      );

      expect(result1.isDuplicate).toBe(false);

      // Create second alert with same fingerprint
      const alert2 = await prisma.alert.create({
        data: {
          title: 'Second Alert',
          severity: 'HIGH',
          source: testIntegration.name,
          integrationId: testIntegration.id,
          triggeredAt: new Date(),
          metadata: { service: 'test-service' }
        }
      });

      const result2 = await deduplicationService.deduplicateAndCreateIncident(
        alert2.id,
        fingerprint,
        alert2,
        15
      );

      expect(result2.isDuplicate).toBe(true);
      expect(result2.incident.id).toBe(result1.incident.id);
      expect(result2.incident.alertCount).toBe(2);
    });

    it('should create new incident outside deduplication window', async () => {
      const fingerprint = `window-test-${Date.now()}`;

      // Create incident with old timestamp
      const oldIncident = await prisma.incident.create({
        data: {
          fingerprint,
          status: 'OPEN',
          priority: 'HIGH',
          teamId: testTeam.id,
          escalationPolicyId: testPolicy.id,
          createdAt: new Date(Date.now() - 20 * 60 * 1000) // 20 minutes ago
        }
      });

      const alert = await prisma.alert.create({
        data: {
          title: 'New Window Alert',
          severity: 'HIGH',
          source: testIntegration.name,
          integrationId: testIntegration.id,
          triggeredAt: new Date(),
          metadata: { service: 'test-service' }
        }
      });

      // Dedup window is 15 minutes, so old incident should not match
      const result = await deduplicationService.deduplicateAndCreateIncident(
        alert.id,
        fingerprint,
        alert,
        15
      );

      expect(result.isDuplicate).toBe(false);
      expect(result.incident.id).not.toBe(oldIncident.id);
    });
  });
});

describe('Alert Service', () => {
  let testTeam: any;
  let testIntegration: any;
  let testAlerts: any[] = [];

  beforeAll(async () => {
    testTeam = await prisma.team.create({
      data: { name: `test-alert-search-${Date.now()}` }
    });

    testIntegration = await prisma.integration.create({
      data: {
        name: `alert-search-int-${Date.now()}`,
        type: 'generic',
        webhookSecret: 'test-secret'
      }
    });

    // Create test alerts with varying severity
    for (const severity of ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']) {
      const alert = await prisma.alert.create({
        data: {
          title: `${severity} Alert`,
          severity: severity as any,
          source: testIntegration.name,
          integrationId: testIntegration.id,
          triggeredAt: new Date()
        }
      });
      testAlerts.push(alert);
    }
  });

  afterAll(async () => {
    await prisma.alert.deleteMany({ where: { integrationId: testIntegration.id } });
    await prisma.integration.delete({ where: { id: testIntegration.id } });
    await prisma.team.delete({ where: { id: testTeam.id } });
  });

  describe('search', () => {
    it('should filter by severity', async () => {
      const result = await alertService.search({
        integrationId: testIntegration.id,
        severity: 'CRITICAL'
      });

      expect(result.alerts.every(a => a.severity === 'CRITICAL')).toBe(true);
    });

    it('should filter by multiple severities', async () => {
      const result = await alertService.search({
        integrationId: testIntegration.id,
        severity: ['CRITICAL', 'HIGH']
      });

      expect(result.alerts.every(a => ['CRITICAL', 'HIGH'].includes(a.severity))).toBe(true);
    });

    it('should search by title text', async () => {
      const result = await alertService.search({
        integrationId: testIntegration.id,
        searchTerm: 'CRITICAL'
      });

      expect(result.alerts.some(a => a.title.includes('CRITICAL'))).toBe(true);
    });

    it('should support cursor pagination', async () => {
      const first = await alertService.search(
        { integrationId: testIntegration.id },
        { limit: 2 }
      );

      expect(first.alerts.length).toBe(2);

      if (first.nextCursor) {
        const second = await alertService.search(
          { integrationId: testIntegration.id },
          { limit: 2, cursor: first.nextCursor }
        );

        expect(second.alerts[0].id).not.toBe(first.alerts[0].id);
      }
    });
  });
});
```
  </action>
  <verify>npm test src/tests/alert-routing.test.ts</verify>
  <done>Alert routing tests pass covering deduplication and search</done>
</task>

</tasks>

<verification>
- [ ] `npm test` passes all Phase 4 tests
- [ ] Deduplication tests verify fingerprint matching
- [ ] Escalation tests verify level progression
- [ ] Alert search tests verify filtering and pagination
- [ ] All tests clean up their test data
</verification>

<success_criteria>
Phase 4 test coverage complete:
- Incident lifecycle tests (acknowledge, resolve, reassign)
- Escalation policy CRUD tests
- Escalation flow tests (skip acknowledged, escalate open)
- Deduplication tests (new incident, grouping, window)
- Alert search tests (filters, pagination)
All requirements have integration test coverage
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-routing-and-deduplication/04-08-SUMMARY.md`
</output>

---
phase: 04-alert-routing-and-deduplication
plan: 05
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - src/services/incident.service.ts
  - src/routes/incident.routes.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can acknowledge incident to stop escalation"
    - "User can resolve incident with notes"
    - "User can reassign incident to different responder"
    - "All incident actions are audit logged"
  artifacts:
    - path: "src/services/incident.service.ts"
      provides: "Incident lifecycle management"
      exports: ["incidentService"]
    - path: "src/routes/incident.routes.ts"
      provides: "REST API for incident actions"
      exports: ["incidentRoutes"]
  key_links:
    - from: "src/services/incident.service.ts"
      to: "src/queues/escalation.queue.ts"
      via: "cancelEscalation on acknowledge"
      pattern: "cancelEscalation"
    - from: "src/routes/incident.routes.ts"
      to: "src/services/incident.service.ts"
      via: "service method calls"
      pattern: "incidentService\\."
---

<objective>
Create incident lifecycle management service and API (acknowledge, resolve, reassign)

Purpose: On-call engineers need to manage incidents - acknowledge to stop escalation, resolve when fixed, reassign if needed. These are the core incident response operations.
Output: IncidentService with lifecycle methods, REST API endpoints, escalation job cancellation on acknowledgment
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-alert-routing-and-deduplication/04-RESEARCH.md

# Queue for escalation job management
@src/queues/escalation.queue.ts

# Audit service for logging
@src/services/audit.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create incident service</name>
  <files>src/services/incident.service.ts</files>
  <action>
Create src/services/incident.service.ts with lifecycle methods:

```typescript
import { prisma } from '../config/database.js';
import { cancelEscalation } from '../queues/escalation.queue.js';
import { auditService } from './audit.service.js';
import { logger } from '../config/logger.js';

interface IncidentFilter {
  teamId?: string;
  status?: string | string[];
  assignedUserId?: string;
  priority?: string;
  startDate?: Date;
  endDate?: Date;
}

interface PaginationOptions {
  limit?: number;
  cursor?: string;
}

class IncidentService {
  // Get incident by ID with related data
  async getById(id: string): Promise<any> {
    return prisma.incident.findUnique({
      where: { id },
      include: {
        team: { select: { id: true, name: true } },
        escalationPolicy: { select: { id: true, name: true } },
        assignedUser: { select: { id: true, firstName: true, lastName: true, email: true } },
        alerts: {
          select: {
            id: true,
            title: true,
            severity: true,
            triggeredAt: true,
            externalId: true
          },
          orderBy: { triggeredAt: 'desc' }
        },
        escalationJobs: {
          where: { completed: false },
          select: { id: true, scheduledLevel: true, scheduledFor: true }
        }
      }
    });
  }

  // List incidents with filters and pagination
  async list(filters: IncidentFilter, options: PaginationOptions = {}): Promise<{
    incidents: any[];
    nextCursor: string | null;
  }> {
    const { limit = 50, cursor } = options;

    const where: any = {};

    if (filters.teamId) {
      where.teamId = filters.teamId;
    }

    if (filters.status) {
      where.status = Array.isArray(filters.status)
        ? { in: filters.status }
        : filters.status;
    }

    if (filters.assignedUserId) {
      where.assignedUserId = filters.assignedUserId;
    }

    if (filters.priority) {
      where.priority = filters.priority;
    }

    if (filters.startDate || filters.endDate) {
      where.createdAt = {
        ...(filters.startDate && { gte: filters.startDate }),
        ...(filters.endDate && { lte: filters.endDate })
      };
    }

    const incidents = await prisma.incident.findMany({
      where,
      take: limit,
      ...(cursor && {
        skip: 1,
        cursor: { id: cursor }
      }),
      orderBy: { createdAt: 'desc' },
      include: {
        team: { select: { id: true, name: true } },
        assignedUser: { select: { id: true, firstName: true, lastName: true } },
        _count: { select: { alerts: true } }
      }
    });

    return {
      incidents,
      nextCursor: incidents.length === limit ? incidents[incidents.length - 1].id : null
    };
  }

  // Acknowledge incident - stops escalation
  async acknowledge(
    incidentId: string,
    userId: string,
    metadata?: { note?: string }
  ): Promise<any> {
    const incident = await prisma.incident.findUnique({
      where: { id: incidentId },
      include: { escalationJobs: { where: { completed: false } } }
    });

    if (!incident) {
      throw new Error('Incident not found');
    }

    if (incident.status !== 'OPEN') {
      throw new Error(`Cannot acknowledge incident in ${incident.status} status`);
    }

    // Update incident status
    const updated = await prisma.incident.update({
      where: { id: incidentId },
      data: {
        status: 'ACKNOWLEDGED',
        acknowledgedAt: new Date(),
        assignedUserId: userId // Assign to acknowledger
      }
    });

    // Cancel all pending escalation jobs
    for (const job of incident.escalationJobs) {
      await cancelEscalation(job.bullJobId);
      await prisma.escalationJob.update({
        where: { id: job.id },
        data: { completed: true, cancelledAt: new Date() }
      });
    }

    // Audit log
    await auditService.log({
      action: 'incident.acknowledged',
      userId,
      teamId: incident.teamId,
      resourceType: 'incident',
      resourceId: incidentId,
      severity: 'INFO',
      metadata: {
        previousStatus: incident.status,
        escalationsCancelled: incident.escalationJobs.length,
        ...metadata
      }
    });

    logger.info(
      { incidentId, userId, escalationsCancelled: incident.escalationJobs.length },
      'Incident acknowledged'
    );

    return updated;
  }

  // Resolve incident
  async resolve(
    incidentId: string,
    userId: string,
    metadata: { resolutionNote?: string }
  ): Promise<any> {
    const incident = await prisma.incident.findUnique({
      where: { id: incidentId },
      include: { escalationJobs: { where: { completed: false } } }
    });

    if (!incident) {
      throw new Error('Incident not found');
    }

    if (!['OPEN', 'ACKNOWLEDGED'].includes(incident.status)) {
      throw new Error(`Cannot resolve incident in ${incident.status} status`);
    }

    // Update incident status
    const updated = await prisma.incident.update({
      where: { id: incidentId },
      data: {
        status: 'RESOLVED',
        resolvedAt: new Date()
      }
    });

    // Cancel any remaining escalation jobs
    for (const job of incident.escalationJobs) {
      await cancelEscalation(job.bullJobId);
      await prisma.escalationJob.update({
        where: { id: job.id },
        data: { completed: true, cancelledAt: new Date() }
      });
    }

    // Audit log
    await auditService.log({
      action: 'incident.resolved',
      userId,
      teamId: incident.teamId,
      resourceType: 'incident',
      resourceId: incidentId,
      severity: 'INFO',
      metadata: {
        previousStatus: incident.status,
        resolutionNote: metadata.resolutionNote,
        durationMs: updated.resolvedAt!.getTime() - incident.createdAt.getTime()
      }
    });

    logger.info(
      { incidentId, userId, durationMs: updated.resolvedAt!.getTime() - incident.createdAt.getTime() },
      'Incident resolved'
    );

    return updated;
  }

  // Close incident (final state)
  async close(incidentId: string, userId: string): Promise<any> {
    const incident = await prisma.incident.findUnique({
      where: { id: incidentId }
    });

    if (!incident) {
      throw new Error('Incident not found');
    }

    if (incident.status !== 'RESOLVED') {
      throw new Error('Only resolved incidents can be closed');
    }

    const updated = await prisma.incident.update({
      where: { id: incidentId },
      data: {
        status: 'CLOSED',
        closedAt: new Date()
      }
    });

    await auditService.log({
      action: 'incident.closed',
      userId,
      teamId: incident.teamId,
      resourceType: 'incident',
      resourceId: incidentId,
      severity: 'INFO'
    });

    return updated;
  }

  // Reassign incident to different user (ROUTE-04)
  async reassign(
    incidentId: string,
    newUserId: string,
    byUserId: string,
    reason?: string
  ): Promise<any> {
    const incident = await prisma.incident.findUnique({
      where: { id: incidentId }
    });

    if (!incident) {
      throw new Error('Incident not found');
    }

    if (!['OPEN', 'ACKNOWLEDGED'].includes(incident.status)) {
      throw new Error(`Cannot reassign incident in ${incident.status} status`);
    }

    // Verify new user is active team member
    const membership = await prisma.teamMember.findFirst({
      where: {
        userId: newUserId,
        teamId: incident.teamId,
        role: { in: ['RESPONDER', 'TEAM_ADMIN'] },
        user: { isActive: true }
      }
    });

    if (!membership) {
      throw new Error('New assignee must be an active team responder');
    }

    const previousAssignee = incident.assignedUserId;

    const updated = await prisma.incident.update({
      where: { id: incidentId },
      data: { assignedUserId: newUserId }
    });

    await auditService.log({
      action: 'incident.reassigned',
      userId: byUserId,
      teamId: incident.teamId,
      resourceType: 'incident',
      resourceId: incidentId,
      severity: 'INFO',
      metadata: {
        previousAssignee,
        newAssignee: newUserId,
        reason
      }
    });

    logger.info(
      { incidentId, previousAssignee, newAssignee: newUserId, byUserId },
      'Incident reassigned'
    );

    return updated;
  }

  // Add note to incident timeline (for INC-05 in Phase 6)
  async addNote(
    incidentId: string,
    userId: string,
    note: string
  ): Promise<void> {
    const incident = await prisma.incident.findUnique({
      where: { id: incidentId }
    });

    if (!incident) {
      throw new Error('Incident not found');
    }

    // Store note as audit event (timeline is built from audit events)
    await auditService.log({
      action: 'incident.note.added',
      userId,
      teamId: incident.teamId,
      resourceType: 'incident',
      resourceId: incidentId,
      severity: 'INFO',
      metadata: { note }
    });

    logger.debug({ incidentId, userId }, 'Note added to incident');
  }

  // Get incident timeline (audit events for this incident)
  async getTimeline(incidentId: string): Promise<any[]> {
    return prisma.auditEvent.findMany({
      where: {
        resourceType: 'incident',
        resourceId: incidentId
      },
      orderBy: { timestamp: 'asc' },
      include: {
        user: { select: { id: true, firstName: true, lastName: true } }
      }
    });
  }
}

export const incidentService = new IncidentService();
```
  </action>
  <verify>npm run build</verify>
  <done>Service compiles with all lifecycle methods</done>
</task>

<task type="auto">
  <name>Task 2: Create incident routes</name>
  <files>src/routes/incident.routes.ts, src/index.ts</files>
  <action>
Create src/routes/incident.routes.ts:

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { incidentService } from '../services/incident.service.js';
import { rbacService } from '../services/rbac.service.js';
import { logger } from '../config/logger.js';

const router = Router();

// GET /api/incidents - List incidents with filters
router.get('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const {
      teamId,
      status,
      assignedUserId,
      priority,
      startDate,
      endDate,
      limit,
      cursor
    } = req.query;

    // If teamId specified, check team access
    if (teamId) {
      const permission = await rbacService.checkTeamPermission(
        (req as any).user.id,
        teamId as string,
        'view'
      );

      if (!permission.allowed) {
        return res.status(403).json({ error: permission.reason });
      }
    }

    const result = await incidentService.list(
      {
        teamId: teamId as string,
        status: status as string,
        assignedUserId: assignedUserId as string,
        priority: priority as string,
        startDate: startDate ? new Date(startDate as string) : undefined,
        endDate: endDate ? new Date(endDate as string) : undefined
      },
      {
        limit: limit ? parseInt(limit as string, 10) : undefined,
        cursor: cursor as string
      }
    );

    res.json(result);
  } catch (error) {
    next(error);
  }
});

// GET /api/incidents/my - User's assigned incidents
router.get('/my', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { status, limit, cursor } = req.query;

    const result = await incidentService.list(
      {
        assignedUserId: (req as any).user.id,
        status: status ? (status as string).split(',') : ['OPEN', 'ACKNOWLEDGED']
      },
      {
        limit: limit ? parseInt(limit as string, 10) : undefined,
        cursor: cursor as string
      }
    );

    res.json(result);
  } catch (error) {
    next(error);
  }
});

// GET /api/incidents/:id - Get incident details
router.get('/:id', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const incident = await incidentService.getById(req.params.id);

    if (!incident) {
      return res.status(404).json({ error: 'Incident not found' });
    }

    // Check team access
    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      incident.teamId,
      'view'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    res.json({ incident });
  } catch (error) {
    next(error);
  }
});

// POST /api/incidents/:id/acknowledge - Acknowledge incident (ROUTE-05)
router.post('/:id/acknowledge', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const incident = await incidentService.getById(req.params.id);

    if (!incident) {
      return res.status(404).json({ error: 'Incident not found' });
    }

    // Any team member can acknowledge
    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      incident.teamId,
      'respond'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const { note } = req.body;
    const updated = await incidentService.acknowledge(
      req.params.id,
      (req as any).user.id,
      { note }
    );

    res.json({ incident: updated });
  } catch (error: any) {
    if (error.message.includes('Cannot acknowledge')) {
      return res.status(400).json({ error: error.message });
    }
    next(error);
  }
});

// POST /api/incidents/:id/resolve - Resolve incident
router.post('/:id/resolve', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const incident = await incidentService.getById(req.params.id);

    if (!incident) {
      return res.status(404).json({ error: 'Incident not found' });
    }

    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      incident.teamId,
      'respond'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const { resolutionNote } = req.body;
    const updated = await incidentService.resolve(
      req.params.id,
      (req as any).user.id,
      { resolutionNote }
    );

    res.json({ incident: updated });
  } catch (error: any) {
    if (error.message.includes('Cannot resolve')) {
      return res.status(400).json({ error: error.message });
    }
    next(error);
  }
});

// POST /api/incidents/:id/close - Close incident
router.post('/:id/close', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const incident = await incidentService.getById(req.params.id);

    if (!incident) {
      return res.status(404).json({ error: 'Incident not found' });
    }

    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      incident.teamId,
      'respond'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const updated = await incidentService.close(req.params.id, (req as any).user.id);
    res.json({ incident: updated });
  } catch (error: any) {
    if (error.message.includes('Only resolved')) {
      return res.status(400).json({ error: error.message });
    }
    next(error);
  }
});

// POST /api/incidents/:id/reassign - Reassign incident (ROUTE-04)
router.post('/:id/reassign', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const incident = await incidentService.getById(req.params.id);

    if (!incident) {
      return res.status(404).json({ error: 'Incident not found' });
    }

    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      incident.teamId,
      'respond'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const { userId, reason } = req.body;

    if (!userId) {
      return res.status(400).json({ error: 'userId is required' });
    }

    const updated = await incidentService.reassign(
      req.params.id,
      userId,
      (req as any).user.id,
      reason
    );

    res.json({ incident: updated });
  } catch (error: any) {
    if (error.message.includes('Cannot reassign') || error.message.includes('must be')) {
      return res.status(400).json({ error: error.message });
    }
    next(error);
  }
});

// POST /api/incidents/:id/notes - Add note to incident
router.post('/:id/notes', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const incident = await incidentService.getById(req.params.id);

    if (!incident) {
      return res.status(404).json({ error: 'Incident not found' });
    }

    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      incident.teamId,
      'view'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const { note } = req.body;

    if (!note) {
      return res.status(400).json({ error: 'note is required' });
    }

    await incidentService.addNote(req.params.id, (req as any).user.id, note);
    res.status(201).json({ success: true });
  } catch (error) {
    next(error);
  }
});

// GET /api/incidents/:id/timeline - Get incident timeline
router.get('/:id/timeline', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const incident = await incidentService.getById(req.params.id);

    if (!incident) {
      return res.status(404).json({ error: 'Incident not found' });
    }

    const permission = await rbacService.checkTeamPermission(
      (req as any).user.id,
      incident.teamId,
      'view'
    );

    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const timeline = await incidentService.getTimeline(req.params.id);
    res.json({ timeline });
  } catch (error) {
    next(error);
  }
});

export const incidentRoutes = router;
```

Update src/index.ts to mount routes:

```typescript
// Add import at top
import { incidentRoutes } from './routes/incident.routes.js';

// Add after other authenticated routes
app.use('/api/incidents', incidentRoutes);
```
  </action>
  <verify>npm run build</verify>
  <done>Routes compile, mounted in index.ts</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` succeeds
- [ ] src/services/incident.service.ts exports incidentService
- [ ] src/routes/incident.routes.ts exports incidentRoutes
- [ ] Acknowledge endpoint cancels escalation jobs
- [ ] Routes mounted at /api/incidents in index.ts
</verification>

<success_criteria>
Incident lifecycle management complete:
- Acknowledge stops escalation and assigns to acknowledger
- Resolve marks incident complete with duration tracking
- Reassign allows manual hand-off with audit trail
- Timeline built from audit events
- All actions require team membership
</success_criteria>

<output>
After completion, create `.planning/phases/04-alert-routing-and-deduplication/04-05-SUMMARY.md`
</output>

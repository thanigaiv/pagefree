---
phase: 10-postmortems
plan: 07
type: execute
wave: 5
depends_on: ["10-05"]
files_modified:
  - frontend/src/pages/PostmortemDetailPage.tsx
  - frontend/src/components/PostmortemTimeline.tsx
  - frontend/src/components/ActionItemList.tsx
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can view postmortem with auto-generated timeline"
    - "User can edit postmortem content with MarkdownEditor"
    - "User can add and manage action items"
    - "User can publish postmortem"
  artifacts:
    - path: "frontend/src/pages/PostmortemDetailPage.tsx"
      provides: "Postmortem detail/edit view"
      min_lines: 200
    - path: "frontend/src/components/PostmortemTimeline.tsx"
      provides: "Timeline visualization from audit events"
      min_lines: 50
    - path: "frontend/src/components/ActionItemList.tsx"
      provides: "Action item tracker with status updates"
      min_lines: 100
  key_links:
    - from: "frontend/src/pages/PostmortemDetailPage.tsx"
      to: "frontend/src/hooks/usePostmortems.ts"
      via: "Hook imports"
      pattern: "usePostmortem|useUpdatePostmortem|usePostmortemTimeline"
    - from: "frontend/src/pages/PostmortemDetailPage.tsx"
      to: "frontend/src/components/MarkdownEditor.tsx"
      via: "Component import"
      pattern: "MarkdownEditor"
---

<objective>
Create postmortem detail page with editor, auto-generated timeline, and action item tracker.

Purpose: Enable users to view, edit, and publish postmortems with full timeline and action item management.

Output: PostmortemDetailPage with editor, PostmortemTimeline, and ActionItemList components.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-postmortems/10-RESEARCH.md

Key patterns:
- Detail page from existing patterns
- MarkdownEditor for content editing
- Timeline from audit events
- Action item status updates

@frontend/src/components/MarkdownEditor.tsx - Existing editor
@frontend/src/components/TimelineEvent.tsx - Event card pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostmortemTimeline component</name>
  <files>frontend/src/components/PostmortemTimeline.tsx</files>
  <action>
Create timeline component that displays audit events chronologically:

```typescript
import { formatDistanceToNow, format } from 'date-fns';
import {
  AlertCircle,
  CheckCircle,
  Clock,
  MessageSquare,
  User,
  ArrowUpRight
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { PostmortemTimelineEvent } from '@/types/postmortem';

interface PostmortemTimelineProps {
  events: PostmortemTimelineEvent[];
  isLoading?: boolean;
}

// Map audit actions to icons and colors
const getEventIcon = (action: string) => {
  if (action.includes('created') || action.includes('triggered')) {
    return { icon: AlertCircle, color: 'text-red-500' };
  }
  if (action.includes('acknowledged')) {
    return { icon: Clock, color: 'text-yellow-500' };
  }
  if (action.includes('resolved') || action.includes('closed')) {
    return { icon: CheckCircle, color: 'text-green-500' };
  }
  if (action.includes('note')) {
    return { icon: MessageSquare, color: 'text-blue-500' };
  }
  if (action.includes('escalated')) {
    return { icon: ArrowUpRight, color: 'text-orange-500' };
  }
  return { icon: Clock, color: 'text-gray-500' };
};

const formatAction = (action: string): string => {
  // Convert action like 'incident.created' to 'Incident Created'
  return action
    .split('.')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
};

export function PostmortemTimeline({ events, isLoading }: PostmortemTimelineProps) {
  if (isLoading) {
    return (
      <div className="space-y-4">
        {[1, 2, 3].map(i => (
          <div key={i} className="flex gap-4 animate-pulse">
            <div className="w-8 h-8 rounded-full bg-muted" />
            <div className="flex-1 space-y-2">
              <div className="h-4 w-1/3 bg-muted rounded" />
              <div className="h-3 w-1/4 bg-muted rounded" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (events.length === 0) {
    return (
      <p className="text-muted-foreground text-sm">
        No timeline events available
      </p>
    );
  }

  return (
    <div className="relative">
      {/* Vertical line */}
      <div className="absolute left-4 top-0 bottom-0 w-px bg-border" />

      <div className="space-y-4">
        {events.map((event, index) => {
          const { icon: Icon, color } = getEventIcon(event.action);
          const isNote = event.action.includes('note');

          return (
            <div key={event.id} className="relative flex gap-4 pl-2">
              {/* Icon */}
              <div
                className={cn(
                  'relative z-10 flex h-8 w-8 items-center justify-center rounded-full bg-background border',
                  color
                )}
              >
                <Icon className="h-4 w-4" />
              </div>

              {/* Content */}
              <div className="flex-1 pb-4">
                <div className="flex items-center gap-2">
                  <span className="font-medium text-sm">
                    {formatAction(event.action)}
                  </span>
                  <span className="text-xs text-muted-foreground">
                    {formatDistanceToNow(new Date(event.timestamp), {
                      addSuffix: true
                    })}
                  </span>
                </div>

                {event.user && (
                  <p className="text-xs text-muted-foreground flex items-center gap-1">
                    <User className="h-3 w-3" />
                    {event.user.firstName} {event.user.lastName}
                  </p>
                )}

                {/* Show note content if available */}
                {isNote && event.metadata?.note && (
                  <div className="mt-2 p-3 bg-blue-50 dark:bg-blue-950 rounded-md text-sm">
                    {String(event.metadata.note)}
                  </div>
                )}

                {/* Show incident ID for multi-incident postmortems */}
                <p className="text-xs text-muted-foreground mt-1">
                  Incident: {event.incidentId.slice(-8)}
                </p>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

Key features:
- Icon and color based on action type
- User attribution
- Note content display
- Incident ID for multi-incident context
- Loading state
  </action>
  <verify>Run `npm run build` in frontend/ - should compile without errors</verify>
  <done>PostmortemTimeline component created with event visualization</done>
</task>

<task type="auto">
  <name>Task 2: Create ActionItemList component</name>
  <files>frontend/src/components/ActionItemList.tsx</files>
  <action>
Create action item list with status management:

```typescript
import { useState } from 'react';
import { Plus, Trash2, Calendar, User } from 'lucide-react';
import { formatDistanceToNow, format } from 'date-fns';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter
} from '@/components/ui/dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import { useToast } from '@/hooks/use-toast';

import {
  useCreateActionItem,
  useUpdateActionItem,
  useDeleteActionItem
} from '@/hooks/usePostmortems';
import { useTeams } from '@/hooks/useTeams';
import type {
  ActionItem,
  ActionItemStatus,
  ActionItemPriority,
  CreateActionItemInput
} from '@/types/postmortem';

interface ActionItemListProps {
  postmortemId: string;
  teamId: string;
  actionItems: ActionItem[];
  readOnly?: boolean;
}

const statusColors: Record<ActionItemStatus, string> = {
  OPEN: 'bg-yellow-100 text-yellow-800',
  IN_PROGRESS: 'bg-blue-100 text-blue-800',
  COMPLETED: 'bg-green-100 text-green-800'
};

const priorityColors: Record<ActionItemPriority, string> = {
  HIGH: 'bg-red-100 text-red-800',
  MEDIUM: 'bg-orange-100 text-orange-800',
  LOW: 'bg-gray-100 text-gray-800'
};

export function ActionItemList({
  postmortemId,
  teamId,
  actionItems,
  readOnly = false
}: ActionItemListProps) {
  const [addDialogOpen, setAddDialogOpen] = useState(false);
  const [newItem, setNewItem] = useState<CreateActionItemInput>({
    title: '',
    description: '',
    priority: 'MEDIUM',
    assigneeId: '',
    dueDate: ''
  });

  const { toast } = useToast();
  const { data: teams } = useTeams();
  const team = teams?.find(t => t.id === teamId);

  const createMutation = useCreateActionItem();
  const updateMutation = useUpdateActionItem();
  const deleteMutation = useDeleteActionItem();

  const handleCreate = async () => {
    if (!newItem.title || !newItem.assigneeId) {
      toast({
        title: 'Missing required fields',
        description: 'Title and assignee are required',
        variant: 'destructive'
      });
      return;
    }

    try {
      await createMutation.mutateAsync({
        postmortemId,
        data: newItem
      });
      toast({ title: 'Action item created' });
      setAddDialogOpen(false);
      setNewItem({
        title: '',
        description: '',
        priority: 'MEDIUM',
        assigneeId: '',
        dueDate: ''
      });
    } catch (error) {
      toast({
        title: 'Failed to create action item',
        variant: 'destructive'
      });
    }
  };

  const handleStatusChange = async (item: ActionItem, newStatus: ActionItemStatus) => {
    try {
      await updateMutation.mutateAsync({
        postmortemId,
        itemId: item.id,
        data: { status: newStatus }
      });
      toast({ title: `Action item ${newStatus.toLowerCase().replace('_', ' ')}` });
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Status update failed';
      toast({ title: message, variant: 'destructive' });
    }
  };

  const handleDelete = async (item: ActionItem) => {
    if (!confirm('Delete this action item?')) return;

    try {
      await deleteMutation.mutateAsync({
        postmortemId,
        itemId: item.id
      });
      toast({ title: 'Action item deleted' });
    } catch (error) {
      toast({ title: 'Failed to delete', variant: 'destructive' });
    }
  };

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h3 className="font-semibold">
          Action Items ({actionItems.filter(a => a.status !== 'COMPLETED').length} open)
        </h3>
        {!readOnly && (
          <Dialog open={addDialogOpen} onOpenChange={setAddDialogOpen}>
            <Button size="sm" onClick={() => setAddDialogOpen(true)}>
              <Plus className="h-4 w-4 mr-1" />
              Add Action
            </Button>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Add Action Item</DialogTitle>
              </DialogHeader>
              <div className="space-y-4 py-4">
                <div className="space-y-2">
                  <Label>Title</Label>
                  <Input
                    placeholder="What needs to be done?"
                    value={newItem.title}
                    onChange={e => setNewItem(n => ({ ...n, title: e.target.value }))}
                  />
                </div>
                <div className="space-y-2">
                  <Label>Description (optional)</Label>
                  <Textarea
                    placeholder="Additional details..."
                    value={newItem.description || ''}
                    onChange={e =>
                      setNewItem(n => ({ ...n, description: e.target.value }))
                    }
                  />
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label>Priority</Label>
                    <Select
                      value={newItem.priority}
                      onValueChange={v =>
                        setNewItem(n => ({
                          ...n,
                          priority: v as ActionItemPriority
                        }))
                      }
                    >
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="HIGH">High</SelectItem>
                        <SelectItem value="MEDIUM">Medium</SelectItem>
                        <SelectItem value="LOW">Low</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <Label>Assignee</Label>
                    <Select
                      value={newItem.assigneeId}
                      onValueChange={v =>
                        setNewItem(n => ({ ...n, assigneeId: v }))
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select..." />
                      </SelectTrigger>
                      <SelectContent>
                        {team?.members?.map(member => (
                          <SelectItem key={member.userId} value={member.userId}>
                            {member.user.firstName} {member.user.lastName}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                <div className="space-y-2">
                  <Label>Due Date (optional)</Label>
                  <Input
                    type="date"
                    value={newItem.dueDate?.split('T')[0] || ''}
                    onChange={e =>
                      setNewItem(n => ({
                        ...n,
                        dueDate: e.target.value ? `${e.target.value}T00:00:00Z` : ''
                      }))
                    }
                  />
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setAddDialogOpen(false)}>
                  Cancel
                </Button>
                <Button onClick={handleCreate} disabled={createMutation.isPending}>
                  {createMutation.isPending ? 'Creating...' : 'Create'}
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        )}
      </div>

      {/* List */}
      {actionItems.length === 0 ? (
        <p className="text-muted-foreground text-sm">
          No action items yet. Add action items to track follow-ups.
        </p>
      ) : (
        <div className="space-y-2">
          {actionItems.map(item => (
            <div
              key={item.id}
              className="flex items-start gap-3 p-3 border rounded-lg hover:bg-muted/50"
            >
              {/* Checkbox for quick completion */}
              {!readOnly && (
                <Checkbox
                  checked={item.status === 'COMPLETED'}
                  onCheckedChange={checked => {
                    handleStatusChange(
                      item,
                      checked ? 'COMPLETED' : 'OPEN'
                    );
                  }}
                  className="mt-1"
                />
              )}

              {/* Content */}
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2 flex-wrap">
                  <span
                    className={
                      item.status === 'COMPLETED'
                        ? 'line-through text-muted-foreground'
                        : 'font-medium'
                    }
                  >
                    {item.title}
                  </span>
                  <Badge className={priorityColors[item.priority]} variant="secondary">
                    {item.priority}
                  </Badge>
                  <Badge className={statusColors[item.status]} variant="secondary">
                    {item.status.replace('_', ' ')}
                  </Badge>
                </div>

                {item.description && (
                  <p className="text-sm text-muted-foreground mt-1">
                    {item.description}
                  </p>
                )}

                <div className="flex items-center gap-4 mt-2 text-xs text-muted-foreground">
                  <span className="flex items-center gap-1">
                    <User className="h-3 w-3" />
                    {item.assignee.firstName} {item.assignee.lastName}
                  </span>
                  {item.dueDate && (
                    <span className="flex items-center gap-1">
                      <Calendar className="h-3 w-3" />
                      Due {format(new Date(item.dueDate), 'MMM d, yyyy')}
                    </span>
                  )}
                  {item.completedAt && (
                    <span className="text-green-600">
                      Completed{' '}
                      {formatDistanceToNow(new Date(item.completedAt), {
                        addSuffix: true
                      })}
                    </span>
                  )}
                </div>
              </div>

              {/* Status selector */}
              {!readOnly && item.status !== 'COMPLETED' && (
                <Select
                  value={item.status}
                  onValueChange={v => handleStatusChange(item, v as ActionItemStatus)}
                >
                  <SelectTrigger className="w-32 h-8 text-xs">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="OPEN">Open</SelectItem>
                    <SelectItem value="IN_PROGRESS">In Progress</SelectItem>
                    <SelectItem value="COMPLETED">Completed</SelectItem>
                  </SelectContent>
                </Select>
              )}

              {/* Delete */}
              {!readOnly && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => handleDelete(item)}
                  className="text-destructive hover:text-destructive"
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

Key features:
- Checkbox for quick completion toggle
- Status dropdown for status changes
- Priority and status badges
- Assignee selector from team members
- Due date display
- Delete with confirmation
- Read-only mode for published postmortems
  </action>
  <verify>Run `npm run build` in frontend/ - should compile without errors</verify>
  <done>ActionItemList component created with full CRUD functionality</done>
</task>

<task type="auto">
  <name>Task 3: Create PostmortemDetailPage</name>
  <files>frontend/src/pages/PostmortemDetailPage.tsx</files>
  <action>
Create the detail/edit page:

```typescript
import { useState, useEffect } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import {
  ArrowLeft,
  Save,
  Send,
  Edit,
  Clock,
  Users,
  FileText
} from 'lucide-react';
import { formatDistanceToNow, format } from 'date-fns';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Skeleton } from '@/components/ui/skeleton';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { useToast } from '@/hooks/use-toast';

import { MarkdownEditor } from '@/components/MarkdownEditor';
import { PostmortemTimeline } from '@/components/PostmortemTimeline';
import { ActionItemList } from '@/components/ActionItemList';
import {
  usePostmortem,
  useUpdatePostmortem,
  usePostmortemTimeline
} from '@/hooks/usePostmortems';

export default function PostmortemDetailPage() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { toast } = useToast();

  const { data: postmortem, isLoading } = usePostmortem(id!);
  const { data: timeline, isLoading: timelineLoading } = usePostmortemTimeline(id!);
  const updateMutation = useUpdatePostmortem();

  // Local editing state
  const [isEditing, setIsEditing] = useState(false);
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [publishDialogOpen, setPublishDialogOpen] = useState(false);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  // Initialize local state from postmortem data
  useEffect(() => {
    if (postmortem) {
      setTitle(postmortem.title);
      setContent(postmortem.content);
    }
  }, [postmortem]);

  // Track unsaved changes
  useEffect(() => {
    if (postmortem) {
      const changed = title !== postmortem.title || content !== postmortem.content;
      setHasUnsavedChanges(changed);
    }
  }, [title, content, postmortem]);

  const handleSave = async () => {
    try {
      await updateMutation.mutateAsync({
        id: id!,
        data: { title, content }
      });
      toast({ title: 'Changes saved' });
      setIsEditing(false);
      setHasUnsavedChanges(false);
    } catch (error) {
      toast({ title: 'Failed to save', variant: 'destructive' });
    }
  };

  const handlePublish = async () => {
    try {
      await updateMutation.mutateAsync({
        id: id!,
        data: { status: 'PUBLISHED' }
      });
      toast({ title: 'Postmortem published' });
      setPublishDialogOpen(false);
    } catch (error) {
      toast({ title: 'Failed to publish', variant: 'destructive' });
    }
  };

  if (isLoading) {
    return (
      <div className="container mx-auto py-6 space-y-6">
        <Skeleton className="h-8 w-48" />
        <Skeleton className="h-64 w-full" />
      </div>
    );
  }

  if (!postmortem) {
    return (
      <div className="container mx-auto py-6">
        <p>Postmortem not found</p>
        <Link to="/postmortems">
          <Button variant="link">Back to postmortems</Button>
        </Link>
      </div>
    );
  }

  const isPublished = postmortem.status === 'PUBLISHED';
  const canEdit = !isPublished;

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between gap-4">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="sm" onClick={() => navigate('/postmortems')}>
            <ArrowLeft className="h-4 w-4 mr-1" />
            Back
          </Button>

          {isEditing ? (
            <Input
              value={title}
              onChange={e => setTitle(e.target.value)}
              className="text-xl font-bold h-10 w-96"
            />
          ) : (
            <h1 className="text-2xl font-bold">{postmortem.title}</h1>
          )}

          <Badge
            className={
              isPublished
                ? 'bg-green-100 text-green-800'
                : 'bg-yellow-100 text-yellow-800'
            }
          >
            {postmortem.status}
          </Badge>
        </div>

        <div className="flex items-center gap-2">
          {canEdit && !isEditing && (
            <Button variant="outline" onClick={() => setIsEditing(true)}>
              <Edit className="h-4 w-4 mr-2" />
              Edit
            </Button>
          )}

          {isEditing && (
            <>
              <Button
                variant="outline"
                onClick={() => {
                  setTitle(postmortem.title);
                  setContent(postmortem.content);
                  setIsEditing(false);
                }}
              >
                Cancel
              </Button>
              <Button
                onClick={handleSave}
                disabled={updateMutation.isPending || !hasUnsavedChanges}
              >
                <Save className="h-4 w-4 mr-2" />
                {updateMutation.isPending ? 'Saving...' : 'Save'}
              </Button>
            </>
          )}

          {canEdit && !isEditing && (
            <Button onClick={() => setPublishDialogOpen(true)}>
              <Send className="h-4 w-4 mr-2" />
              Publish
            </Button>
          )}
        </div>
      </div>

      {/* Metadata */}
      <div className="flex items-center gap-6 text-sm text-muted-foreground">
        <span className="flex items-center gap-1">
          <Users className="h-4 w-4" />
          {postmortem.team.name}
        </span>
        <span className="flex items-center gap-1">
          <Clock className="h-4 w-4" />
          Created {formatDistanceToNow(new Date(postmortem.createdAt), { addSuffix: true })}
        </span>
        {postmortem.publishedAt && (
          <span className="flex items-center gap-1">
            <FileText className="h-4 w-4" />
            Published {format(new Date(postmortem.publishedAt), 'MMM d, yyyy')}
          </span>
        )}
        <span>{postmortem.incidentIds.length} linked incident(s)</span>
      </div>

      {/* Main content */}
      <Tabs defaultValue="content" className="space-y-4">
        <TabsList>
          <TabsTrigger value="content">Content</TabsTrigger>
          <TabsTrigger value="timeline">
            Timeline ({timeline?.length || 0})
          </TabsTrigger>
          <TabsTrigger value="actions">
            Action Items ({postmortem.actionItems?.length || 0})
          </TabsTrigger>
        </TabsList>

        <TabsContent value="content">
          <Card>
            <CardContent className="pt-6">
              {isEditing ? (
                <MarkdownEditor
                  value={content}
                  onChange={setContent}
                  placeholder="## Summary\n\nDescribe what happened...\n\n## Root Cause\n\nWhy did this happen?\n\n## Resolution\n\nHow was it fixed?\n\n## Lessons Learned\n\nWhat did we learn?"
                  minRows={15}
                />
              ) : (
                <div className="prose prose-sm max-w-none dark:prose-invert">
                  {postmortem.content ? (
                    <MarkdownEditor
                      value={postmortem.content}
                      onChange={() => {}}
                      disabled
                    />
                  ) : (
                    <p className="text-muted-foreground italic">
                      No content yet. Click Edit to add postmortem content.
                    </p>
                  )}
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="timeline">
          <Card>
            <CardHeader>
              <CardTitle>Incident Timeline</CardTitle>
              <p className="text-sm text-muted-foreground">
                Auto-generated timeline from {postmortem.incidentIds.length} linked
                incident(s)
              </p>
            </CardHeader>
            <CardContent>
              <PostmortemTimeline events={timeline || []} isLoading={timelineLoading} />
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="actions">
          <Card>
            <CardContent className="pt-6">
              <ActionItemList
                postmortemId={postmortem.id}
                teamId={postmortem.teamId}
                actionItems={postmortem.actionItems || []}
                readOnly={isPublished}
              />
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Publish confirmation dialog */}
      <AlertDialog open={publishDialogOpen} onOpenChange={setPublishDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Publish Postmortem?</AlertDialogTitle>
            <AlertDialogDescription>
              Publishing makes this postmortem read-only. You won't be able to edit
              the content or add new action items. Existing action items can still
              be updated.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handlePublish}>
              Publish
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```

Key features:
- Title and content editing with save
- Tabs for Content, Timeline, Action Items
- Publish confirmation dialog
- Read-only mode after publish
- Suggested template in placeholder
- Unsaved changes tracking
  </action>
  <verify>Run `npm run build` in frontend/ - should compile without errors</verify>
  <done>PostmortemDetailPage created with editor, timeline, and action items</done>
</task>

<task type="auto">
  <name>Task 4: Add detail route to App.tsx</name>
  <files>frontend/src/App.tsx</files>
  <action>
Add the postmortem detail route:

1. Import the page:
   ```typescript
   import PostmortemDetailPage from './pages/PostmortemDetailPage';
   ```

2. Add route with ID param:
   ```tsx
   <Route path="/postmortems/:id" element={<PostmortemDetailPage />} />
   ```

Place after the /postmortems route.
  </action>
  <verify>Navigate to /postmortems/:id in browser - detail page renders</verify>
  <done>Detail route added and accessible</done>
</task>

</tasks>

<verification>
1. `npm run build` in frontend/ compiles without errors
2. /postmortems/:id shows postmortem with content, timeline, action items
3. Editing mode allows changing title and content
4. Save persists changes
5. Timeline tab shows auto-generated audit events
6. Action items can be created, updated, deleted
7. Publish makes postmortem read-only
</verification>

<success_criteria>
- User can view postmortem with all three tabs (Content, Timeline, Actions)
- User can edit content with MarkdownEditor in draft mode
- Timeline displays chronological audit events from linked incidents
- Action items can be added with assignee and due date
- Action item status can be updated via dropdown or checkbox
- Publishing disables editing
</success_criteria>

<output>
After completion, create `.planning/phases/10-postmortems/10-07-SUMMARY.md`
</output>

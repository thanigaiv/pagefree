---
phase: 10-postmortems
plan: 05
type: execute
wave: 4
depends_on: ["10-04"]
files_modified:
  - frontend/src/hooks/usePostmortems.ts
  - frontend/src/types/postmortem.ts
autonomous: true

must_haves:
  truths:
    - "Frontend hooks exist for postmortem CRUD"
    - "Frontend hooks exist for action item mutations"
    - "Timeline hook fetches audit events for postmortem"
    - "TypeScript types match backend API"
  artifacts:
    - path: "frontend/src/hooks/usePostmortems.ts"
      provides: "React Query hooks for postmortem operations"
      exports: ["usePostmortems", "usePostmortem", "useCreatePostmortem", "useUpdatePostmortem", "useDeletePostmortem", "usePostmortemTimeline", "useCreateActionItem", "useUpdateActionItem", "useDeleteActionItem", "useMyActionItems"]
      min_lines: 100
    - path: "frontend/src/types/postmortem.ts"
      provides: "Frontend TypeScript interfaces"
      exports: ["Postmortem", "ActionItem", "PostmortemTimelineEvent"]
  key_links:
    - from: "frontend/src/hooks/usePostmortems.ts"
      to: "/postmortems API"
      via: "apiFetch calls"
      pattern: "apiFetch.*postmortems"
---

<objective>
Create frontend React Query hooks and TypeScript types for postmortem functionality.

Purpose: Provide type-safe data fetching and mutations for postmortem UI components.

Output: usePostmortems hooks and frontend types matching backend API.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-postmortems/10-RESEARCH.md

Key patterns:
- Hook pattern from frontend/src/hooks/useStatusPages.ts
- apiFetch<T>() pattern for API calls
- QueryClient invalidation on mutations
- Types in frontend/src/types/ directory

@frontend/src/hooks/useStatusPages.ts - Hook pattern reference
@frontend/src/lib/api.ts - apiFetch pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create frontend TypeScript types</name>
  <files>frontend/src/types/postmortem.ts</files>
  <action>
Create new types file matching backend API:

```typescript
// Enums
export type PostmortemStatus = 'DRAFT' | 'PUBLISHED';
export type ActionItemStatus = 'OPEN' | 'IN_PROGRESS' | 'COMPLETED';
export type ActionItemPriority = 'HIGH' | 'MEDIUM' | 'LOW';

// Postmortem
export interface Postmortem {
  id: string;
  title: string;
  content: string;
  incidentIds: string[];
  status: PostmortemStatus;
  teamId: string;
  team: { id: string; name: string };
  createdById: string;
  createdBy: { id: string; firstName: string; lastName: string };
  publishedAt: string | null;
  createdAt: string;
  updatedAt: string;
  actionItems?: ActionItem[];
}

// Action Item
export interface ActionItem {
  id: string;
  postmortemId: string;
  title: string;
  description: string | null;
  status: ActionItemStatus;
  priority: ActionItemPriority;
  assigneeId: string;
  assignee: { id: string; firstName: string; lastName: string };
  dueDate: string | null;
  completedAt: string | null;
  createdAt: string;
  updatedAt: string;
  // Extended with postmortem info for /me/action-items
  postmortem?: { id: string; title: string; teamId: string };
}

// Timeline event from audit service
export interface PostmortemTimelineEvent {
  id: string;
  action: string;
  timestamp: string;
  userId: string | null;
  user: { id: string; firstName: string; lastName: string } | null;
  metadata: Record<string, unknown>;
  incidentId: string;
}

// Input types for mutations
export interface CreatePostmortemInput {
  title: string;
  content?: string;
  incidentIds: string[];
  teamId: string;
}

export interface UpdatePostmortemInput {
  title?: string;
  content?: string;
  incidentIds?: string[];
  status?: PostmortemStatus;
}

export interface CreateActionItemInput {
  title: string;
  description?: string;
  priority?: ActionItemPriority;
  assigneeId: string;
  dueDate?: string;
}

export interface UpdateActionItemInput {
  title?: string;
  description?: string | null;
  status?: ActionItemStatus;
  priority?: ActionItemPriority;
  assigneeId?: string;
  dueDate?: string | null;
}
```

Follow existing frontend type patterns.
  </action>
  <verify>Run `npm run build` in frontend/ - should compile without errors</verify>
  <done>Frontend TypeScript types created matching backend API</done>
</task>

<task type="auto">
  <name>Task 2: Create React Query hooks</name>
  <files>frontend/src/hooks/usePostmortems.ts</files>
  <action>
Create new hooks file following useStatusPages.ts pattern:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiFetch } from '@/lib/api';
import type {
  Postmortem,
  ActionItem,
  PostmortemTimelineEvent,
  CreatePostmortemInput,
  UpdatePostmortemInput,
  CreateActionItemInput,
  UpdateActionItemInput,
  ActionItemStatus
} from '@/types/postmortem';

// ============================================================================
// POSTMORTEM HOOKS
// ============================================================================

export function usePostmortems(teamId?: string) {
  return useQuery({
    queryKey: ['postmortems', teamId],
    queryFn: async () => {
      const params = teamId ? `?teamId=${teamId}` : '';
      return apiFetch<Postmortem[]>(`/postmortems${params}`);
    }
  });
}

export function usePostmortem(id: string) {
  return useQuery({
    queryKey: ['postmortem', id],
    queryFn: () => apiFetch<Postmortem>(`/postmortems/${id}`),
    enabled: !!id
  });
}

export function usePostmortemTimeline(id: string, enabled = true) {
  return useQuery({
    queryKey: ['postmortem-timeline', id],
    queryFn: () => apiFetch<PostmortemTimelineEvent[]>(`/postmortems/${id}/timeline`),
    enabled: !!id && enabled,
    staleTime: 5 * 60 * 1000 // 5 min - timeline doesn't change often
  });
}

export function useCreatePostmortem() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreatePostmortemInput) =>
      apiFetch<Postmortem>('/postmortems', {
        method: 'POST',
        body: JSON.stringify(data)
      }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['postmortems'] });
    }
  });
}

export function useUpdatePostmortem() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdatePostmortemInput }) =>
      apiFetch<Postmortem>(`/postmortems/${id}`, {
        method: 'PUT',
        body: JSON.stringify(data)
      }),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['postmortem', id] });
      queryClient.invalidateQueries({ queryKey: ['postmortems'] });
    }
  });
}

export function useDeletePostmortem() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (id: string) =>
      apiFetch(`/postmortems/${id}`, { method: 'DELETE' }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['postmortems'] });
    }
  });
}

// ============================================================================
// ACTION ITEM HOOKS
// ============================================================================

export function useCreateActionItem() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({
      postmortemId,
      data
    }: {
      postmortemId: string;
      data: CreateActionItemInput;
    }) =>
      apiFetch<ActionItem>(`/postmortems/${postmortemId}/action-items`, {
        method: 'POST',
        body: JSON.stringify(data)
      }),
    onSuccess: (_, { postmortemId }) => {
      queryClient.invalidateQueries({ queryKey: ['postmortem', postmortemId] });
      queryClient.invalidateQueries({ queryKey: ['my-action-items'] });
    }
  });
}

export function useUpdateActionItem() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({
      postmortemId,
      itemId,
      data
    }: {
      postmortemId: string;
      itemId: string;
      data: UpdateActionItemInput;
    }) =>
      apiFetch<ActionItem>(`/postmortems/${postmortemId}/action-items/${itemId}`, {
        method: 'PUT',
        body: JSON.stringify(data)
      }),
    onSuccess: (_, { postmortemId }) => {
      queryClient.invalidateQueries({ queryKey: ['postmortem', postmortemId] });
      queryClient.invalidateQueries({ queryKey: ['my-action-items'] });
    }
  });
}

export function useDeleteActionItem() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({
      postmortemId,
      itemId
    }: {
      postmortemId: string;
      itemId: string;
    }) =>
      apiFetch(`/postmortems/${postmortemId}/action-items/${itemId}`, {
        method: 'DELETE'
      }),
    onSuccess: (_, { postmortemId }) => {
      queryClient.invalidateQueries({ queryKey: ['postmortem', postmortemId] });
      queryClient.invalidateQueries({ queryKey: ['my-action-items'] });
    }
  });
}

// ============================================================================
// USER'S ACTION ITEMS (for dashboard)
// ============================================================================

export function useMyActionItems(status?: ActionItemStatus) {
  return useQuery({
    queryKey: ['my-action-items', status],
    queryFn: async () => {
      const params = status ? `?status=${status}` : '';
      return apiFetch<ActionItem[]>(`/postmortems/me/action-items${params}`);
    }
  });
}
```

Key implementation details:
- Follow useStatusPages pattern exactly
- Query invalidation on mutations for data consistency
- useMyActionItems for user's dashboard view
- Timeline query with 5-min staleTime (rarely changes)
- Type-safe apiFetch<T> generics
  </action>
  <verify>Run `npm run build` in frontend/ - should compile without errors</verify>
  <done>React Query hooks created for all postmortem and action item operations</done>
</task>

</tasks>

<verification>
1. `npm run build` in frontend/ compiles without errors
2. All hooks exported from usePostmortems.ts
3. Types match backend API responses
4. Query keys are consistent and enable proper invalidation
</verification>

<success_criteria>
- usePostmortems() returns list of postmortems with optional team filter
- usePostmortem(id) returns single postmortem with action items
- usePostmortemTimeline(id) returns chronological timeline events
- All mutation hooks invalidate relevant queries on success
- useMyActionItems() returns current user's assigned action items
</success_criteria>

<output>
After completion, create `.planning/phases/10-postmortems/10-05-SUMMARY.md`
</output>

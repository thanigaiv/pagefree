---
phase: 10-postmortems
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/services/actionItem.service.ts
autonomous: true

must_haves:
  truths:
    - "Action item CRUD operations work (create, read, update, delete)"
    - "Status transitions follow state machine (OPEN->IN_PROGRESS->COMPLETED)"
    - "Invalid status transitions are rejected"
    - "Completed items have completedAt timestamp set"
  artifacts:
    - path: "src/services/actionItem.service.ts"
      provides: "Action item CRUD with state machine"
      exports: ["actionItemService"]
      min_lines: 100
  key_links:
    - from: "src/services/actionItem.service.ts"
      to: "prisma.actionItem"
      via: "Prisma client queries"
      pattern: "prisma\\.actionItem\\.(create|findMany|findUnique|update|delete)"
    - from: "src/services/actionItem.service.ts"
      to: "src/types/postmortem.ts"
      via: "State transition validation"
      pattern: "ACTION_ITEM_TRANSITIONS"
---

<objective>
Create action item service with state machine for tracking postmortem follow-ups.

Purpose: Enable tracking of action items with clear status progression and completion tracking.

Output: ActionItemService with CRUD and state machine validation.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-postmortems/10-RESEARCH.md

Key patterns:
- State machine validation before status update
- Audit logging for all state changes
- Service singleton pattern
- Required assigneeId (every action item needs owner per pitfall #2)

@src/types/postmortem.ts - ACTION_ITEM_TRANSITIONS constant
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create action item service with state machine</name>
  <files>src/services/actionItem.service.ts</files>
  <action>
Create new service file for action item management:

```typescript
import { prisma } from '../lib/prisma.js';
import { auditService } from './audit.service.js';
import { logger } from '../lib/logger.js';
import {
  ACTION_ITEM_TRANSITIONS,
  type ActionItem,
  type ActionItemStatus,
  type CreateActionItemInput,
  type UpdateActionItemInput
} from '../types/postmortem.js';

class ActionItemService {
  /**
   * Create a new action item on a postmortem
   */
  async create(
    postmortemId: string,
    data: CreateActionItemInput,
    userId: string
  ): Promise<ActionItem> {
    // Verify postmortem exists
    const postmortem = await prisma.postmortem.findUnique({
      where: { id: postmortemId },
      select: { id: true, teamId: true }
    });

    if (!postmortem) {
      throw new Error('Postmortem not found');
    }

    const actionItem = await prisma.actionItem.create({
      data: {
        postmortemId,
        title: data.title,
        description: data.description,
        priority: data.priority || 'MEDIUM',
        assigneeId: data.assigneeId,
        dueDate: data.dueDate ? new Date(data.dueDate) : null,
        status: 'OPEN'
      },
      include: {
        assignee: { select: { id: true, firstName: true, lastName: true } }
      }
    });

    await auditService.log({
      action: 'postmortem.action_item.created',
      userId,
      teamId: postmortem.teamId,
      resourceType: 'action_item',
      resourceId: actionItem.id,
      severity: 'INFO',
      metadata: {
        postmortemId,
        title: data.title,
        assigneeId: data.assigneeId
      }
    });

    logger.info(
      { actionItemId: actionItem.id, postmortemId, userId },
      'Action item created'
    );
    return actionItem as ActionItem;
  }

  /**
   * Get action item by ID
   */
  async getById(id: string): Promise<ActionItem | null> {
    const actionItem = await prisma.actionItem.findUnique({
      where: { id },
      include: {
        assignee: { select: { id: true, firstName: true, lastName: true } }
      }
    });
    return actionItem as ActionItem | null;
  }

  /**
   * List action items for a postmortem
   */
  async listByPostmortem(postmortemId: string): Promise<ActionItem[]> {
    const actionItems = await prisma.actionItem.findMany({
      where: { postmortemId },
      include: {
        assignee: { select: { id: true, firstName: true, lastName: true } }
      },
      orderBy: [
        { status: 'asc' }, // OPEN first, then IN_PROGRESS, then COMPLETED
        { priority: 'desc' }, // HIGH, MEDIUM, LOW
        { createdAt: 'asc' }
      ]
    });
    return actionItems as ActionItem[];
  }

  /**
   * List action items assigned to a user (for dashboard)
   */
  async listByAssignee(
    assigneeId: string,
    status?: ActionItemStatus
  ): Promise<ActionItem[]> {
    const actionItems = await prisma.actionItem.findMany({
      where: {
        assigneeId,
        ...(status ? { status } : {})
      },
      include: {
        assignee: { select: { id: true, firstName: true, lastName: true } },
        postmortem: { select: { id: true, title: true, teamId: true } }
      },
      orderBy: [
        { status: 'asc' },
        { dueDate: 'asc' }, // Earliest due date first
        { priority: 'desc' }
      ]
    });
    return actionItems as ActionItem[];
  }

  /**
   * Update action item with state machine validation
   */
  async update(
    id: string,
    data: UpdateActionItemInput,
    userId: string
  ): Promise<ActionItem> {
    const existing = await prisma.actionItem.findUnique({
      where: { id },
      include: {
        postmortem: { select: { teamId: true } }
      }
    });

    if (!existing) {
      throw new Error('Action item not found');
    }

    // Validate status transition if status is being changed
    if (data.status && data.status !== existing.status) {
      const validTransitions = ACTION_ITEM_TRANSITIONS[existing.status as ActionItemStatus];
      if (!validTransitions.includes(data.status)) {
        throw new Error(
          `Invalid status transition: cannot change from ${existing.status} to ${data.status}`
        );
      }
    }

    // Build update data
    const updateData: any = { ...data };

    // Handle dueDate conversion
    if (data.dueDate !== undefined) {
      updateData.dueDate = data.dueDate ? new Date(data.dueDate) : null;
    }

    // Set completedAt when transitioning to COMPLETED
    if (data.status === 'COMPLETED' && existing.status !== 'COMPLETED') {
      updateData.completedAt = new Date();
    }
    // Clear completedAt when reopening
    if (data.status && data.status !== 'COMPLETED' && existing.status === 'COMPLETED') {
      updateData.completedAt = null;
    }

    const actionItem = await prisma.actionItem.update({
      where: { id },
      data: updateData,
      include: {
        assignee: { select: { id: true, firstName: true, lastName: true } }
      }
    });

    await auditService.log({
      action: 'postmortem.action_item.updated',
      userId,
      teamId: existing.postmortem.teamId,
      resourceType: 'action_item',
      resourceId: id,
      severity: 'INFO',
      metadata: {
        postmortemId: existing.postmortemId,
        changes: Object.keys(data),
        previousStatus: existing.status,
        newStatus: data.status
      }
    });

    logger.info({ actionItemId: id, userId, changes: Object.keys(data) }, 'Action item updated');
    return actionItem as ActionItem;
  }

  /**
   * Update just the status (convenience method)
   */
  async updateStatus(
    id: string,
    status: ActionItemStatus,
    userId: string
  ): Promise<ActionItem> {
    return this.update(id, { status }, userId);
  }

  /**
   * Delete action item
   */
  async delete(id: string, userId: string): Promise<void> {
    const actionItem = await prisma.actionItem.findUnique({
      where: { id },
      include: {
        postmortem: { select: { teamId: true } }
      }
    });

    if (!actionItem) {
      throw new Error('Action item not found');
    }

    await prisma.actionItem.delete({ where: { id } });

    await auditService.log({
      action: 'postmortem.action_item.deleted',
      userId,
      teamId: actionItem.postmortem.teamId,
      resourceType: 'action_item',
      resourceId: id,
      severity: 'WARN',
      metadata: {
        postmortemId: actionItem.postmortemId,
        title: actionItem.title
      }
    });

    logger.info({ actionItemId: id, userId }, 'Action item deleted');
  }
}

export const actionItemService = new ActionItemService();
```

Key implementation details:
- State machine validation using ACTION_ITEM_TRANSITIONS from types
- completedAt timestamp set/cleared on status transitions
- listByAssignee for user dashboard view (future: visible action items for user)
- Audit logging for all mutations with postmortem context
- Required assigneeId enforced at database level
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>ActionItemService created with CRUD, state machine validation, and completedAt handling</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. Service exports actionItemService singleton
3. State machine validation rejects invalid transitions:
   - OPEN -> COMPLETED: valid
   - COMPLETED -> IN_PROGRESS: invalid (must go through OPEN)
4. completedAt set when status changes to COMPLETED
5. completedAt cleared when reopening (COMPLETED -> OPEN)
</verification>

<success_criteria>
- create() creates action item with required assignee
- update() validates status transitions using ACTION_ITEM_TRANSITIONS
- update() sets completedAt on completion, clears on reopen
- Invalid transitions throw clear error message
- listByAssignee() returns user's assigned action items for dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/10-postmortems/10-03-SUMMARY.md`
</output>

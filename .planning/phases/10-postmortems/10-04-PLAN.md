---
phase: 10-postmortems
plan: 04
type: execute
wave: 3
depends_on: ["10-02", "10-03"]
files_modified:
  - src/routes/postmortem.routes.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "REST API endpoints exist for postmortem CRUD"
    - "REST API endpoints exist for action item CRUD"
    - "Timeline endpoint returns chronological audit events"
    - "Permission checks enforce team role requirements"
  artifacts:
    - path: "src/routes/postmortem.routes.ts"
      provides: "REST API endpoints for postmortems and action items"
      exports: ["postmortemRouter"]
      min_lines: 150
  key_links:
    - from: "src/routes/postmortem.routes.ts"
      to: "src/services/postmortem.service.ts"
      via: "Service method calls"
      pattern: "postmortemService\\.(create|getById|list|update|delete|getTimeline)"
    - from: "src/routes/postmortem.routes.ts"
      to: "src/services/actionItem.service.ts"
      via: "Service method calls"
      pattern: "actionItemService\\.(create|update|delete)"
    - from: "src/index.ts"
      to: "src/routes/postmortem.routes.ts"
      via: "Router mounting"
      pattern: "app\\.use.*postmortemRouter"
---

<objective>
Create REST API endpoints for postmortem and action item management.

Purpose: Expose postmortem functionality via RESTful API for frontend consumption.

Output: Express router with all CRUD endpoints and proper authentication/authorization.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-postmortems/10-RESEARCH.md

Key patterns:
- Router pattern from src/routes/statusPage.routes.ts
- Permission checks via permissionService
- Full visibility model: any authenticated user can view
- Responder+ required to edit team resources
- req.user.id for authenticated user ID

@src/routes/statusPage.routes.ts - Route pattern reference
@src/services/permission.service.ts - Permission check pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create postmortem routes</name>
  <files>src/routes/postmortem.routes.ts</files>
  <action>
Create new router file following existing patterns:

```typescript
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { postmortemService } from '../services/postmortem.service.js';
import { actionItemService } from '../services/actionItem.service.js';
import { permissionService } from '../services/permission.service.js';
import { logger } from '../lib/logger.js';

const router = Router();

// Validation schemas
const createPostmortemSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string().optional(),
  incidentIds: z.array(z.string()).min(1, 'At least one incident required'),
  teamId: z.string().min(1)
});

const updatePostmortemSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  content: z.string().optional(),
  incidentIds: z.array(z.string()).optional(),
  status: z.enum(['DRAFT', 'PUBLISHED']).optional()
});

const createActionItemSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().optional(),
  priority: z.enum(['HIGH', 'MEDIUM', 'LOW']).optional(),
  assigneeId: z.string().min(1),
  dueDate: z.string().datetime().optional()
});

const updateActionItemSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  description: z.string().nullable().optional(),
  status: z.enum(['OPEN', 'IN_PROGRESS', 'COMPLETED']).optional(),
  priority: z.enum(['HIGH', 'MEDIUM', 'LOW']).optional(),
  assigneeId: z.string().optional(),
  dueDate: z.string().datetime().nullable().optional()
});

// ============================================================================
// POSTMORTEM ROUTES
// ============================================================================

// List postmortems (any authenticated user - full visibility)
router.get('/', async (req: Request, res: Response) => {
  try {
    const teamId = req.query.teamId as string | undefined;
    const postmortems = await postmortemService.list(teamId ? { teamId } : undefined);
    res.json(postmortems);
  } catch (error) {
    logger.error(error, 'Failed to list postmortems');
    res.status(500).json({ error: 'Failed to list postmortems' });
  }
});

// Get postmortem by ID (any authenticated user - full visibility)
router.get('/:id', async (req: Request, res: Response) => {
  try {
    const postmortem = await postmortemService.getById(req.params.id);
    if (!postmortem) {
      return res.status(404).json({ error: 'Postmortem not found' });
    }
    res.json(postmortem);
  } catch (error) {
    logger.error(error, 'Failed to get postmortem');
    res.status(500).json({ error: 'Failed to get postmortem' });
  }
});

// Get timeline for postmortem's linked incidents
router.get('/:id/timeline', async (req: Request, res: Response) => {
  try {
    const postmortem = await postmortemService.getById(req.params.id);
    if (!postmortem) {
      return res.status(404).json({ error: 'Postmortem not found' });
    }
    const timeline = await postmortemService.getTimeline(postmortem.incidentIds);
    res.json(timeline);
  } catch (error) {
    logger.error(error, 'Failed to get postmortem timeline');
    res.status(500).json({ error: 'Failed to get timeline' });
  }
});

// Create postmortem (Responder+ on team)
router.post('/', async (req: Request, res: Response) => {
  try {
    const data = createPostmortemSchema.parse(req.body);

    // Check team permission
    const permission = await permissionService.hasMinimumTeamRole(
      req.user!,
      data.teamId,
      'RESPONDER'
    );
    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const postmortem = await postmortemService.create(data, req.user!.id);
    res.status(201).json(postmortem);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation failed', details: error.errors });
    }
    logger.error(error, 'Failed to create postmortem');
    res.status(500).json({ error: 'Failed to create postmortem' });
  }
});

// Update postmortem (Responder+ on team)
router.put('/:id', async (req: Request, res: Response) => {
  try {
    const data = updatePostmortemSchema.parse(req.body);

    // Get existing postmortem for team check
    const existing = await postmortemService.getById(req.params.id);
    if (!existing) {
      return res.status(404).json({ error: 'Postmortem not found' });
    }

    // Check team permission
    const permission = await permissionService.hasMinimumTeamRole(
      req.user!,
      existing.teamId,
      'RESPONDER'
    );
    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const postmortem = await postmortemService.update(req.params.id, data, req.user!.id);
    res.json(postmortem);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation failed', details: error.errors });
    }
    logger.error(error, 'Failed to update postmortem');
    res.status(500).json({ error: 'Failed to update postmortem' });
  }
});

// Delete postmortem (Team Admin only)
router.delete('/:id', async (req: Request, res: Response) => {
  try {
    const existing = await postmortemService.getById(req.params.id);
    if (!existing) {
      return res.status(404).json({ error: 'Postmortem not found' });
    }

    // Require Team Admin for delete
    const permission = await permissionService.hasMinimumTeamRole(
      req.user!,
      existing.teamId,
      'TEAM_ADMIN'
    );
    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    await postmortemService.delete(req.params.id, req.user!.id);
    res.status(204).send();
  } catch (error) {
    logger.error(error, 'Failed to delete postmortem');
    res.status(500).json({ error: 'Failed to delete postmortem' });
  }
});

// ============================================================================
// ACTION ITEM ROUTES (nested under postmortem)
// ============================================================================

// Create action item (Responder+ on postmortem's team)
router.post('/:id/action-items', async (req: Request, res: Response) => {
  try {
    const data = createActionItemSchema.parse(req.body);

    const postmortem = await postmortemService.getById(req.params.id);
    if (!postmortem) {
      return res.status(404).json({ error: 'Postmortem not found' });
    }

    const permission = await permissionService.hasMinimumTeamRole(
      req.user!,
      postmortem.teamId,
      'RESPONDER'
    );
    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    const actionItem = await actionItemService.create(req.params.id, data, req.user!.id);
    res.status(201).json(actionItem);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation failed', details: error.errors });
    }
    logger.error(error, 'Failed to create action item');
    res.status(500).json({ error: 'Failed to create action item' });
  }
});

// Update action item (Responder+ or assignee)
router.put('/:postmortemId/action-items/:itemId', async (req: Request, res: Response) => {
  try {
    const data = updateActionItemSchema.parse(req.body);

    const actionItem = await actionItemService.getById(req.params.itemId);
    if (!actionItem) {
      return res.status(404).json({ error: 'Action item not found' });
    }

    const postmortem = await postmortemService.getById(actionItem.postmortemId);
    if (!postmortem) {
      return res.status(404).json({ error: 'Postmortem not found' });
    }

    // Allow if team responder+ OR if user is the assignee
    const isAssignee = actionItem.assigneeId === req.user!.id;
    const permission = await permissionService.hasMinimumTeamRole(
      req.user!,
      postmortem.teamId,
      'RESPONDER'
    );

    if (!permission.allowed && !isAssignee) {
      return res.status(403).json({
        error: 'Only team responders or the assignee can update action items'
      });
    }

    const updated = await actionItemService.update(req.params.itemId, data, req.user!.id);
    res.json(updated);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Validation failed', details: error.errors });
    }
    if (error instanceof Error && error.message.includes('Invalid status transition')) {
      return res.status(400).json({ error: error.message });
    }
    logger.error(error, 'Failed to update action item');
    res.status(500).json({ error: 'Failed to update action item' });
  }
});

// Delete action item (Responder+ on team)
router.delete('/:postmortemId/action-items/:itemId', async (req: Request, res: Response) => {
  try {
    const actionItem = await actionItemService.getById(req.params.itemId);
    if (!actionItem) {
      return res.status(404).json({ error: 'Action item not found' });
    }

    const postmortem = await postmortemService.getById(actionItem.postmortemId);
    if (!postmortem) {
      return res.status(404).json({ error: 'Postmortem not found' });
    }

    const permission = await permissionService.hasMinimumTeamRole(
      req.user!,
      postmortem.teamId,
      'RESPONDER'
    );
    if (!permission.allowed) {
      return res.status(403).json({ error: permission.reason });
    }

    await actionItemService.delete(req.params.itemId, req.user!.id);
    res.status(204).send();
  } catch (error) {
    logger.error(error, 'Failed to delete action item');
    res.status(500).json({ error: 'Failed to delete action item' });
  }
});

// ============================================================================
// USER'S ACTION ITEMS (for dashboard)
// ============================================================================

// Get current user's assigned action items
router.get('/me/action-items', async (req: Request, res: Response) => {
  try {
    const status = req.query.status as string | undefined;
    const actionItems = await actionItemService.listByAssignee(
      req.user!.id,
      status as any
    );
    res.json(actionItems);
  } catch (error) {
    logger.error(error, 'Failed to list user action items');
    res.status(500).json({ error: 'Failed to list action items' });
  }
});

export const postmortemRouter = router;
```

Key implementation details:
- Zod validation for all inputs
- Permission checks: full visibility for reads, Responder+ for writes
- Team Admin required for postmortem deletion (elevated operation)
- Action item updates allowed by team responder+ OR assignee
- Invalid status transitions return 400 (not 500)
- /me/action-items endpoint for user's dashboard
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>Postmortem routes created with CRUD, timeline, action items, and permission checks</done>
</task>

<task type="auto">
  <name>Task 2: Mount router in main app</name>
  <files>src/index.ts</files>
  <action>
Add the postmortem router to the Express app:

1. Import the router:
   ```typescript
   import { postmortemRouter } from './routes/postmortem.routes.js';
   ```

2. Mount after auth middleware (with other protected routes):
   ```typescript
   app.use('/postmortems', postmortemRouter);
   ```

Place the mount near other protected routes like `/status-pages`.

Note: The `/me/action-items` route must be mounted before `/:id` to avoid matching issues.
Actually, looking at the router - reorder the routes so `/me/action-items` comes before `/:id`:

Move `router.get('/me/action-items', ...)` to be BEFORE `router.get('/:id', ...)` in the router file.
  </action>
  <verify>Server starts without errors, `curl http://localhost:3000/postmortems` returns 401 (auth required)</verify>
  <done>Router mounted and accessible at /postmortems</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. Server starts without errors
3. All endpoints require authentication (return 401 if not logged in)
4. POST /postmortems creates postmortem with valid data
5. GET /postmortems/:id/timeline returns audit events
6. PUT /postmortems/:id/action-items/:itemId returns 400 for invalid status transition
</verification>

<success_criteria>
- All CRUD endpoints work for postmortems and action items
- Timeline endpoint returns chronological audit events
- Permission checks enforce team role requirements
- Invalid status transitions return 400 with clear message
- Zod validation returns 400 with field details on invalid input
</success_criteria>

<output>
After completion, create `.planning/phases/10-postmortems/10-04-SUMMARY.md`
</output>

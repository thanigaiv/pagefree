---
phase: 10-postmortems
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/services/postmortem.service.ts
autonomous: true

must_haves:
  truths:
    - "Postmortem CRUD operations work (create, read, update, delete)"
    - "Timeline generation queries audit events for linked incidents"
    - "Only team members with RESPONDER+ can edit postmortems"
    - "Any authenticated user can view postmortems (full visibility)"
  artifacts:
    - path: "src/services/postmortem.service.ts"
      provides: "Postmortem CRUD and timeline generation"
      exports: ["postmortemService"]
      min_lines: 150
  key_links:
    - from: "src/services/postmortem.service.ts"
      to: "prisma.postmortem"
      via: "Prisma client queries"
      pattern: "prisma\\.postmortem\\.(create|findMany|findUnique|update|delete)"
    - from: "src/services/postmortem.service.ts"
      to: "prisma.auditEvent"
      via: "Timeline generation query"
      pattern: "prisma\\.auditEvent\\.findMany"
---

<objective>
Create postmortem service with CRUD operations and timeline generation from audit events.

Purpose: Enable postmortem document management with automatic incident timeline aggregation.

Output: PostmortemService with create, read, update, delete, and getTimeline methods.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-postmortems/10-RESEARCH.md

Key patterns from codebase:
- Timeline from audit events (src/services/incident.service.ts getTimeline method)
- Service singleton pattern (all services export instance)
- Audit logging for all mutations (auditService.log pattern)
- Permission checks via permissionService

@src/services/incident.service.ts - Timeline query pattern
@src/services/audit.service.ts - Audit logging pattern
@src/services/permission.service.ts - Permission check pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create postmortem service with CRUD operations</name>
  <files>src/services/postmortem.service.ts</files>
  <action>
Create new service file following existing patterns from incident.service.ts:

```typescript
import { prisma } from '../lib/prisma.js';
import { auditService } from './audit.service.js';
import { logger } from '../lib/logger.js';
import type {
  CreatePostmortemInput,
  UpdatePostmortemInput,
  Postmortem,
  PostmortemTimelineEvent
} from '../types/postmortem.js';

class PostmortemService {
  /**
   * Create a new postmortem
   */
  async create(data: CreatePostmortemInput, userId: string): Promise<Postmortem> {
    const postmortem = await prisma.postmortem.create({
      data: {
        title: data.title,
        content: data.content || '',
        incidentIds: data.incidentIds,
        teamId: data.teamId,
        createdById: userId,
        status: 'DRAFT'
      },
      include: {
        team: { select: { id: true, name: true } },
        createdBy: { select: { id: true, firstName: true, lastName: true } }
      }
    });

    await auditService.log({
      action: 'postmortem.created',
      userId,
      teamId: data.teamId,
      resourceType: 'postmortem',
      resourceId: postmortem.id,
      severity: 'INFO',
      metadata: {
        title: data.title,
        incidentCount: data.incidentIds.length
      }
    });

    logger.info({ postmortemId: postmortem.id, userId }, 'Postmortem created');
    return postmortem as Postmortem;
  }

  /**
   * Get postmortem by ID with relations
   */
  async getById(id: string): Promise<Postmortem | null> {
    const postmortem = await prisma.postmortem.findUnique({
      where: { id },
      include: {
        team: { select: { id: true, name: true } },
        createdBy: { select: { id: true, firstName: true, lastName: true } },
        actionItems: {
          include: {
            assignee: { select: { id: true, firstName: true, lastName: true } }
          },
          orderBy: [
            { status: 'asc' }, // OPEN first
            { priority: 'desc' }, // HIGH priority first
            { createdAt: 'asc' }
          ]
        }
      }
    });
    return postmortem as Postmortem | null;
  }

  /**
   * List postmortems with optional team filter
   */
  async list(filters?: { teamId?: string }): Promise<Postmortem[]> {
    const postmortems = await prisma.postmortem.findMany({
      where: filters?.teamId ? { teamId: filters.teamId } : undefined,
      include: {
        team: { select: { id: true, name: true } },
        createdBy: { select: { id: true, firstName: true, lastName: true } },
        actionItems: {
          select: { id: true, status: true }
        }
      },
      orderBy: { createdAt: 'desc' }
    });
    return postmortems as Postmortem[];
  }

  /**
   * Update postmortem (title, content, status, incidentIds)
   */
  async update(
    id: string,
    data: UpdatePostmortemInput,
    userId: string
  ): Promise<Postmortem> {
    const existing = await prisma.postmortem.findUnique({
      where: { id },
      select: { status: true, teamId: true }
    });

    if (!existing) {
      throw new Error('Postmortem not found');
    }

    // Handle status change to PUBLISHED
    const updateData: any = { ...data };
    if (data.status === 'PUBLISHED' && existing.status !== 'PUBLISHED') {
      updateData.publishedAt = new Date();
    }

    const postmortem = await prisma.postmortem.update({
      where: { id },
      data: updateData,
      include: {
        team: { select: { id: true, name: true } },
        createdBy: { select: { id: true, firstName: true, lastName: true } }
      }
    });

    await auditService.log({
      action: 'postmortem.updated',
      userId,
      teamId: postmortem.teamId,
      resourceType: 'postmortem',
      resourceId: id,
      severity: 'INFO',
      metadata: {
        changes: Object.keys(data),
        newStatus: data.status
      }
    });

    logger.info({ postmortemId: id, userId }, 'Postmortem updated');
    return postmortem as Postmortem;
  }

  /**
   * Delete postmortem and cascade action items
   */
  async delete(id: string, userId: string): Promise<void> {
    const postmortem = await prisma.postmortem.findUnique({
      where: { id },
      select: { teamId: true, title: true }
    });

    if (!postmortem) {
      throw new Error('Postmortem not found');
    }

    await prisma.postmortem.delete({ where: { id } });

    await auditService.log({
      action: 'postmortem.deleted',
      userId,
      teamId: postmortem.teamId,
      resourceType: 'postmortem',
      resourceId: id,
      severity: 'WARN',
      metadata: { title: postmortem.title }
    });

    logger.info({ postmortemId: id, userId }, 'Postmortem deleted');
  }

  /**
   * Generate timeline from audit events for linked incidents
   * This is the key functionality for POST-01 (auto-generate timeline)
   */
  async getTimeline(incidentIds: string[]): Promise<PostmortemTimelineEvent[]> {
    if (incidentIds.length === 0) {
      return [];
    }

    // Query audit events for all linked incidents
    // Reuse pattern from incident.service.ts getTimeline
    const events = await prisma.auditEvent.findMany({
      where: {
        resourceType: 'incident',
        resourceId: { in: incidentIds }
      },
      orderBy: { timestamp: 'asc' },
      include: {
        user: { select: { id: true, firstName: true, lastName: true } }
      }
    });

    // Add incidentId context for multi-incident postmortems
    return events.map(event => ({
      id: event.id,
      action: event.action,
      timestamp: event.timestamp.toISOString(),
      userId: event.userId,
      user: event.user,
      metadata: event.metadata as Record<string, unknown>,
      incidentId: event.resourceId! // resourceId is incidentId for incident events
    }));
  }

  /**
   * Publish postmortem (change status to PUBLISHED)
   */
  async publish(id: string, userId: string): Promise<Postmortem> {
    return this.update(id, { status: 'PUBLISHED' }, userId);
  }
}

export const postmortemService = new PostmortemService();
```

Key implementation details:
- Follow singleton pattern from other services
- getTimeline queries AuditEvent table (no duplication of timeline data)
- Audit logging for create/update/delete operations
- Include relations in queries for frontend display
- Action items ordered: OPEN first, then by priority DESC
  </action>
  <verify>Run `npx tsc --noEmit` - should compile without errors</verify>
  <done>PostmortemService created with CRUD, timeline generation, and audit logging</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles without errors
2. Service exports postmortemService singleton
3. All methods use Prisma client correctly
4. Audit events logged for mutations
5. Timeline query uses existing audit event pattern
</verification>

<success_criteria>
- create() creates postmortem and logs audit event
- getById() returns postmortem with team, creator, and action items
- list() returns postmortems with optional team filter
- update() updates fields and handles status change to PUBLISHED
- delete() removes postmortem and logs audit event
- getTimeline() returns chronological audit events for linked incidents
</success_criteria>

<output>
After completion, create `.planning/phases/10-postmortems/10-02-SUMMARY.md`
</output>

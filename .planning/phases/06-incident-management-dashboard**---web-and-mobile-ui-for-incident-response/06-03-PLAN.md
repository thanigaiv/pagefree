---
phase: 06-incident-management-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - frontend/src/pages/DashboardPage.tsx
  - frontend/src/components/IncidentList.tsx
  - frontend/src/components/IncidentRow.tsx
  - frontend/src/components/IncidentFilters.tsx
  - frontend/src/components/MetricsSummary.tsx
  - frontend/src/components/Pagination.tsx
  - frontend/src/hooks/useIncidents.ts
  - frontend/src/hooks/useUrlState.ts
autonomous: true

must_haves:
  truths:
    - "User sees list of incidents with priority, service, description, time, assignee"
    - "User can filter incidents by status, priority, service, assignee"
    - "User can paginate through incidents (10-20 per page)"
    - "Filters are reflected in URL query params (shareable)"
    - "Summary metrics show count of open, acknowledged, critical incidents"
    - "Empty state shows positive message when no incidents"
  artifacts:
    - path: "frontend/src/components/IncidentList.tsx"
      provides: "Main incident list component"
      min_lines: 50
    - path: "frontend/src/components/IncidentRow.tsx"
      provides: "Individual incident row (collapsed state)"
      contains: "priority"
    - path: "frontend/src/hooks/useIncidents.ts"
      provides: "TanStack Query hooks for incident data"
      exports: ["useIncidents"]
    - path: "frontend/src/hooks/useUrlState.ts"
      provides: "URL query param sync hook"
      exports: ["useUrlState"]
  key_links:
    - from: "frontend/src/pages/DashboardPage.tsx"
      to: "frontend/src/hooks/useIncidents.ts"
      via: "useIncidents hook"
      pattern: "useIncidents"
    - from: "frontend/src/hooks/useIncidents.ts"
      to: "/api/incidents"
      via: "fetch request"
      pattern: "apiFetch.*incidents"
---

<objective>
Build the incident list dashboard with filtering, pagination, and summary metrics.

Purpose: Deliver the core dashboard view that shows all active incidents. Users can scan, filter, and navigate through incidents efficiently. Per user decisions: hybrid list layout, pagination (not infinite scroll), advanced multi-select filters, URL state for shareable links.

Output: Fully functional incident list page with filters, pagination, and metrics.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-CONTEXT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-RESEARCH.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-01-SUMMARY.md

# Frontend types and API client
@frontend/src/types/incident.ts
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL State and Incident Query Hooks</name>
  <files>
    frontend/src/hooks/useUrlState.ts
    frontend/src/hooks/useIncidents.ts
  </files>
  <action>
Create frontend/src/hooks/useUrlState.ts per RESEARCH.md pattern:
```typescript
import { useSearchParams } from 'react-router-dom';
import { useMemo, useCallback } from 'react';
import queryString from 'query-string';

export interface IncidentFilters {
  status?: string[];
  priority?: string[];
  teamId?: string;
  assignedUserId?: string;
  sort?: string;
  page?: number;
}

export function useUrlState() {
  const [searchParams, setSearchParams] = useSearchParams();

  const filters = useMemo<IncidentFilters>(() => {
    const parsed = queryString.parse(searchParams.toString(), {
      arrayFormat: 'bracket',
    });

    return {
      status: Array.isArray(parsed.status)
        ? parsed.status as string[]
        : parsed.status
        ? [parsed.status as string]
        : undefined,
      priority: Array.isArray(parsed.priority)
        ? parsed.priority as string[]
        : parsed.priority
        ? [parsed.priority as string]
        : undefined,
      teamId: parsed.teamId as string | undefined,
      assignedUserId: parsed.assignedUserId as string | undefined,
      sort: (parsed.sort as string) || 'newest',
      page: parsed.page ? parseInt(parsed.page as string, 10) : 1,
    };
  }, [searchParams]);

  const updateFilters = useCallback(
    (newFilters: Partial<IncidentFilters>) => {
      const merged = { ...filters, ...newFilters };

      // Remove empty values
      const cleaned = Object.fromEntries(
        Object.entries(merged).filter(([_, v]) => {
          if (Array.isArray(v)) return v.length > 0;
          if (v === undefined || v === null) return false;
          if (v === 1 && _ === 'page') return false; // Don't include page=1
          return true;
        })
      );

      setSearchParams(
        queryString.stringify(cleaned, { arrayFormat: 'bracket' })
      );
    },
    [filters, setSearchParams]
  );

  const clearFilters = useCallback(() => {
    setSearchParams({});
  }, [setSearchParams]);

  return { filters, updateFilters, clearFilters };
}
```

Create frontend/src/hooks/useIncidents.ts:
```typescript
import { useQuery } from '@tanstack/react-query';
import { apiFetch } from '../lib/api';
import type { Incident, IncidentListResponse } from '../types/incident';
import type { IncidentFilters } from './useUrlState';

const PAGE_SIZE = 20; // Per user decision: 10-20 per page

export function useIncidents(filters: IncidentFilters) {
  return useQuery({
    queryKey: ['incidents', filters],
    queryFn: async () => {
      const params = new URLSearchParams();

      if (filters.status?.length) {
        params.set('status', filters.status.join(','));
      }
      if (filters.priority?.length) {
        params.set('priority', filters.priority.join(','));
      }
      if (filters.teamId) {
        params.set('teamId', filters.teamId);
      }
      if (filters.assignedUserId) {
        params.set('assignedUserId', filters.assignedUserId);
      }
      params.set('limit', String(PAGE_SIZE));

      // Simple offset pagination (page * limit)
      if (filters.page && filters.page > 1) {
        // For cursor-based, we'd need to track cursors
        // For now, using offset approach
        params.set('offset', String((filters.page - 1) * PAGE_SIZE));
      }

      const response = await apiFetch<IncidentListResponse>(
        `/incidents?${params.toString()}`
      );

      return response;
    },
    staleTime: 30 * 1000, // 30 seconds
  });
}

export function useIncidentById(id: string | undefined) {
  return useQuery({
    queryKey: ['incidents', id],
    queryFn: async () => {
      if (!id) throw new Error('No incident ID');
      const response = await apiFetch<{ incident: Incident }>(
        `/incidents/${id}`
      );
      return response.incident;
    },
    enabled: !!id,
  });
}

// Count queries for metrics
export function useIncidentCounts() {
  return useQuery({
    queryKey: ['incidents', 'counts'],
    queryFn: async () => {
      // Fetch minimal data for counts
      const [open, acked, critical] = await Promise.all([
        apiFetch<IncidentListResponse>('/incidents?status=OPEN&limit=1'),
        apiFetch<IncidentListResponse>('/incidents?status=ACKNOWLEDGED&limit=1'),
        apiFetch<IncidentListResponse>('/incidents?priority=CRITICAL&status=OPEN,ACKNOWLEDGED&limit=1'),
      ]);

      // Note: Backend should ideally provide count endpoint
      // This is a workaround using limit=1 to check existence
      return {
        open: open.incidents.length > 0,
        acknowledged: acked.incidents.length > 0,
        critical: critical.incidents.length > 0,
      };
    },
    staleTime: 60 * 1000, // 1 minute
  });
}
```
  </action>
  <verify>
ls frontend/src/hooks/useUrlState.ts
ls frontend/src/hooks/useIncidents.ts
cd frontend && npm run build
  </verify>
  <done>
URL state hook syncs filters with query params. Incident query hooks fetch data from backend API with proper filtering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IncidentRow and Priority Visual System</name>
  <files>
    frontend/src/components/IncidentRow.tsx
    frontend/src/components/ui/priority-badge.tsx
  </files>
  <action>
Add more shadcn/ui components:
```bash
cd frontend
npx shadcn@latest add checkbox
```

Create frontend/src/components/ui/priority-badge.tsx (per discretion: color-coded left border + icon):
```typescript
import { cn } from '@/lib/utils';
import { Badge } from '@/components/ui/badge';
import { Flame, AlertTriangle, AlertCircle, Info } from 'lucide-react';

type Priority = 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';

const priorityConfig: Record<Priority, {
  color: string;
  bgColor: string;
  borderColor: string;
  icon: React.ComponentType<{ className?: string }>;
  label: string;
}> = {
  CRITICAL: {
    color: 'text-red-700 dark:text-red-400',
    bgColor: 'bg-red-50 dark:bg-red-950',
    borderColor: 'border-l-red-500',
    icon: Flame,
    label: 'Critical',
  },
  HIGH: {
    color: 'text-orange-700 dark:text-orange-400',
    bgColor: 'bg-orange-50 dark:bg-orange-950',
    borderColor: 'border-l-orange-500',
    icon: AlertTriangle,
    label: 'High',
  },
  MEDIUM: {
    color: 'text-yellow-700 dark:text-yellow-400',
    bgColor: 'bg-yellow-50 dark:bg-yellow-950',
    borderColor: 'border-l-yellow-500',
    icon: AlertCircle,
    label: 'Medium',
  },
  LOW: {
    color: 'text-blue-700 dark:text-blue-400',
    bgColor: 'bg-blue-50 dark:bg-blue-950',
    borderColor: 'border-l-blue-500',
    icon: Info,
    label: 'Low',
  },
  INFO: {
    color: 'text-gray-700 dark:text-gray-400',
    bgColor: 'bg-gray-50 dark:bg-gray-800',
    borderColor: 'border-l-gray-400',
    icon: Info,
    label: 'Info',
  },
};

interface PriorityBadgeProps {
  priority: Priority;
  showLabel?: boolean;
  className?: string;
}

export function PriorityBadge({ priority, showLabel = true, className }: PriorityBadgeProps) {
  const config = priorityConfig[priority] || priorityConfig.INFO;
  const Icon = config.icon;

  return (
    <Badge
      variant="outline"
      className={cn(
        config.color,
        config.bgColor,
        'border-0 gap-1',
        className
      )}
    >
      <Icon className="h-3 w-3" />
      {showLabel && <span>{config.label}</span>}
    </Badge>
  );
}

export function getPriorityBorderClass(priority: Priority): string {
  return priorityConfig[priority]?.borderColor || priorityConfig.INFO.borderColor;
}
```

Install lucide-react icons:
```bash
cd frontend && npm install lucide-react
```

Create frontend/src/components/IncidentRow.tsx:
```typescript
import { formatDistanceToNow } from 'date-fns';
import type { Incident } from '@/types/incident';
import { Card } from '@/components/ui/card';
import { Checkbox } from '@/components/ui/checkbox';
import { PriorityBadge, getPriorityBorderClass } from '@/components/ui/priority-badge';
import { cn } from '@/lib/utils';
import { ChevronDown, User } from 'lucide-react';

interface IncidentRowProps {
  incident: Incident;
  isSelected: boolean;
  isExpanded: boolean;
  onSelect: (selected: boolean) => void;
  onToggleExpand: () => void;
}

export function IncidentRow({
  incident,
  isSelected,
  isExpanded,
  onSelect,
  onToggleExpand,
}: IncidentRowProps) {
  const service = incident.metadata?.service as string || incident.team.name;
  const borderClass = getPriorityBorderClass(incident.priority);

  return (
    <Card
      className={cn(
        'border-l-4 transition-all',
        borderClass,
        isExpanded && 'ring-2 ring-blue-500',
        'hover:shadow-md cursor-pointer'
      )}
      onClick={onToggleExpand}
    >
      <div className="p-4 flex items-center gap-4">
        {/* Checkbox for bulk selection */}
        <Checkbox
          checked={isSelected}
          onCheckedChange={onSelect}
          onClick={(e) => e.stopPropagation()}
          aria-label={`Select incident ${incident.id}`}
        />

        {/* Priority badge */}
        <PriorityBadge priority={incident.priority} showLabel={false} />

        {/* Main content */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2">
            <span className="text-sm font-medium text-muted-foreground">
              {service}
            </span>
            <span className="text-xs text-muted-foreground">
              #{incident.id.slice(-6)}
            </span>
          </div>
          <p className="text-sm font-medium truncate">
            {incident.title || incident.fingerprint}
          </p>
          {incident.description && (
            <p className="text-xs text-muted-foreground truncate">
              {incident.description}
            </p>
          )}
        </div>

        {/* Time */}
        <div className="text-right text-sm text-muted-foreground whitespace-nowrap">
          {formatDistanceToNow(new Date(incident.createdAt), { addSuffix: true })}
        </div>

        {/* Assignee */}
        <div className="flex items-center gap-1 text-sm text-muted-foreground min-w-[120px]">
          <User className="h-4 w-4" />
          <span className="truncate">
            {incident.assignedUser
              ? `${incident.assignedUser.firstName} ${incident.assignedUser.lastName}`
              : 'Unassigned'}
          </span>
        </div>

        {/* Status badge */}
        <span
          className={cn(
            'text-xs font-medium px-2 py-1 rounded',
            incident.status === 'OPEN' && 'bg-red-100 text-red-700',
            incident.status === 'ACKNOWLEDGED' && 'bg-yellow-100 text-yellow-700',
            incident.status === 'RESOLVED' && 'bg-green-100 text-green-700',
            incident.status === 'CLOSED' && 'bg-gray-100 text-gray-700'
          )}
        >
          {incident.status}
        </span>

        {/* Expand indicator */}
        <ChevronDown
          className={cn(
            'h-5 w-5 text-muted-foreground transition-transform',
            isExpanded && 'rotate-180'
          )}
        />
      </div>
    </Card>
  );
}
```

Install date-fns for time formatting:
```bash
cd frontend && npm install date-fns
```
  </action>
  <verify>
ls frontend/src/components/IncidentRow.tsx
ls frontend/src/components/ui/priority-badge.tsx
cd frontend && npm run build
  </verify>
  <done>
IncidentRow shows collapsed view with priority, service, description, time, assignee per user decision. Priority visual system uses color-coded left border + icons.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create IncidentList, Filters, MetricsSummary, and DashboardPage</name>
  <files>
    frontend/src/components/IncidentList.tsx
    frontend/src/components/IncidentFilters.tsx
    frontend/src/components/MetricsSummary.tsx
    frontend/src/components/Pagination.tsx
    frontend/src/pages/DashboardPage.tsx
  </files>
  <action>
Add more shadcn/ui components:
```bash
cd frontend
npx shadcn@latest add select popover command separator
```

Create frontend/src/components/IncidentFilters.tsx (multi-select per user decision):
```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';
import { Checkbox } from '@/components/ui/checkbox';
import { Separator } from '@/components/ui/separator';
import type { IncidentFilters as Filters } from '@/hooks/useUrlState';
import { Filter, X } from 'lucide-react';

const STATUS_OPTIONS = [
  { value: 'OPEN', label: 'Open' },
  { value: 'ACKNOWLEDGED', label: 'Acknowledged' },
  { value: 'RESOLVED', label: 'Resolved' },
  { value: 'CLOSED', label: 'Closed' },
];

const PRIORITY_OPTIONS = [
  { value: 'CRITICAL', label: 'Critical' },
  { value: 'HIGH', label: 'High' },
  { value: 'MEDIUM', label: 'Medium' },
  { value: 'LOW', label: 'Low' },
  { value: 'INFO', label: 'Info' },
];

interface IncidentFiltersProps {
  filters: Filters;
  onUpdateFilters: (filters: Partial<Filters>) => void;
  onClearFilters: () => void;
}

export function IncidentFilters({
  filters,
  onUpdateFilters,
  onClearFilters,
}: IncidentFiltersProps) {
  const activeFilterCount =
    (filters.status?.length || 0) + (filters.priority?.length || 0);

  const handleStatusChange = (value: string, checked: boolean) => {
    const current = filters.status || [];
    const updated = checked
      ? [...current, value]
      : current.filter((s) => s !== value);
    onUpdateFilters({ status: updated.length ? updated : undefined, page: 1 });
  };

  const handlePriorityChange = (value: string, checked: boolean) => {
    const current = filters.priority || [];
    const updated = checked
      ? [...current, value]
      : current.filter((p) => p !== value);
    onUpdateFilters({ priority: updated.length ? updated : undefined, page: 1 });
  };

  return (
    <div className="flex items-center gap-2">
      <Popover>
        <PopoverTrigger asChild>
          <Button variant="outline" size="sm" className="gap-2">
            <Filter className="h-4 w-4" />
            Filters
            {activeFilterCount > 0 && (
              <span className="ml-1 bg-primary text-primary-foreground rounded-full px-2 py-0.5 text-xs">
                {activeFilterCount}
              </span>
            )}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-80" align="start">
          <div className="space-y-4">
            {/* Status filters */}
            <div>
              <h4 className="font-medium text-sm mb-2">Status</h4>
              <div className="grid grid-cols-2 gap-2">
                {STATUS_OPTIONS.map((option) => (
                  <label
                    key={option.value}
                    className="flex items-center gap-2 text-sm cursor-pointer"
                  >
                    <Checkbox
                      checked={filters.status?.includes(option.value) || false}
                      onCheckedChange={(checked) =>
                        handleStatusChange(option.value, !!checked)
                      }
                    />
                    {option.label}
                  </label>
                ))}
              </div>
            </div>

            <Separator />

            {/* Priority filters */}
            <div>
              <h4 className="font-medium text-sm mb-2">Priority</h4>
              <div className="grid grid-cols-2 gap-2">
                {PRIORITY_OPTIONS.map((option) => (
                  <label
                    key={option.value}
                    className="flex items-center gap-2 text-sm cursor-pointer"
                  >
                    <Checkbox
                      checked={filters.priority?.includes(option.value) || false}
                      onCheckedChange={(checked) =>
                        handlePriorityChange(option.value, !!checked)
                      }
                    />
                    {option.label}
                  </label>
                ))}
              </div>
            </div>
          </div>
        </PopoverContent>
      </Popover>

      {activeFilterCount > 0 && (
        <Button
          variant="ghost"
          size="sm"
          onClick={onClearFilters}
          className="gap-1"
        >
          <X className="h-4 w-4" />
          Clear
        </Button>
      )}
    </div>
  );
}
```

Create frontend/src/components/MetricsSummary.tsx:
```typescript
import { Card, CardContent } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { AlertCircle, CheckCircle, Flame, Clock } from 'lucide-react';

interface MetricsSummaryProps {
  metrics?: {
    open: number;
    acknowledged: number;
    critical: number;
    total: number;
  };
  isLoading?: boolean;
}

export function MetricsSummary({ metrics, isLoading }: MetricsSummaryProps) {
  if (isLoading) {
    return (
      <div className="grid grid-cols-4 gap-4">
        {[...Array(4)].map((_, i) => (
          <Card key={i}>
            <CardContent className="p-4">
              <Skeleton className="h-8 w-16 mb-2" />
              <Skeleton className="h-4 w-24" />
            </CardContent>
          </Card>
        ))}
      </div>
    );
  }

  const items = [
    {
      label: 'Open',
      value: metrics?.open ?? 0,
      icon: AlertCircle,
      color: 'text-red-600',
      bgColor: 'bg-red-50',
    },
    {
      label: 'Acknowledged',
      value: metrics?.acknowledged ?? 0,
      icon: Clock,
      color: 'text-yellow-600',
      bgColor: 'bg-yellow-50',
    },
    {
      label: 'Critical',
      value: metrics?.critical ?? 0,
      icon: Flame,
      color: 'text-red-600',
      bgColor: 'bg-red-50',
    },
    {
      label: 'Total Active',
      value: (metrics?.open ?? 0) + (metrics?.acknowledged ?? 0),
      icon: CheckCircle,
      color: 'text-blue-600',
      bgColor: 'bg-blue-50',
    },
  ];

  return (
    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
      {items.map((item) => (
        <Card key={item.label}>
          <CardContent className="p-4 flex items-center gap-4">
            <div className={`p-2 rounded-full ${item.bgColor}`}>
              <item.icon className={`h-5 w-5 ${item.color}`} />
            </div>
            <div>
              <p className="text-2xl font-bold">{item.value}</p>
              <p className="text-sm text-muted-foreground">{item.label}</p>
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
```

Create frontend/src/components/Pagination.tsx:
```typescript
import { Button } from '@/components/ui/button';
import { ChevronLeft, ChevronRight } from 'lucide-react';

interface PaginationProps {
  currentPage: number;
  hasNextPage: boolean;
  hasPrevPage: boolean;
  onPageChange: (page: number) => void;
}

export function Pagination({
  currentPage,
  hasNextPage,
  hasPrevPage,
  onPageChange,
}: PaginationProps) {
  return (
    <div className="flex items-center justify-center gap-2 py-4">
      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage - 1)}
        disabled={!hasPrevPage}
      >
        <ChevronLeft className="h-4 w-4" />
        Previous
      </Button>

      <span className="text-sm text-muted-foreground px-4">
        Page {currentPage}
      </span>

      <Button
        variant="outline"
        size="sm"
        onClick={() => onPageChange(currentPage + 1)}
        disabled={!hasNextPage}
      >
        Next
        <ChevronRight className="h-4 w-4" />
      </Button>
    </div>
  );
}
```

Create frontend/src/components/IncidentList.tsx:
```typescript
import { useState } from 'react';
import type { Incident } from '@/types/incident';
import { IncidentRow } from './IncidentRow';
import { Button } from '@/components/ui/button';
import { Skeleton } from '@/components/ui/skeleton';
import { AlertCircle } from 'lucide-react';

interface IncidentListProps {
  incidents: Incident[];
  isLoading: boolean;
  error?: Error | null;
  selectedIds: Set<string>;
  expandedId: string | null;
  onSelectIncident: (id: string, selected: boolean) => void;
  onSelectAll: (selected: boolean) => void;
  onExpandIncident: (id: string | null) => void;
}

export function IncidentList({
  incidents,
  isLoading,
  error,
  selectedIds,
  expandedId,
  onSelectIncident,
  onSelectAll,
  onExpandIncident,
}: IncidentListProps) {
  // Loading state with skeletons (per user decision)
  if (isLoading) {
    return (
      <div className="space-y-3">
        {[...Array(5)].map((_, i) => (
          <Skeleton key={i} className="h-20 w-full" />
        ))}
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="flex flex-col items-center justify-center py-12 text-center">
        <AlertCircle className="h-12 w-12 text-red-500 mb-4" />
        <h3 className="text-lg font-medium">Failed to load incidents</h3>
        <p className="text-muted-foreground">{error.message}</p>
      </div>
    );
  }

  // Empty state (per user decision: positive message)
  if (incidents.length === 0) {
    return (
      <div className="flex flex-col items-center justify-center py-12 text-center">
        <div className="text-6xl mb-4">ðŸŽ‰</div>
        <h3 className="text-lg font-medium">All clear!</h3>
        <p className="text-muted-foreground">No active incidents</p>
      </div>
    );
  }

  return (
    <div className="space-y-3">
      {/* Bulk select header */}
      {selectedIds.size > 0 && (
        <div className="flex items-center gap-4 p-2 bg-muted rounded">
          <span className="text-sm font-medium">
            {selectedIds.size} selected
          </span>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => onSelectAll(false)}
          >
            Clear selection
          </Button>
        </div>
      )}

      {/* Incident rows */}
      {incidents.map((incident) => (
        <IncidentRow
          key={incident.id}
          incident={incident}
          isSelected={selectedIds.has(incident.id)}
          isExpanded={expandedId === incident.id}
          onSelect={(selected) => onSelectIncident(incident.id, selected)}
          onToggleExpand={() =>
            onExpandIncident(expandedId === incident.id ? null : incident.id)
          }
        />
      ))}
    </div>
  );
}
```

Update frontend/src/pages/DashboardPage.tsx:
```typescript
import { useState, useMemo } from 'react';
import { useIncidents } from '@/hooks/useIncidents';
import { useUrlState } from '@/hooks/useUrlState';
import { IncidentList } from '@/components/IncidentList';
import { IncidentFilters } from '@/components/IncidentFilters';
import { MetricsSummary } from '@/components/MetricsSummary';
import { Pagination } from '@/components/Pagination';
import { Button } from '@/components/ui/button';
import { RefreshCw } from 'lucide-react';

const PAGE_SIZE = 20;

export default function DashboardPage() {
  const { filters, updateFilters, clearFilters } = useUrlState();
  const { data, isLoading, error, refetch, isFetching } = useIncidents(filters);

  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());
  const [expandedId, setExpandedId] = useState<string | null>(null);

  // Calculate metrics from current data
  const metrics = useMemo(() => {
    if (!data?.incidents) return undefined;

    return {
      open: data.incidents.filter((i) => i.status === 'OPEN').length,
      acknowledged: data.incidents.filter((i) => i.status === 'ACKNOWLEDGED').length,
      critical: data.incidents.filter(
        (i) => i.priority === 'CRITICAL' && ['OPEN', 'ACKNOWLEDGED'].includes(i.status)
      ).length,
      total: data.incidents.length,
    };
  }, [data?.incidents]);

  const handleSelectIncident = (id: string, selected: boolean) => {
    setSelectedIds((prev) => {
      const next = new Set(prev);
      if (selected) {
        next.add(id);
      } else {
        next.delete(id);
      }
      return next;
    });
  };

  const handleSelectAll = (selected: boolean) => {
    if (selected && data?.incidents) {
      setSelectedIds(new Set(data.incidents.map((i) => i.id)));
    } else {
      setSelectedIds(new Set());
    }
  };

  const handlePageChange = (page: number) => {
    updateFilters({ page });
    setExpandedId(null);
  };

  const currentPage = filters.page || 1;
  const hasNextPage = data?.nextCursor !== null;
  const hasPrevPage = currentPage > 1;

  return (
    <div className="container mx-auto py-6 px-4 max-w-7xl">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold">Incidents</h1>
          <p className="text-muted-foreground">
            Manage and respond to active incidents
          </p>
        </div>
        <Button
          variant="outline"
          size="sm"
          onClick={() => refetch()}
          disabled={isFetching}
        >
          <RefreshCw className={`h-4 w-4 mr-2 ${isFetching ? 'animate-spin' : ''}`} />
          Refresh
        </Button>
      </div>

      {/* Metrics summary (per user decision) */}
      <div className="mb-6">
        <MetricsSummary metrics={metrics} isLoading={isLoading} />
      </div>

      {/* Filters */}
      <div className="mb-4">
        <IncidentFilters
          filters={filters}
          onUpdateFilters={updateFilters}
          onClearFilters={clearFilters}
        />
      </div>

      {/* Incident list */}
      <IncidentList
        incidents={data?.incidents || []}
        isLoading={isLoading}
        error={error}
        selectedIds={selectedIds}
        expandedId={expandedId}
        onSelectIncident={handleSelectIncident}
        onSelectAll={handleSelectAll}
        onExpandIncident={setExpandedId}
      />

      {/* Pagination (per user decision: pagination not infinite scroll) */}
      {data?.incidents && data.incidents.length > 0 && (
        <Pagination
          currentPage={currentPage}
          hasNextPage={hasNextPage}
          hasPrevPage={hasPrevPage}
          onPageChange={handlePageChange}
        />
      )}
    </div>
  );
}
```
  </action>
  <verify>
ls frontend/src/components/IncidentList.tsx
ls frontend/src/components/IncidentFilters.tsx
ls frontend/src/components/MetricsSummary.tsx
ls frontend/src/pages/DashboardPage.tsx
cd frontend && npm run build
  </verify>
  <done>
Dashboard page complete with incident list, multi-select filters in URL, pagination, metrics summary, and empty state message per all user decisions.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npm run build` - Compiles without errors
2. `cd frontend && npm run dev` - Start dev server
3. Navigate to http://localhost:3001/incidents
4. Verify skeleton loading states appear
5. Verify filters update URL query params
6. Verify pagination controls work
7. Verify empty state shows "All clear!" message
</verification>

<success_criteria>
- [ ] IncidentRow displays priority, service, description, time, assignee
- [ ] Priority uses color-coded left border + icon system
- [ ] Multi-select filters for status and priority
- [ ] URL query params update when filters change
- [ ] Pagination with 20 incidents per page
- [ ] Skeleton loading states during fetch
- [ ] Empty state shows positive "All clear!" message
- [ ] Metrics summary shows open, acknowledged, critical counts
- [ ] Bulk selection with checkboxes
- [ ] Rows are expandable (expand UI in Plan 04)
</success_criteria>

<output>
After completion, create `.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-03-SUMMARY.md`
</output>

---
phase: 06-incident-management-dashboard
plan: 11
type: execute
wave: 6
depends_on: ["06-01", "06-02", "06-03", "06-04", "06-05", "06-06", "06-07", "06-08", "06-09", "06-10"]
files_modified:
  - frontend/src/tests/setup.ts
  - frontend/src/tests/components/IncidentRow.test.tsx
  - frontend/src/tests/components/IncidentTimeline.test.tsx
  - frontend/src/tests/hooks/useWebSocket.test.ts
  - frontend/src/tests/hooks/useSwipeGesture.test.ts
  - frontend/vitest.config.ts
autonomous: true

must_haves:
  truths:
    - "Component tests pass for critical UI components"
    - "Hook tests verify WebSocket and gesture behavior"
    - "All tests pass in CI environment"
    - "Test coverage for core incident workflow"
  artifacts:
    - path: "frontend/vitest.config.ts"
      provides: "Test configuration"
      contains: "vitest"
    - path: "frontend/src/tests/setup.ts"
      provides: "Test setup with mocks"
      contains: "vi.mock"
    - path: "frontend/src/tests/components/IncidentRow.test.tsx"
      provides: "IncidentRow component tests"
      contains: "describe"
  key_links:
    - from: "frontend/vitest.config.ts"
      to: "vitest"
      via: "test configuration"
      pattern: "defineConfig"
    - from: "frontend/src/tests/setup.ts"
      to: "test files"
      via: "setupFiles"
      pattern: "beforeEach|afterEach"
---

<objective>
Create frontend tests to verify critical dashboard functionality.

Purpose: Ensure incident list, timeline, WebSocket integration, and mobile gestures work correctly. Tests provide confidence for ongoing development and catch regressions.

Output: Passing test suite for frontend components and hooks.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-CONTEXT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-RESEARCH.md

# All prior summaries from this phase
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Vitest and Test Setup</name>
  <files>
    frontend/vitest.config.ts
    frontend/src/tests/setup.ts
    frontend/package.json
  </files>
  <action>
Install testing dependencies:
```bash
cd frontend && npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom @vitejs/plugin-react
```

Create frontend/vitest.config.ts:
```typescript
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/tests/setup.ts'],
    include: ['src/**/*.{test,spec}.{ts,tsx}'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['src/components/**', 'src/hooks/**'],
      exclude: ['src/tests/**', 'src/**/*.d.ts'],
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

Create frontend/src/tests/setup.ts:
```typescript
import '@testing-library/jest-dom';
import { vi, beforeEach, afterEach } from 'vitest';

// Mock socket.io-client
vi.mock('socket.io-client', () => ({
  io: vi.fn(() => ({
    on: vi.fn(),
    off: vi.fn(),
    emit: vi.fn(),
    connect: vi.fn(),
    disconnect: vi.fn(),
    connected: false,
    io: {
      on: vi.fn(),
      off: vi.fn(),
    },
  })),
}));

// Mock fetch globally
global.fetch = vi.fn();

// Mock navigator for PWA tests
Object.defineProperty(navigator, 'serviceWorker', {
  value: {
    ready: Promise.resolve({
      pushManager: {
        subscribe: vi.fn(),
        getSubscription: vi.fn(),
      },
    }),
  },
  writable: true,
});

// Mock matchMedia for responsive tests
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation((query) => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
});

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Mock ResizeObserver
global.ResizeObserver = vi.fn().mockImplementation(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}));

// Reset all mocks between tests
beforeEach(() => {
  vi.clearAllMocks();
});

afterEach(() => {
  vi.restoreAllMocks();
});
```

Update frontend/package.json scripts:
```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  }
}
```
  </action>
  <verify>
ls frontend/vitest.config.ts
ls frontend/src/tests/setup.ts
grep -q "vitest" frontend/package.json
  </verify>
  <done>
Vitest configured with jsdom environment, React Testing Library, and comprehensive mocks for socket.io, fetch, and browser APIs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Component Tests</name>
  <files>
    frontend/src/tests/components/IncidentRow.test.tsx
    frontend/src/tests/components/IncidentTimeline.test.tsx
    frontend/src/tests/components/IncidentFilters.test.tsx
  </files>
  <action>
Create frontend/src/tests/components/IncidentRow.test.tsx:
```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BrowserRouter } from 'react-router-dom';
import { IncidentRow } from '@/components/IncidentRow';
import type { Incident } from '@/types/incident';

const mockIncident: Incident = {
  id: 'inc-123',
  fingerprint: 'test-fingerprint',
  status: 'OPEN',
  priority: 'HIGH',
  title: 'Test Incident',
  description: 'Test description',
  metadata: { service: 'payment-api' },
  teamId: 'team-1',
  team: { id: 'team-1', name: 'Platform Team' },
  assignedUserId: 'user-1',
  assignedUser: { id: 'user-1', firstName: 'John', lastName: 'Doe', email: 'john@test.com' },
  currentLevel: 0,
  currentRepeat: 0,
  createdAt: new Date().toISOString(),
};

const renderWithProviders = (ui: React.ReactElement) => {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  });

  return render(
    <QueryClientProvider client={queryClient}>
      <BrowserRouter>{ui}</BrowserRouter>
    </QueryClientProvider>
  );
};

describe('IncidentRow', () => {
  it('renders incident title and priority', () => {
    renderWithProviders(
      <IncidentRow
        incident={mockIncident}
        isSelected={false}
        isExpanded={false}
        onSelect={vi.fn()}
        onToggleExpand={vi.fn()}
      />
    );

    expect(screen.getByText('Test Incident')).toBeInTheDocument();
    expect(screen.getByText('HIGH')).toBeInTheDocument();
  });

  it('renders service from metadata', () => {
    renderWithProviders(
      <IncidentRow
        incident={mockIncident}
        isSelected={false}
        isExpanded={false}
        onSelect={vi.fn()}
        onToggleExpand={vi.fn()}
      />
    );

    expect(screen.getByText('payment-api')).toBeInTheDocument();
  });

  it('renders assignee name', () => {
    renderWithProviders(
      <IncidentRow
        incident={mockIncident}
        isSelected={false}
        isExpanded={false}
        onSelect={vi.fn()}
        onToggleExpand={vi.fn()}
      />
    );

    expect(screen.getByText('John Doe')).toBeInTheDocument();
  });

  it('shows Unassigned when no assignee', () => {
    const unassignedIncident = { ...mockIncident, assignedUser: undefined };

    renderWithProviders(
      <IncidentRow
        incident={unassignedIncident}
        isSelected={false}
        isExpanded={false}
        onSelect={vi.fn()}
        onToggleExpand={vi.fn()}
      />
    );

    expect(screen.getByText('Unassigned')).toBeInTheDocument();
  });

  it('calls onToggleExpand when clicked', () => {
    const onToggleExpand = vi.fn();

    renderWithProviders(
      <IncidentRow
        incident={mockIncident}
        isSelected={false}
        isExpanded={false}
        onSelect={vi.fn()}
        onToggleExpand={onToggleExpand}
      />
    );

    fireEvent.click(screen.getByText('Test Incident').closest('[class*="Card"]')!);
    expect(onToggleExpand).toHaveBeenCalled();
  });

  it('checkbox calls onSelect when clicked', () => {
    const onSelect = vi.fn();

    renderWithProviders(
      <IncidentRow
        incident={mockIncident}
        isSelected={false}
        isExpanded={false}
        onSelect={onSelect}
        onToggleExpand={vi.fn()}
      />
    );

    const checkbox = screen.getByRole('checkbox');
    fireEvent.click(checkbox);
    expect(onSelect).toHaveBeenCalledWith(true);
  });

  it('displays correct status badge colors', () => {
    const { rerender } = renderWithProviders(
      <IncidentRow
        incident={mockIncident}
        isSelected={false}
        isExpanded={false}
        onSelect={vi.fn()}
        onToggleExpand={vi.fn()}
      />
    );

    expect(screen.getByText('OPEN')).toHaveClass('bg-red-100');

    rerender(
      <QueryClientProvider client={new QueryClient()}>
        <BrowserRouter>
          <IncidentRow
            incident={{ ...mockIncident, status: 'ACKNOWLEDGED' }}
            isSelected={false}
            isExpanded={false}
            onSelect={vi.fn()}
            onToggleExpand={vi.fn()}
          />
        </BrowserRouter>
      </QueryClientProvider>
    );

    expect(screen.getByText('ACKNOWLEDGED')).toHaveClass('bg-yellow-100');
  });
});
```

Create frontend/src/tests/components/IncidentTimeline.test.tsx:
```typescript
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { IncidentTimeline } from '@/components/IncidentTimeline';
import type { TimelineEvent } from '@/types/incident';

const mockEvents: TimelineEvent[] = [
  {
    id: '1',
    action: 'incident.created',
    timestamp: new Date().toISOString(),
    userId: 'system',
  },
  {
    id: '2',
    action: 'incident.acknowledged',
    timestamp: new Date().toISOString(),
    userId: 'user-1',
    user: { id: 'user-1', firstName: 'Jane', lastName: 'Smith' },
  },
  {
    id: '3',
    action: 'incident.note.added',
    timestamp: new Date().toISOString(),
    userId: 'user-2',
    user: { id: 'user-2', firstName: 'Bob', lastName: 'Jones' },
    metadata: { note: 'This is a test note' },
  },
];

describe('IncidentTimeline', () => {
  it('renders loading skeleton when loading', () => {
    render(<IncidentTimeline events={[]} isLoading={true} />);

    // Should render skeleton elements
    const skeletons = document.querySelectorAll('[class*="skeleton"]');
    expect(skeletons.length).toBeGreaterThan(0);
  });

  it('renders empty state when no events', () => {
    render(<IncidentTimeline events={[]} isLoading={false} />);

    expect(screen.getByText('No timeline events yet')).toBeInTheDocument();
  });

  it('renders timeline events', () => {
    render(<IncidentTimeline events={mockEvents} isLoading={false} />);

    expect(screen.getByText('Jane Smith')).toBeInTheDocument();
    expect(screen.getByText('This is a test note')).toBeInTheDocument();
  });

  it('distinguishes note events with different styling', () => {
    render(<IncidentTimeline events={mockEvents} isLoading={false} />);

    // Note events should have blue background
    const noteContent = screen.getByText('This is a test note');
    const noteCard = noteContent.closest('[class*="bg-blue"]');
    expect(noteCard).toBeInTheDocument();
  });

  it('renders without virtualization for short lists', () => {
    const shortList = mockEvents.slice(0, 2);
    render(<IncidentTimeline events={shortList} isLoading={false} />);

    // Should render directly without virtualization container
    const virtualContainer = document.querySelector('[style*="height"]');
    expect(virtualContainer).toBeNull();
  });
});
```

Create frontend/src/tests/components/IncidentFilters.test.tsx:
```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { IncidentFilters } from '@/components/IncidentFilters';

describe('IncidentFilters', () => {
  it('renders filter button', () => {
    render(
      <IncidentFilters
        filters={{}}
        onUpdateFilters={vi.fn()}
        onClearFilters={vi.fn()}
      />
    );

    expect(screen.getByText('Filters')).toBeInTheDocument();
  });

  it('shows active filter count badge', () => {
    render(
      <IncidentFilters
        filters={{ status: ['OPEN', 'ACKNOWLEDGED'], priority: ['HIGH'] }}
        onUpdateFilters={vi.fn()}
        onClearFilters={vi.fn()}
      />
    );

    // Badge should show count of active filters (2 status + 1 priority = 3)
    expect(screen.getByText('3')).toBeInTheDocument();
  });

  it('shows clear button when filters are active', () => {
    render(
      <IncidentFilters
        filters={{ status: ['OPEN'] }}
        onUpdateFilters={vi.fn()}
        onClearFilters={vi.fn()}
      />
    );

    expect(screen.getByText('Clear')).toBeInTheDocument();
  });

  it('calls onClearFilters when clear button clicked', () => {
    const onClearFilters = vi.fn();

    render(
      <IncidentFilters
        filters={{ status: ['OPEN'] }}
        onUpdateFilters={vi.fn()}
        onClearFilters={onClearFilters}
      />
    );

    fireEvent.click(screen.getByText('Clear'));
    expect(onClearFilters).toHaveBeenCalled();
  });

  it('does not show clear button when no filters active', () => {
    render(
      <IncidentFilters
        filters={{}}
        onUpdateFilters={vi.fn()}
        onClearFilters={vi.fn()}
      />
    );

    expect(screen.queryByText('Clear')).not.toBeInTheDocument();
  });
});
```
  </action>
  <verify>
ls frontend/src/tests/components/IncidentRow.test.tsx
ls frontend/src/tests/components/IncidentTimeline.test.tsx
ls frontend/src/tests/components/IncidentFilters.test.tsx
  </verify>
  <done>
Component tests created for IncidentRow, IncidentTimeline, and IncidentFilters. Tests verify rendering, interactions, and state-based styling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Hook Tests and Run Test Suite</name>
  <files>
    frontend/src/tests/hooks/useSwipeGesture.test.ts
    frontend/src/tests/hooks/useUrlState.test.tsx
  </files>
  <action>
Create frontend/src/tests/hooks/useSwipeGesture.test.ts:
```typescript
import { describe, it, expect, vi } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useSwipeGesture } from '@/hooks/useSwipeGesture';

describe('useSwipeGesture', () => {
  const createTouchEvent = (clientX: number, clientY: number) => ({
    targetTouches: [{ clientX, clientY }],
  } as unknown as React.TouchEvent);

  it('returns initial state with no swipe', () => {
    const { result } = renderHook(() =>
      useSwipeGesture({
        onSwipeRight: vi.fn(),
        onSwipeLeft: vi.fn(),
      })
    );

    expect(result.current.swipeOffset).toBe(0);
    expect(result.current.isSwipingRight).toBe(false);
    expect(result.current.isSwipingLeft).toBe(false);
    expect(result.current.swipeDirection).toBe(null);
  });

  it('detects right swipe when moving > 80px right', () => {
    const onSwipeRight = vi.fn();
    const { result } = renderHook(() =>
      useSwipeGesture({
        onSwipeRight,
        onSwipeLeft: vi.fn(),
      })
    );

    act(() => {
      result.current.swipeHandlers.onTouchStart(createTouchEvent(0, 100));
      result.current.swipeHandlers.onTouchMove(createTouchEvent(100, 100));
      result.current.swipeHandlers.onTouchEnd();
    });

    expect(onSwipeRight).toHaveBeenCalled();
  });

  it('detects left swipe when moving > 80px left', () => {
    const onSwipeLeft = vi.fn();
    const { result } = renderHook(() =>
      useSwipeGesture({
        onSwipeRight: vi.fn(),
        onSwipeLeft,
      })
    );

    act(() => {
      result.current.swipeHandlers.onTouchStart(createTouchEvent(100, 100));
      result.current.swipeHandlers.onTouchMove(createTouchEvent(0, 100));
      result.current.swipeHandlers.onTouchEnd();
    });

    expect(onSwipeLeft).toHaveBeenCalled();
  });

  it('does not trigger swipe on small movements', () => {
    const onSwipeRight = vi.fn();
    const { result } = renderHook(() =>
      useSwipeGesture({
        onSwipeRight,
        onSwipeLeft: vi.fn(),
      })
    );

    act(() => {
      result.current.swipeHandlers.onTouchStart(createTouchEvent(0, 100));
      result.current.swipeHandlers.onTouchMove(createTouchEvent(30, 100));
      result.current.swipeHandlers.onTouchEnd();
    });

    expect(onSwipeRight).not.toHaveBeenCalled();
  });

  it('ignores vertical swipes', () => {
    const onSwipeRight = vi.fn();
    const { result } = renderHook(() =>
      useSwipeGesture({
        onSwipeRight,
        onSwipeLeft: vi.fn(),
      })
    );

    // Move mostly vertical
    act(() => {
      result.current.swipeHandlers.onTouchStart(createTouchEvent(100, 0));
      result.current.swipeHandlers.onTouchMove(createTouchEvent(110, 100));
      result.current.swipeHandlers.onTouchEnd();
    });

    expect(onSwipeRight).not.toHaveBeenCalled();
  });

  it('shows preview state during swipe', () => {
    const { result } = renderHook(() =>
      useSwipeGesture({
        onSwipeRight: vi.fn(),
        onSwipeLeft: vi.fn(),
      })
    );

    act(() => {
      result.current.swipeHandlers.onTouchStart(createTouchEvent(0, 100));
      result.current.swipeHandlers.onTouchMove(createTouchEvent(50, 100));
    });

    expect(result.current.swipeOffset).toBeGreaterThan(0);
    expect(result.current.isSwipingRight).toBe(true);
  });

  it('resets state after swipe completes', () => {
    const { result } = renderHook(() =>
      useSwipeGesture({
        onSwipeRight: vi.fn(),
        onSwipeLeft: vi.fn(),
      })
    );

    act(() => {
      result.current.swipeHandlers.onTouchStart(createTouchEvent(0, 100));
      result.current.swipeHandlers.onTouchMove(createTouchEvent(100, 100));
      result.current.swipeHandlers.onTouchEnd();
    });

    expect(result.current.swipeOffset).toBe(0);
    expect(result.current.isSwipingRight).toBe(false);
  });
});
```

Create frontend/src/tests/hooks/useUrlState.test.tsx:
```typescript
import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { BrowserRouter } from 'react-router-dom';
import { useUrlState } from '@/hooks/useUrlState';

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <BrowserRouter>{children}</BrowserRouter>
);

describe('useUrlState', () => {
  it('returns default filters when URL is empty', () => {
    const { result } = renderHook(() => useUrlState(), { wrapper });

    expect(result.current.filters.sort).toBe('newest');
    expect(result.current.filters.page).toBe(1);
    expect(result.current.filters.status).toBeUndefined();
  });

  it('updates URL when filters change', () => {
    const { result } = renderHook(() => useUrlState(), { wrapper });

    act(() => {
      result.current.updateFilters({ status: ['OPEN'] });
    });

    expect(result.current.filters.status).toEqual(['OPEN']);
  });

  it('supports multiple filter values', () => {
    const { result } = renderHook(() => useUrlState(), { wrapper });

    act(() => {
      result.current.updateFilters({
        status: ['OPEN', 'ACKNOWLEDGED'],
        priority: ['HIGH', 'CRITICAL'],
      });
    });

    expect(result.current.filters.status).toEqual(['OPEN', 'ACKNOWLEDGED']);
    expect(result.current.filters.priority).toEqual(['HIGH', 'CRITICAL']);
  });

  it('clears filters when clearFilters called', () => {
    const { result } = renderHook(() => useUrlState(), { wrapper });

    act(() => {
      result.current.updateFilters({ status: ['OPEN'] });
    });

    act(() => {
      result.current.clearFilters();
    });

    expect(result.current.filters.status).toBeUndefined();
  });

  it('resets page to 1 when filters change', () => {
    const { result } = renderHook(() => useUrlState(), { wrapper });

    act(() => {
      result.current.updateFilters({ page: 5 });
    });

    expect(result.current.filters.page).toBe(5);

    act(() => {
      result.current.updateFilters({ status: ['OPEN'], page: 1 });
    });

    expect(result.current.filters.page).toBe(1);
  });
});
```

Run the tests:
```bash
cd frontend && npm test
```

If tests fail due to missing modules, ensure all dependencies are installed and components exist. Fix any import issues.

Add test script verification in CI (update package.json if needed):
```json
{
  "scripts": {
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "test:ci": "vitest run --reporter=verbose"
  }
}
```
  </action>
  <verify>
ls frontend/src/tests/hooks/useSwipeGesture.test.ts
ls frontend/src/tests/hooks/useUrlState.test.tsx
cd frontend && npm test
  </verify>
  <done>
Hook tests for swipe gesture and URL state. Test suite runs and passes. Tests cover component rendering, user interactions, and hook behavior.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npm test` - All tests pass
2. `cd frontend && npm run test:coverage` - View coverage report
3. Verify no test failures in CI environment
4. Check coverage includes IncidentRow, IncidentTimeline, useSwipeGesture
</verification>

<success_criteria>
- [ ] Vitest configured with React Testing Library
- [ ] Test setup mocks socket.io, fetch, and browser APIs
- [ ] IncidentRow tests verify rendering and interactions
- [ ] IncidentTimeline tests verify loading, empty, and populated states
- [ ] IncidentFilters tests verify filter count and clear functionality
- [ ] useSwipeGesture tests verify horizontal detection and callbacks
- [ ] useUrlState tests verify URL synchronization
- [ ] All tests pass with `npm test`
- [ ] No console errors during test runs
</success_criteria>

<output>
After completion, create `.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-11-SUMMARY.md`
</output>

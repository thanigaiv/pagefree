---
phase: 06-incident-management-dashboard
plan: 09
type: execute
wave: 5
depends_on: ["06-07", "06-02"]
files_modified:
  - src/routes/push.routes.ts
  - src/services/push.service.ts
  - frontend/src/lib/push.ts
  - frontend/src/hooks/usePushNotifications.ts
  - frontend/src/sw-push.ts
  - frontend/vite.config.ts
autonomous: true

must_haves:
  truths:
    - "Push notifications reach mobile devices when new incidents occur"
    - "Tapping notification opens incident detail view (deep link)"
    - "User can enable/disable push notifications from profile"
    - "Push token registered with backend on subscription"
  artifacts:
    - path: "src/routes/push.routes.ts"
      provides: "Push subscription API endpoints"
      exports: ["pushRoutes"]
    - path: "frontend/src/lib/push.ts"
      provides: "Push notification utilities"
      exports: ["subscribeToPush"]
    - path: "frontend/src/hooks/usePushNotifications.ts"
      provides: "Push subscription hook"
      exports: ["usePushNotifications"]
  key_links:
    - from: "frontend/src/lib/push.ts"
      to: "Push API"
      via: "serviceWorkerRegistration.pushManager.subscribe"
      pattern: "pushManager.subscribe"
    - from: "src/routes/push.routes.ts"
      to: "src/services/push.service.ts"
      via: "subscription storage"
      pattern: "pushService"
---

<objective>
Implement push notifications with deep linking to incident detail views.

Purpose: Ensure on-call engineers receive alerts even when the app is closed. Per user decisions: push notification tap goes directly to incident detail (deep link), push works on mobile PWA.

Output: Working push notifications with subscription management and deep linking.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-CONTEXT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-RESEARCH.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-07-SUMMARY.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-02-SUMMARY.md

# Existing push infrastructure from Phase 5
@src/services/notification/channels/push.channel.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Backend Push Subscription API</name>
  <files>
    src/routes/push.routes.ts
    src/services/push.service.ts
    src/index.ts
  </files>
  <action>
Create src/services/push.service.ts:
```typescript
import { prisma } from '../config/database.js';
import { logger } from '../config/logger.js';
import crypto from 'crypto';

// Web Push VAPID keys - in production, generate and store securely
const VAPID_PUBLIC_KEY = process.env.VAPID_PUBLIC_KEY || '';
const VAPID_PRIVATE_KEY = process.env.VAPID_PRIVATE_KEY || '';

interface PushSubscription {
  endpoint: string;
  keys: {
    p256dh: string;
    auth: string;
  };
}

class PushService {
  // Get VAPID public key for client
  getVapidPublicKey(): string {
    if (!VAPID_PUBLIC_KEY) {
      logger.warn('VAPID_PUBLIC_KEY not configured');
    }
    return VAPID_PUBLIC_KEY;
  }

  // Store push subscription for user
  async subscribe(
    userId: string,
    subscription: PushSubscription,
    userAgent?: string
  ): Promise<void> {
    // Generate unique ID for this subscription
    const subscriptionId = crypto
      .createHash('sha256')
      .update(subscription.endpoint)
      .digest('hex')
      .slice(0, 32);

    // Store in PushToken table (created in Phase 5)
    await prisma.pushToken.upsert({
      where: { id: subscriptionId },
      create: {
        id: subscriptionId,
        userId,
        token: subscription.endpoint,
        platform: 'WEB',
        deviceInfo: {
          endpoint: subscription.endpoint,
          keys: subscription.keys,
          userAgent,
        },
        isActive: true,
      },
      update: {
        token: subscription.endpoint,
        deviceInfo: {
          endpoint: subscription.endpoint,
          keys: subscription.keys,
          userAgent,
        },
        isActive: true,
        updatedAt: new Date(),
      },
    });

    logger.info({ userId, subscriptionId }, 'Push subscription stored');
  }

  // Remove push subscription
  async unsubscribe(userId: string, endpoint: string): Promise<void> {
    const subscriptionId = crypto
      .createHash('sha256')
      .update(endpoint)
      .digest('hex')
      .slice(0, 32);

    await prisma.pushToken.updateMany({
      where: {
        id: subscriptionId,
        userId,
      },
      data: {
        isActive: false,
        updatedAt: new Date(),
      },
    });

    logger.info({ userId, subscriptionId }, 'Push subscription deactivated');
  }

  // Get user's active push subscriptions
  async getSubscriptions(userId: string) {
    return prisma.pushToken.findMany({
      where: {
        userId,
        platform: 'WEB',
        isActive: true,
      },
      select: {
        id: true,
        createdAt: true,
        updatedAt: true,
      },
    });
  }
}

export const pushService = new PushService();
```

Create src/routes/push.routes.ts:
```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { pushService } from '../services/push.service.js';

const router = Router();

// GET /api/push/vapid-public-key - Get VAPID public key for Push API
router.get('/vapid-public-key', (req: Request, res: Response) => {
  const key = pushService.getVapidPublicKey();

  if (!key) {
    return res.status(503).json({
      error: 'Push notifications not configured',
    });
  }

  return res.json({ publicKey: key });
});

// POST /api/push/subscribe - Store push subscription
router.post('/subscribe', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { subscription } = req.body;
    const userId = (req as any).user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    if (!subscription?.endpoint || !subscription?.keys) {
      return res.status(400).json({ error: 'Invalid subscription' });
    }

    await pushService.subscribe(
      userId,
      subscription,
      req.headers['user-agent']
    );

    return res.status(201).json({ success: true });
  } catch (error) {
    return next(error);
  }
});

// DELETE /api/push/unsubscribe - Remove push subscription
router.delete('/unsubscribe', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { endpoint } = req.body;
    const userId = (req as any).user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    if (!endpoint) {
      return res.status(400).json({ error: 'Endpoint required' });
    }

    await pushService.unsubscribe(userId, endpoint);

    return res.json({ success: true });
  } catch (error) {
    return next(error);
  }
});

// GET /api/push/subscriptions - List user's subscriptions
router.get('/subscriptions', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = (req as any).user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const subscriptions = await pushService.getSubscriptions(userId);

    return res.json({ subscriptions });
  } catch (error) {
    return next(error);
  }
});

export const pushRoutes = router;
```

Update src/index.ts to mount push routes (add after other route mounts):
```typescript
import { pushRoutes } from './routes/push.routes.js';

// ... existing code ...

// Mount push routes
app.use('/api/push', pushRoutes);
```
  </action>
  <verify>
ls src/services/push.service.ts
ls src/routes/push.routes.ts
grep -q "pushRoutes" src/index.ts
npm run build
  </verify>
  <done>
Backend push subscription API created. Endpoints for VAPID key retrieval, subscription storage, and management. Integrates with existing PushToken model from Phase 5.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Frontend Push Utilities and Service Worker Handler</name>
  <files>
    frontend/src/lib/push.ts
    frontend/src/sw-custom.ts
    frontend/vite.config.ts
  </files>
  <action>
Create frontend/src/lib/push.ts:
```typescript
import { apiFetch } from './api';

// Convert base64 URL-safe string to Uint8Array for Push API
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }

  return outputArray;
}

// Check if push notifications are supported
export function isPushSupported(): boolean {
  return 'PushManager' in window && 'serviceWorker' in navigator;
}

// Check current notification permission
export function getNotificationPermission(): NotificationPermission {
  return Notification.permission;
}

// Request notification permission
export async function requestNotificationPermission(): Promise<NotificationPermission> {
  if (!('Notification' in window)) {
    return 'denied';
  }

  return Notification.requestPermission();
}

// Get VAPID public key from backend
async function getVapidPublicKey(): Promise<string | null> {
  try {
    const response = await apiFetch<{ publicKey: string }>('/push/vapid-public-key');
    return response.publicKey;
  } catch (error) {
    console.error('Failed to get VAPID key:', error);
    return null;
  }
}

// Subscribe to push notifications
export async function subscribeToPush(): Promise<boolean> {
  if (!isPushSupported()) {
    console.log('Push notifications not supported');
    return false;
  }

  try {
    // Request permission first
    const permission = await requestNotificationPermission();
    if (permission !== 'granted') {
      console.log('Notification permission denied');
      return false;
    }

    // Get VAPID key
    const vapidPublicKey = await getVapidPublicKey();
    if (!vapidPublicKey) {
      console.log('VAPID key not available');
      return false;
    }

    // Get service worker registration
    const registration = await navigator.serviceWorker.ready;

    // Subscribe to push
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
    });

    // Send subscription to backend
    await apiFetch('/push/subscribe', {
      method: 'POST',
      body: JSON.stringify({ subscription: subscription.toJSON() }),
    });

    console.log('Push subscription successful');
    return true;
  } catch (error) {
    console.error('Push subscription failed:', error);
    return false;
  }
}

// Unsubscribe from push notifications
export async function unsubscribeFromPush(): Promise<boolean> {
  if (!isPushSupported()) {
    return false;
  }

  try {
    const registration = await navigator.serviceWorker.ready;
    const subscription = await registration.pushManager.getSubscription();

    if (!subscription) {
      return true; // Already unsubscribed
    }

    // Notify backend
    await apiFetch('/push/unsubscribe', {
      method: 'DELETE',
      body: JSON.stringify({ endpoint: subscription.endpoint }),
    });

    // Unsubscribe locally
    await subscription.unsubscribe();

    console.log('Push unsubscription successful');
    return true;
  } catch (error) {
    console.error('Push unsubscription failed:', error);
    return false;
  }
}

// Check if currently subscribed
export async function isPushSubscribed(): Promise<boolean> {
  if (!isPushSupported()) {
    return false;
  }

  try {
    const registration = await navigator.serviceWorker.ready;
    const subscription = await registration.pushManager.getSubscription();
    return subscription !== null;
  } catch {
    return false;
  }
}
```

Create frontend/src/sw-custom.ts (custom service worker additions for push handling):
```typescript
/// <reference lib="webworker" />

declare const self: ServiceWorkerGlobalScope;

// Handle push notification received
self.addEventListener('push', (event) => {
  if (!event.data) return;

  const data = event.data.json();

  const options: NotificationOptions = {
    body: data.body || 'New incident',
    icon: '/icons/icon-192.png',
    badge: '/icons/icon-192.png',
    tag: data.incidentId || 'incident',
    data: {
      incidentId: data.incidentId,
      url: data.url || `/incidents/${data.incidentId}`,
    },
    actions: [
      { action: 'view', title: 'View' },
      { action: 'acknowledge', title: 'Acknowledge' },
    ],
    vibrate: [200, 100, 200],
    requireInteraction: data.priority === 'CRITICAL' || data.priority === 'HIGH',
  };

  event.waitUntil(
    self.registration.showNotification(data.title || 'OnCall Alert', options)
  );
});

// Handle notification click (deep link per user decision)
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const data = event.notification.data;
  const url = data?.url || '/incidents';

  // Handle action buttons
  if (event.action === 'acknowledge' && data?.incidentId) {
    // Could call API here, but for simplicity just open the incident
    event.waitUntil(
      clients.openWindow(`/incidents/${data.incidentId}?action=acknowledge`)
    );
    return;
  }

  // Default: open incident detail (per user decision: tap goes to detail)
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((windowClients) => {
      // If app is already open, focus it and navigate
      for (const client of windowClients) {
        if ('focus' in client && 'navigate' in client) {
          client.focus();
          return (client as any).navigate(url);
        }
      }
      // Otherwise, open new window
      return clients.openWindow(url);
    })
  );
});
```

Update frontend/vite.config.ts to include custom service worker code:

In the VitePWA configuration, update the workbox section:
```typescript
workbox: {
  // ... existing runtimeCaching ...

  // Include custom service worker for push handling
  importScripts: ['sw-custom.js'],
},
```

Also update devOptions:
```typescript
devOptions: {
  enabled: true,
  type: 'module',
  navigateFallback: 'index.html',
},
```
  </action>
  <verify>
ls frontend/src/lib/push.ts
ls frontend/src/sw-custom.ts
cd frontend && npm run build
  </verify>
  <done>
Push utilities for subscription management. Custom service worker handles push events and notification clicks with deep linking to incident detail per user decision.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Push Notifications Hook and Settings UI</name>
  <files>
    frontend/src/hooks/usePushNotifications.ts
    frontend/src/components/PushSettings.tsx
    frontend/src/pages/ProfilePage.tsx
  </files>
  <action>
Create frontend/src/hooks/usePushNotifications.ts:
```typescript
import { useState, useEffect, useCallback } from 'react';
import {
  isPushSupported,
  isPushSubscribed,
  subscribeToPush,
  unsubscribeFromPush,
  getNotificationPermission,
} from '@/lib/push';
import { toast } from 'sonner';

interface UsePushNotificationsReturn {
  isSupported: boolean;
  isSubscribed: boolean;
  permission: NotificationPermission;
  isLoading: boolean;
  subscribe: () => Promise<void>;
  unsubscribe: () => Promise<void>;
  toggle: () => Promise<void>;
}

export function usePushNotifications(): UsePushNotificationsReturn {
  const [isSupported] = useState(() => isPushSupported());
  const [isSubscribed, setIsSubscribed] = useState(false);
  const [permission, setPermission] = useState<NotificationPermission>('default');
  const [isLoading, setIsLoading] = useState(false);

  // Check subscription status on mount
  useEffect(() => {
    async function checkStatus() {
      if (!isSupported) return;

      setPermission(getNotificationPermission());
      const subscribed = await isPushSubscribed();
      setIsSubscribed(subscribed);
    }

    checkStatus();
  }, [isSupported]);

  const subscribe = useCallback(async () => {
    if (!isSupported) {
      toast.error('Push notifications not supported on this device');
      return;
    }

    setIsLoading(true);
    try {
      const success = await subscribeToPush();
      if (success) {
        setIsSubscribed(true);
        setPermission('granted');
        toast.success('Push notifications enabled');
      } else {
        toast.error('Failed to enable push notifications');
      }
    } finally {
      setIsLoading(false);
    }
  }, [isSupported]);

  const unsubscribe = useCallback(async () => {
    setIsLoading(true);
    try {
      const success = await unsubscribeFromPush();
      if (success) {
        setIsSubscribed(false);
        toast.success('Push notifications disabled');
      } else {
        toast.error('Failed to disable push notifications');
      }
    } finally {
      setIsLoading(false);
    }
  }, []);

  const toggle = useCallback(async () => {
    if (isSubscribed) {
      await unsubscribe();
    } else {
      await subscribe();
    }
  }, [isSubscribed, subscribe, unsubscribe]);

  return {
    isSupported,
    isSubscribed,
    permission,
    isLoading,
    subscribe,
    unsubscribe,
    toggle,
  };
}
```

Create frontend/src/components/PushSettings.tsx:
```typescript
import { usePushNotifications } from '@/hooks/usePushNotifications';
import { Button } from '@/components/ui/button';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { Bell, BellOff, Loader2, AlertTriangle } from 'lucide-react';

export function PushSettings() {
  const {
    isSupported,
    isSubscribed,
    permission,
    isLoading,
    toggle,
  } = usePushNotifications();

  if (!isSupported) {
    return (
      <div className="flex items-center gap-3 text-muted-foreground">
        <AlertTriangle className="h-5 w-5" />
        <span>Push notifications are not supported on this browser</span>
      </div>
    );
  }

  if (permission === 'denied') {
    return (
      <div className="flex items-center gap-3 text-muted-foreground">
        <BellOff className="h-5 w-5" />
        <div>
          <p>Push notifications are blocked</p>
          <p className="text-sm">
            Enable notifications in your browser settings to receive alerts
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex items-center justify-between">
      <div className="flex items-center gap-3">
        {isSubscribed ? (
          <Bell className="h-5 w-5 text-green-500" />
        ) : (
          <BellOff className="h-5 w-5 text-muted-foreground" />
        )}
        <div>
          <Label htmlFor="push-toggle" className="text-base font-medium">
            Push Notifications
          </Label>
          <p className="text-sm text-muted-foreground">
            {isSubscribed
              ? 'You will receive alerts for new incidents'
              : 'Enable to receive alerts when offline'}
          </p>
        </div>
      </div>

      {isLoading ? (
        <Loader2 className="h-5 w-5 animate-spin" />
      ) : (
        <Switch
          id="push-toggle"
          checked={isSubscribed}
          onCheckedChange={toggle}
        />
      )}
    </div>
  );
}
```

Add shadcn/ui switch:
```bash
cd frontend && npx shadcn@latest add switch
```

Update frontend/src/pages/ProfilePage.tsx to include PushSettings:

Add import:
```typescript
import { PushSettings } from '@/components/PushSettings';
```

Update the Mobile Settings card:
```typescript
<Card>
  <CardHeader>
    <CardTitle className="flex items-center gap-2">
      <Smartphone className="h-5 w-5" />
      Mobile Settings
    </CardTitle>
  </CardHeader>
  <CardContent className="space-y-4">
    <PushSettings />

    <div className="border-t pt-4">
      <p className="text-sm text-muted-foreground">
        Biometric authentication settings coming soon.
      </p>
    </div>
  </CardContent>
</Card>
```
  </action>
  <verify>
ls frontend/src/hooks/usePushNotifications.ts
ls frontend/src/components/PushSettings.tsx
cd frontend && npm run build
  </verify>
  <done>
Push notifications hook with subscription management. PushSettings component with toggle switch in Profile page. Handles permission denied and unsupported browser states.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` - Both backend and frontend compile
2. Start backend and frontend
3. Go to Profile page
4. Toggle push notifications on
5. Verify browser permission prompt appears
6. Grant permission - verify subscription stored
7. Manually trigger a test notification from backend
8. Verify notification appears and click opens incident detail
</verification>

<success_criteria>
- [ ] Backend VAPID key endpoint returns public key
- [ ] Push subscription stored in database
- [ ] Frontend can subscribe/unsubscribe to push
- [ ] Service worker handles push events
- [ ] Notification click opens incident detail (deep link)
- [ ] PushSettings toggle in Profile page
- [ ] Handles blocked notification permission gracefully
- [ ] Works when browser is closed (via service worker)
</success_criteria>

<output>
After completion, create `.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-09-SUMMARY.md`
</output>

---
phase: 06-incident-management-dashboard
plan: 10
type: execute
wave: 5
depends_on: ["06-03", "06-07"]
files_modified:
  - src/routes/preferences.routes.ts
  - src/services/preferences.service.ts
  - frontend/src/hooks/usePreferences.ts
  - frontend/src/components/FilterPresets.tsx
  - frontend/src/lib/webauthn.ts
  - frontend/src/components/BiometricSettings.tsx
  - frontend/src/pages/ProfilePage.tsx
autonomous: true

must_haves:
  truths:
    - "User's filter preferences persist across sessions"
    - "Dashboard loads with user's saved filter preferences"
    - "User can enable biometric unlock for PWA"
    - "Biometric auth works on supported devices"
  artifacts:
    - path: "src/routes/preferences.routes.ts"
      provides: "User preferences API"
      exports: ["preferencesRoutes"]
    - path: "frontend/src/hooks/usePreferences.ts"
      provides: "Preferences management hook"
      exports: ["usePreferences"]
    - path: "frontend/src/lib/webauthn.ts"
      provides: "WebAuthn biometric utilities"
      exports: ["registerBiometric"]
  key_links:
    - from: "frontend/src/hooks/usePreferences.ts"
      to: "/api/preferences"
      via: "fetch request"
      pattern: "apiFetch.*preferences"
    - from: "frontend/src/lib/webauthn.ts"
      to: "Web Authentication API"
      via: "navigator.credentials"
      pattern: "navigator.credentials"
---

<objective>
Implement user preferences storage and biometric authentication for PWA.

Purpose: Personalize the dashboard experience by remembering filter preferences and enabling quick biometric unlock. Per user decisions: save preferences to user profile, optional biometric unlock.

Output: Persistent preferences and optional biometric authentication.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-CONTEXT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-RESEARCH.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-03-SUMMARY.md

# User model
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Backend Preferences API</name>
  <files>
    src/routes/preferences.routes.ts
    src/services/preferences.service.ts
    src/index.ts
  </files>
  <action>
Create src/services/preferences.service.ts:
```typescript
import { prisma } from '../config/database.js';
import { logger } from '../config/logger.js';

interface DashboardPreferences {
  defaultFilters?: {
    status?: string[];
    priority?: string[];
    teamId?: string;
  };
  defaultSort?: string;
  pageSize?: number;
  expandedView?: boolean;
}

interface NotificationPreferences {
  pushEnabled?: boolean;
  emailEnabled?: boolean;
  smsEnabled?: boolean;
  quietHoursStart?: string;
  quietHoursEnd?: string;
}

interface UserPreferences {
  dashboard?: DashboardPreferences;
  notifications?: NotificationPreferences;
}

class PreferencesService {
  // Get user preferences
  async get(userId: string): Promise<UserPreferences> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { preferences: true },
    });

    // Return stored preferences or empty object
    return (user?.preferences as UserPreferences) || {};
  }

  // Update user preferences (merge with existing)
  async update(userId: string, preferences: Partial<UserPreferences>): Promise<UserPreferences> {
    const existing = await this.get(userId);

    // Deep merge preferences
    const merged: UserPreferences = {
      dashboard: {
        ...existing.dashboard,
        ...preferences.dashboard,
      },
      notifications: {
        ...existing.notifications,
        ...preferences.notifications,
      },
    };

    await prisma.user.update({
      where: { id: userId },
      data: { preferences: merged as any },
    });

    logger.debug({ userId }, 'User preferences updated');

    return merged;
  }

  // Set dashboard preferences
  async setDashboardPreferences(
    userId: string,
    dashboard: DashboardPreferences
  ): Promise<void> {
    await this.update(userId, { dashboard });
  }

  // Get dashboard preferences
  async getDashboardPreferences(userId: string): Promise<DashboardPreferences> {
    const prefs = await this.get(userId);
    return prefs.dashboard || {};
  }
}

export const preferencesService = new PreferencesService();
```

Create src/routes/preferences.routes.ts:
```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { preferencesService } from '../services/preferences.service.js';

const router = Router();

// GET /api/preferences - Get all user preferences
router.get('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = (req as any).user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const preferences = await preferencesService.get(userId);
    return res.json({ preferences });
  } catch (error) {
    return next(error);
  }
});

// PATCH /api/preferences - Update user preferences
router.patch('/', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = (req as any).user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const { dashboard, notifications } = req.body;

    const updated = await preferencesService.update(userId, {
      dashboard,
      notifications,
    });

    return res.json({ preferences: updated });
  } catch (error) {
    return next(error);
  }
});

// GET /api/preferences/dashboard - Get dashboard preferences only
router.get('/dashboard', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = (req as any).user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const preferences = await preferencesService.getDashboardPreferences(userId);
    return res.json({ preferences });
  } catch (error) {
    return next(error);
  }
});

// PUT /api/preferences/dashboard - Set dashboard preferences
router.put('/dashboard', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const userId = (req as any).user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    await preferencesService.setDashboardPreferences(userId, req.body);
    return res.json({ success: true });
  } catch (error) {
    return next(error);
  }
});

export const preferencesRoutes = router;
```

Update src/index.ts to mount preferences routes:
```typescript
import { preferencesRoutes } from './routes/preferences.routes.js';

// ... existing code ...

app.use('/api/preferences', preferencesRoutes);
```

Check if User model has preferences field. If not, we need to add migration:

If schema.prisma User model doesn't have preferences, add:
```prisma
model User {
  // ... existing fields ...
  preferences Json?
}
```

Then run: `npx prisma db push`
  </action>
  <verify>
ls src/services/preferences.service.ts
ls src/routes/preferences.routes.ts
grep -q "preferencesRoutes" src/index.ts
npm run build
  </verify>
  <done>
Backend preferences API created. Endpoints for getting and updating user preferences including dashboard filters and notification settings.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Frontend Preferences Hook and Filter Presets</name>
  <files>
    frontend/src/hooks/usePreferences.ts
    frontend/src/components/FilterPresets.tsx
    frontend/src/pages/DashboardPage.tsx
  </files>
  <action>
Create frontend/src/hooks/usePreferences.ts:
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiFetch } from '@/lib/api';
import type { IncidentFilters } from './useUrlState';
import { toast } from 'sonner';

interface DashboardPreferences {
  defaultFilters?: {
    status?: string[];
    priority?: string[];
    teamId?: string;
  };
  defaultSort?: string;
  pageSize?: number;
}

interface UserPreferences {
  dashboard?: DashboardPreferences;
}

// Fetch user preferences
export function usePreferences() {
  return useQuery({
    queryKey: ['preferences'],
    queryFn: async () => {
      const response = await apiFetch<{ preferences: UserPreferences }>('/preferences');
      return response.preferences;
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: false, // Don't retry if not authenticated
  });
}

// Update preferences mutation
export function useUpdatePreferences() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (preferences: Partial<UserPreferences>) => {
      const response = await apiFetch<{ preferences: UserPreferences }>(
        '/preferences',
        {
          method: 'PATCH',
          body: JSON.stringify(preferences),
        }
      );
      return response.preferences;
    },
    onSuccess: (data) => {
      queryClient.setQueryData(['preferences'], data);
      toast.success('Preferences saved');
    },
    onError: (error) => {
      toast.error(`Failed to save preferences: ${error.message}`);
    },
  });
}

// Save current filters as default
export function useSaveFiltersAsDefault() {
  const updatePreferences = useUpdatePreferences();

  return (filters: IncidentFilters) => {
    updatePreferences.mutate({
      dashboard: {
        defaultFilters: {
          status: filters.status,
          priority: filters.priority,
          teamId: filters.teamId,
        },
        defaultSort: filters.sort,
      },
    });
  };
}

// Get default filters from preferences
export function useDefaultFilters(): IncidentFilters | null {
  const { data: preferences } = usePreferences();

  if (!preferences?.dashboard?.defaultFilters) {
    return null;
  }

  return {
    status: preferences.dashboard.defaultFilters.status,
    priority: preferences.dashboard.defaultFilters.priority,
    teamId: preferences.dashboard.defaultFilters.teamId,
    sort: preferences.dashboard.defaultSort,
  };
}
```

Create frontend/src/components/FilterPresets.tsx:
```typescript
import { usePreferences, useSaveFiltersAsDefault } from '@/hooks/usePreferences';
import type { IncidentFilters } from '@/hooks/useUrlState';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Save, RotateCcw, ChevronDown } from 'lucide-react';
import { toast } from 'sonner';

interface FilterPresetsProps {
  currentFilters: IncidentFilters;
  onApplyPreset: (filters: Partial<IncidentFilters>) => void;
  onClearFilters: () => void;
}

// Predefined quick filters
const QUICK_FILTERS = [
  {
    name: 'Active Incidents',
    filters: { status: ['OPEN', 'ACKNOWLEDGED'] },
  },
  {
    name: 'Critical Only',
    filters: { status: ['OPEN', 'ACKNOWLEDGED'], priority: ['CRITICAL', 'HIGH'] },
  },
  {
    name: 'Needs Attention',
    filters: { status: ['OPEN'] },
  },
  {
    name: 'Recently Resolved',
    filters: { status: ['RESOLVED'] },
  },
];

export function FilterPresets({
  currentFilters,
  onApplyPreset,
  onClearFilters,
}: FilterPresetsProps) {
  const { data: preferences } = usePreferences();
  const saveAsDefault = useSaveFiltersAsDefault();

  const handleSaveAsDefault = () => {
    saveAsDefault(currentFilters);
  };

  const handleApplyDefault = () => {
    if (preferences?.dashboard?.defaultFilters) {
      onApplyPreset({
        status: preferences.dashboard.defaultFilters.status,
        priority: preferences.dashboard.defaultFilters.priority,
        teamId: preferences.dashboard.defaultFilters.teamId,
        sort: preferences.dashboard.defaultSort,
        page: 1,
      });
      toast.info('Applied saved filters');
    }
  };

  const hasDefaultFilters = !!preferences?.dashboard?.defaultFilters;

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm">
          Presets
          <ChevronDown className="h-4 w-4 ml-1" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="start" className="w-48">
        {/* Quick filters */}
        {QUICK_FILTERS.map((preset) => (
          <DropdownMenuItem
            key={preset.name}
            onClick={() => onApplyPreset({ ...preset.filters, page: 1 })}
          >
            {preset.name}
          </DropdownMenuItem>
        ))}

        <DropdownMenuSeparator />

        {/* Saved default */}
        {hasDefaultFilters && (
          <DropdownMenuItem onClick={handleApplyDefault}>
            <RotateCcw className="h-4 w-4 mr-2" />
            My Saved Filters
          </DropdownMenuItem>
        )}

        {/* Save current */}
        <DropdownMenuItem onClick={handleSaveAsDefault}>
          <Save className="h-4 w-4 mr-2" />
          Save Current as Default
        </DropdownMenuItem>

        <DropdownMenuSeparator />

        {/* Clear */}
        <DropdownMenuItem onClick={onClearFilters}>
          Clear All Filters
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
```

Add shadcn/ui dropdown-menu:
```bash
cd frontend && npx shadcn@latest add dropdown-menu
```

Update frontend/src/pages/DashboardPage.tsx to include FilterPresets:

Add imports:
```typescript
import { FilterPresets } from '@/components/FilterPresets';
import { useDefaultFilters, usePreferences } from '@/hooks/usePreferences';
```

Add in component:
```typescript
const defaultFilters = useDefaultFilters();
```

In the filters section, add FilterPresets:
```typescript
<div className="flex items-center gap-2 mb-4">
  <IncidentFilters
    filters={filters}
    onUpdateFilters={updateFilters}
    onClearFilters={clearFilters}
  />
  <FilterPresets
    currentFilters={filters}
    onApplyPreset={updateFilters}
    onClearFilters={clearFilters}
  />
</div>
```

Apply default filters on mount if URL has no filters:
```typescript
useEffect(() => {
  // Apply default filters if URL has no filters and user has preferences
  const hasUrlFilters = filters.status?.length || filters.priority?.length;

  if (!hasUrlFilters && defaultFilters) {
    updateFilters(defaultFilters);
  }
}, [defaultFilters]); // Only run when default filters load
```
  </action>
  <verify>
ls frontend/src/hooks/usePreferences.ts
ls frontend/src/components/FilterPresets.tsx
cd frontend && npm run build
  </verify>
  <done>
Preferences hook fetches and updates user preferences. FilterPresets component with quick filters and ability to save current filters as default. Dashboard loads with saved preferences.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create WebAuthn Biometric Authentication</name>
  <files>
    frontend/src/lib/webauthn.ts
    frontend/src/hooks/useBiometricAuth.ts
    frontend/src/components/BiometricSettings.tsx
    frontend/src/pages/ProfilePage.tsx
    src/routes/auth.routes.ts
  </files>
  <action>
Create frontend/src/lib/webauthn.ts (per RESEARCH.md pattern):
```typescript
// WebAuthn biometric authentication utilities

// Check if WebAuthn is supported
export function isWebAuthnSupported(): boolean {
  return (
    typeof window !== 'undefined' &&
    !!window.PublicKeyCredential &&
    typeof window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable === 'function'
  );
}

// Check if platform authenticator (Face ID, Touch ID, Windows Hello) is available
export async function isPlatformAuthenticatorAvailable(): Promise<boolean> {
  if (!isWebAuthnSupported()) return false;

  try {
    return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
  } catch {
    return false;
  }
}

// Helper to convert base64 to ArrayBuffer
function base64ToArrayBuffer(base64: string): ArrayBuffer {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}

// Helper to convert ArrayBuffer to base64
function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// Register biometric credential
export async function registerBiometric(
  userId: string,
  userName: string
): Promise<boolean> {
  if (!isWebAuthnSupported()) {
    throw new Error('WebAuthn not supported');
  }

  try {
    // Get challenge from server
    const challengeResponse = await fetch('/api/auth/webauthn/register-challenge', {
      method: 'POST',
      credentials: 'include',
    });

    if (!challengeResponse.ok) {
      throw new Error('Failed to get registration challenge');
    }

    const { challenge, rpId, rpName } = await challengeResponse.json();

    // Create credential using platform authenticator
    const credential = await navigator.credentials.create({
      publicKey: {
        challenge: base64ToArrayBuffer(challenge),
        rp: {
          id: rpId,
          name: rpName,
        },
        user: {
          id: new TextEncoder().encode(userId),
          name: userName,
          displayName: userName,
        },
        pubKeyCredParams: [
          { alg: -7, type: 'public-key' }, // ES256
          { alg: -257, type: 'public-key' }, // RS256
        ],
        authenticatorSelection: {
          authenticatorAttachment: 'platform', // Built-in biometric
          userVerification: 'required',
          residentKey: 'preferred',
        },
        timeout: 60000,
        attestation: 'none',
      },
    }) as PublicKeyCredential;

    if (!credential) {
      throw new Error('Credential creation failed');
    }

    const attestationResponse = credential.response as AuthenticatorAttestationResponse;

    // Send credential to server for storage
    const registerResponse = await fetch('/api/auth/webauthn/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({
        credential: {
          id: credential.id,
          rawId: arrayBufferToBase64(credential.rawId),
          response: {
            attestationObject: arrayBufferToBase64(attestationResponse.attestationObject),
            clientDataJSON: arrayBufferToBase64(attestationResponse.clientDataJSON),
          },
          type: credential.type,
        },
      }),
    });

    return registerResponse.ok;
  } catch (error) {
    console.error('Biometric registration failed:', error);
    throw error;
  }
}

// Authenticate with biometric
export async function authenticateBiometric(): Promise<boolean> {
  if (!isWebAuthnSupported()) {
    return false;
  }

  try {
    // Get challenge from server
    const challengeResponse = await fetch('/api/auth/webauthn/login-challenge', {
      credentials: 'include',
    });

    if (!challengeResponse.ok) {
      return false;
    }

    const { challenge, rpId, allowCredentials } = await challengeResponse.json();

    // Get credential using platform authenticator
    const credential = await navigator.credentials.get({
      publicKey: {
        challenge: base64ToArrayBuffer(challenge),
        rpId,
        timeout: 60000,
        userVerification: 'required',
        allowCredentials: allowCredentials?.map((cred: any) => ({
          id: base64ToArrayBuffer(cred.id),
          type: 'public-key',
        })),
      },
    }) as PublicKeyCredential;

    if (!credential) {
      return false;
    }

    const assertionResponse = credential.response as AuthenticatorAssertionResponse;

    // Verify with server
    const verifyResponse = await fetch('/api/auth/webauthn/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({
        credential: {
          id: credential.id,
          rawId: arrayBufferToBase64(credential.rawId),
          response: {
            authenticatorData: arrayBufferToBase64(assertionResponse.authenticatorData),
            clientDataJSON: arrayBufferToBase64(assertionResponse.clientDataJSON),
            signature: arrayBufferToBase64(assertionResponse.signature),
            userHandle: assertionResponse.userHandle
              ? arrayBufferToBase64(assertionResponse.userHandle)
              : null,
          },
          type: credential.type,
        },
      }),
    });

    return verifyResponse.ok;
  } catch (error) {
    console.error('Biometric authentication failed:', error);
    return false;
  }
}

// Check if user has registered biometric credentials
export async function hasBiometricCredential(): Promise<boolean> {
  try {
    const response = await fetch('/api/auth/webauthn/credentials', {
      credentials: 'include',
    });

    if (!response.ok) return false;

    const { credentials } = await response.json();
    return credentials?.length > 0;
  } catch {
    return false;
  }
}
```

Create frontend/src/hooks/useBiometricAuth.ts:
```typescript
import { useState, useEffect, useCallback } from 'react';
import {
  isWebAuthnSupported,
  isPlatformAuthenticatorAvailable,
  registerBiometric,
  hasBiometricCredential,
} from '@/lib/webauthn';
import { toast } from 'sonner';

interface UseBiometricAuthReturn {
  isSupported: boolean;
  isAvailable: boolean;
  isRegistered: boolean;
  isLoading: boolean;
  register: () => Promise<boolean>;
  checkStatus: () => Promise<void>;
}

export function useBiometricAuth(): UseBiometricAuthReturn {
  const [isSupported] = useState(() => isWebAuthnSupported());
  const [isAvailable, setIsAvailable] = useState(false);
  const [isRegistered, setIsRegistered] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const checkStatus = useCallback(async () => {
    if (!isSupported) return;

    setIsLoading(true);
    try {
      const available = await isPlatformAuthenticatorAvailable();
      setIsAvailable(available);

      if (available) {
        const registered = await hasBiometricCredential();
        setIsRegistered(registered);
      }
    } finally {
      setIsLoading(false);
    }
  }, [isSupported]);

  useEffect(() => {
    checkStatus();
  }, [checkStatus]);

  const register = useCallback(async (): Promise<boolean> => {
    if (!isSupported || !isAvailable) {
      toast.error('Biometric authentication not available');
      return false;
    }

    setIsLoading(true);
    try {
      // Get current user info (would come from auth context in production)
      const userResponse = await fetch('/api/auth/me', { credentials: 'include' });
      if (!userResponse.ok) {
        toast.error('Please log in first');
        return false;
      }

      const { user } = await userResponse.json();

      const success = await registerBiometric(user.id, user.email);

      if (success) {
        setIsRegistered(true);
        toast.success('Biometric authentication enabled');
        return true;
      } else {
        toast.error('Failed to enable biometric authentication');
        return false;
      }
    } catch (error) {
      toast.error(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [isSupported, isAvailable]);

  return {
    isSupported,
    isAvailable,
    isRegistered,
    isLoading,
    register,
    checkStatus,
  };
}
```

Create frontend/src/components/BiometricSettings.tsx:
```typescript
import { useBiometricAuth } from '@/hooks/useBiometricAuth';
import { Button } from '@/components/ui/button';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { Fingerprint, Loader2, AlertTriangle, CheckCircle } from 'lucide-react';

export function BiometricSettings() {
  const {
    isSupported,
    isAvailable,
    isRegistered,
    isLoading,
    register,
  } = useBiometricAuth();

  if (!isSupported) {
    return (
      <div className="flex items-center gap-3 text-muted-foreground">
        <AlertTriangle className="h-5 w-5" />
        <span>Biometric authentication is not supported on this device</span>
      </div>
    );
  }

  if (!isAvailable) {
    return (
      <div className="flex items-center gap-3 text-muted-foreground">
        <AlertTriangle className="h-5 w-5" />
        <div>
          <p>No biometric authenticator found</p>
          <p className="text-sm">
            Set up Face ID, Touch ID, or Windows Hello to use this feature
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex items-center justify-between">
      <div className="flex items-center gap-3">
        {isRegistered ? (
          <CheckCircle className="h-5 w-5 text-green-500" />
        ) : (
          <Fingerprint className="h-5 w-5 text-muted-foreground" />
        )}
        <div>
          <Label className="text-base font-medium">
            Biometric Unlock
          </Label>
          <p className="text-sm text-muted-foreground">
            {isRegistered
              ? 'Use Face ID, Touch ID, or fingerprint to unlock'
              : 'Quick access with biometric authentication'}
          </p>
        </div>
      </div>

      {isLoading ? (
        <Loader2 className="h-5 w-5 animate-spin" />
      ) : isRegistered ? (
        <Switch checked disabled />
      ) : (
        <Button size="sm" onClick={register}>
          Enable
        </Button>
      )}
    </div>
  );
}
```

Update frontend/src/pages/ProfilePage.tsx to include BiometricSettings:

Add import:
```typescript
import { BiometricSettings } from '@/components/BiometricSettings';
```

Update Mobile Settings card:
```typescript
<CardContent className="space-y-6">
  <PushSettings />

  <div className="border-t pt-4">
    <BiometricSettings />
  </div>
</CardContent>
```

Note: Backend WebAuthn endpoints would need to be implemented in src/routes/auth.routes.ts. For this plan, add placeholder endpoints that return mock data. Full WebAuthn implementation is complex and may be deferred:

Add to src/routes/auth.routes.ts:
```typescript
// WebAuthn placeholder endpoints (full implementation deferred)
router.post('/webauthn/register-challenge', (req: Request, res: Response) => {
  // In production: Generate and store challenge
  res.json({
    challenge: Buffer.from(crypto.randomUUID()).toString('base64'),
    rpId: process.env.WEBAUTHN_RP_ID || 'localhost',
    rpName: 'OnCall Platform',
  });
});

router.post('/webauthn/register', (req: Request, res: Response) => {
  // In production: Verify and store credential
  res.json({ success: true });
});

router.get('/webauthn/login-challenge', (req: Request, res: Response) => {
  // In production: Generate challenge, look up user credentials
  res.json({
    challenge: Buffer.from(crypto.randomUUID()).toString('base64'),
    rpId: process.env.WEBAUTHN_RP_ID || 'localhost',
    allowCredentials: [],
  });
});

router.post('/webauthn/login', (req: Request, res: Response) => {
  // In production: Verify assertion
  res.json({ success: true });
});

router.get('/webauthn/credentials', (req: Request, res: Response) => {
  // In production: Return user's registered credentials
  res.json({ credentials: [] });
});
```
  </action>
  <verify>
ls frontend/src/lib/webauthn.ts
ls frontend/src/hooks/useBiometricAuth.ts
ls frontend/src/components/BiometricSettings.tsx
cd frontend && npm run build
  </verify>
  <done>
WebAuthn utilities for biometric registration and authentication. BiometricSettings component in Profile page. Backend placeholder endpoints for WebAuthn flow.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` - Both backend and frontend compile
2. Start backend and frontend
3. Go to Dashboard, set some filters
4. Click "Presets" -> "Save Current as Default"
5. Refresh page - verify saved filters are applied
6. Go to Profile -> Mobile Settings
7. Verify Biometric Settings shows device capability status
8. On supported device, test biometric enrollment
</verification>

<success_criteria>
- [ ] Backend preferences API stores/retrieves user preferences
- [ ] Dashboard loads with user's saved filter preferences
- [ ] "Save Current as Default" persists filters
- [ ] Quick filter presets work (Active, Critical Only, etc.)
- [ ] WebAuthn library detects platform authenticator availability
- [ ] BiometricSettings shows appropriate status message
- [ ] On supported devices, biometric registration flow works
- [ ] Profile page shows both push and biometric settings
</success_criteria>

<output>
After completion, create `.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-10-SUMMARY.md`
</output>

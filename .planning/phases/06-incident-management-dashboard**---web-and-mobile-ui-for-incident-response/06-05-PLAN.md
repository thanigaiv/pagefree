---
phase: 06-incident-management-dashboard
plan: 05
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - frontend/src/lib/socket.ts
  - frontend/src/hooks/useWebSocket.ts
  - frontend/src/hooks/useIncidentMutations.ts
  - frontend/src/components/IncidentActions.tsx
  - frontend/src/components/BulkActions.tsx
  - frontend/src/components/ConnectionStatus.tsx
  - frontend/src/pages/DashboardPage.tsx
autonomous: true

must_haves:
  truths:
    - "UI updates instantly when incident status changes (via WebSocket)"
    - "User can acknowledge incident with optimistic update"
    - "User can resolve incident with confirmation dialog"
    - "Multi-user updates show toast notification"
    - "Connection status indicator shows when disconnected"
    - "Bulk acknowledge/resolve works for selected incidents"
  artifacts:
    - path: "frontend/src/lib/socket.ts"
      provides: "Socket.io client singleton"
      contains: "socket.io-client"
    - path: "frontend/src/hooks/useWebSocket.ts"
      provides: "WebSocket connection hook with TanStack Query sync"
      exports: ["useWebSocket"]
    - path: "frontend/src/hooks/useIncidentMutations.ts"
      provides: "Optimistic mutation hooks"
      exports: ["useAcknowledgeIncident", "useResolveIncident"]
  key_links:
    - from: "frontend/src/hooks/useWebSocket.ts"
      to: "frontend/src/lib/queryClient.ts"
      via: "queryClient invalidation"
      pattern: "queryClient.invalidateQueries"
    - from: "frontend/src/hooks/useIncidentMutations.ts"
      to: "/api/incidents/:id/acknowledge"
      via: "POST mutation"
      pattern: "apiFetch.*acknowledge"
---

<objective>
Implement real-time WebSocket updates and optimistic incident actions.

Purpose: Enable instant UI updates when incidents change anywhere in the system. Per user decisions: WebSockets (not polling), optimistic updates for acknowledge, confirmation for resolve, toast notifications for multi-user updates.

Output: Real-time dashboard with instant actions and connection status.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-CONTEXT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-RESEARCH.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-02-SUMMARY.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-03-SUMMARY.md

# Socket types from backend
@src/types/socket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Socket.io Client and WebSocket Hook</name>
  <files>
    frontend/src/lib/socket.ts
    frontend/src/types/socket.ts
    frontend/src/hooks/useWebSocket.ts
    frontend/src/components/ConnectionStatus.tsx
  </files>
  <action>
Install socket.io-client:
```bash
cd frontend && npm install socket.io-client
```

Create frontend/src/types/socket.ts (mirror backend types):
```typescript
// Mirror backend socket types for type safety
export interface ServerToClientEvents {
  'incident:created': (incident: IncidentBroadcast) => void;
  'incident:updated': (incident: IncidentBroadcast) => void;
  'incident:acknowledged': (data: IncidentAckData) => void;
  'incident:resolved': (data: IncidentResolveData) => void;
  'incident:reassigned': (data: IncidentReassignData) => void;
  'incident:note_added': (data: IncidentNoteData) => void;
  'authenticated': () => void;
  'auth_error': (message: string) => void;
}

export interface ClientToServerEvents {
  'subscribe:incidents': (filters: { teamId?: string }) => void;
  'unsubscribe:incidents': () => void;
  'ping': () => void;
}

export interface IncidentBroadcast {
  id: string;
  fingerprint: string;
  status: string;
  priority: string;
  title: string;
  teamId: string;
  team: { id: string; name: string };
  assignedUserId?: string;
  assignedUser?: { id: string; firstName: string; lastName: string };
  createdAt: string;
  acknowledgedAt?: string;
  resolvedAt?: string;
}

export interface IncidentAckData {
  incidentId: string;
  userId: string;
  user: { id: string; firstName: string; lastName: string };
  acknowledgedAt: string;
}

export interface IncidentResolveData {
  incidentId: string;
  userId: string;
  user: { id: string; firstName: string; lastName: string };
  resolvedAt: string;
  resolutionNote?: string;
}

export interface IncidentReassignData {
  incidentId: string;
  fromUserId: string | null;
  toUserId: string;
  toUser: { id: string; firstName: string; lastName: string };
  reason?: string;
}

export interface IncidentNoteData {
  incidentId: string;
  note: {
    id: string;
    content: string;
    userId: string;
    user: { firstName: string; lastName: string };
    createdAt: string;
  };
}
```

Create frontend/src/lib/socket.ts (per RESEARCH.md pattern):
```typescript
import { io, Socket } from 'socket.io-client';
import type { ServerToClientEvents, ClientToServerEvents } from '@/types/socket';

// Socket.io client singleton
export const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io(
  import.meta.env.VITE_API_URL || 'http://localhost:3000',
  {
    autoConnect: false, // Connect manually after auth check
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionDelayMax: 5000,
    reconnectionAttempts: Infinity,
    auth: (cb) => {
      // Send session cookie for auth
      // In production, could also send JWT token
      cb({ token: 'session' });
    },
    withCredentials: true,
  }
);

export function connectSocket() {
  if (!socket.connected) {
    socket.connect();
  }
}

export function disconnectSocket() {
  if (socket.connected) {
    socket.disconnect();
  }
}
```

Create frontend/src/hooks/useWebSocket.ts:
```typescript
import { useEffect, useState, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { socket, connectSocket } from '@/lib/socket';
import { toast } from 'sonner';

export type ConnectionState = 'connected' | 'disconnected' | 'connecting' | 'error';

export function useWebSocket() {
  const queryClient = useQueryClient();
  const [connectionState, setConnectionState] = useState<ConnectionState>('disconnected');
  const [reconnectAttempt, setReconnectAttempt] = useState(0);

  useEffect(() => {
    // Connect on mount
    setConnectionState('connecting');
    connectSocket();

    // Connection event handlers
    socket.on('connect', () => {
      console.log('WebSocket connected');
      setConnectionState('connected');
      setReconnectAttempt(0);

      // Subscribe to all incidents
      socket.emit('subscribe:incidents', {});
    });

    socket.on('disconnect', (reason) => {
      console.log('WebSocket disconnected:', reason);
      setConnectionState('disconnected');

      if (reason === 'io server disconnect') {
        // Server kicked us, try to reconnect
        socket.connect();
      }
    });

    socket.on('connect_error', (error) => {
      console.error('WebSocket connection error:', error);
      setConnectionState('error');
    });

    socket.io.on('reconnect_attempt', (attempt) => {
      setConnectionState('connecting');
      setReconnectAttempt(attempt);
    });

    socket.io.on('reconnect', () => {
      toast.success('Connection restored');
    });

    socket.io.on('reconnect_failed', () => {
      setConnectionState('error');
      toast.error('Connection failed. Please refresh the page.');
    });

    // Incident event handlers - update TanStack Query cache
    socket.on('incident:created', (incident) => {
      // Invalidate list to refetch with new incident
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
      toast.info(`New incident: ${incident.title || incident.fingerprint}`);
    });

    socket.on('incident:acknowledged', (data) => {
      // Update specific incident in cache
      queryClient.invalidateQueries({ queryKey: ['incidents', data.incidentId] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });

      // Show toast for multi-user awareness (per user decision)
      toast.success(
        `${data.user.firstName} ${data.user.lastName} acknowledged incident`
      );
    });

    socket.on('incident:resolved', (data) => {
      queryClient.invalidateQueries({ queryKey: ['incidents', data.incidentId] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });

      toast.success(
        `${data.user.firstName} ${data.user.lastName} resolved incident`
      );
    });

    socket.on('incident:reassigned', (data) => {
      queryClient.invalidateQueries({ queryKey: ['incidents', data.incidentId] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });

      toast.info(
        `Incident reassigned to ${data.toUser.firstName} ${data.toUser.lastName}`
      );
    });

    socket.on('incident:note_added', (data) => {
      queryClient.invalidateQueries({
        queryKey: ['incidents', data.incidentId, 'timeline'],
      });

      toast.info(`${data.note.user.firstName} added a note`);
    });

    socket.on('incident:updated', (incident) => {
      queryClient.invalidateQueries({ queryKey: ['incidents', incident.id] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
    });

    // Cleanup
    return () => {
      socket.off('connect');
      socket.off('disconnect');
      socket.off('connect_error');
      socket.off('incident:created');
      socket.off('incident:acknowledged');
      socket.off('incident:resolved');
      socket.off('incident:reassigned');
      socket.off('incident:note_added');
      socket.off('incident:updated');
      socket.io.off('reconnect_attempt');
      socket.io.off('reconnect');
      socket.io.off('reconnect_failed');
      socket.disconnect();
    };
  }, [queryClient]);

  return { connectionState, reconnectAttempt };
}
```

Create frontend/src/components/ConnectionStatus.tsx:
```typescript
import type { ConnectionState } from '@/hooks/useWebSocket';
import { cn } from '@/lib/utils';
import { Wifi, WifiOff, Loader2 } from 'lucide-react';

interface ConnectionStatusProps {
  state: ConnectionState;
  reconnectAttempt?: number;
}

export function ConnectionStatus({ state, reconnectAttempt }: ConnectionStatusProps) {
  // Don't show anything when connected (per discretion recommendation)
  if (state === 'connected') return null;

  return (
    <div
      className={cn(
        'fixed top-0 left-0 right-0 py-2 px-4 text-sm text-center z-50',
        state === 'connecting' && 'bg-yellow-100 text-yellow-800',
        state === 'disconnected' && 'bg-yellow-100 text-yellow-800',
        state === 'error' && 'bg-red-100 text-red-800'
      )}
    >
      <div className="flex items-center justify-center gap-2">
        {state === 'connecting' && (
          <>
            <Loader2 className="h-4 w-4 animate-spin" />
            <span>
              Reconnecting...
              {reconnectAttempt ? ` (attempt ${reconnectAttempt})` : ''}
            </span>
          </>
        )}
        {state === 'disconnected' && (
          <>
            <WifiOff className="h-4 w-4" />
            <span>Connection lost. Reconnecting...</span>
          </>
        )}
        {state === 'error' && (
          <>
            <WifiOff className="h-4 w-4" />
            <span>Connection failed. Please refresh the page.</span>
          </>
        )}
      </div>
    </div>
  );
}
```
  </action>
  <verify>
grep -q "socket.io-client" frontend/package.json
ls frontend/src/lib/socket.ts
ls frontend/src/hooks/useWebSocket.ts
cd frontend && npm run build
  </verify>
  <done>
Socket.io client configured with reconnection. WebSocket hook syncs events with TanStack Query cache. Connection status banner shows when disconnected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Optimistic Mutation Hooks for Incident Actions</name>
  <files>
    frontend/src/hooks/useIncidentMutations.ts
  </files>
  <action>
Create frontend/src/hooks/useIncidentMutations.ts (per RESEARCH.md optimistic update pattern):
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiFetch } from '@/lib/api';
import type { Incident } from '@/types/incident';
import { toast } from 'sonner';

interface AcknowledgeResponse {
  incident: Incident;
}

interface ResolveResponse {
  incident: Incident;
}

// Optimistic acknowledge mutation (per user decision)
export function useAcknowledgeIncident() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      incidentId,
      note,
    }: {
      incidentId: string;
      note?: string;
    }) => {
      const response = await apiFetch<AcknowledgeResponse>(
        `/incidents/${incidentId}/acknowledge`,
        {
          method: 'POST',
          body: JSON.stringify({ note }),
        }
      );
      return response.incident;
    },
    onMutate: async ({ incidentId }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['incidents', incidentId] });
      await queryClient.cancelQueries({ queryKey: ['incidents'] });

      // Snapshot previous value
      const previousIncident = queryClient.getQueryData<{ incident: Incident }>([
        'incidents',
        incidentId,
      ]);
      const previousList = queryClient.getQueryData(['incidents']);

      // Optimistically update to acknowledged
      if (previousIncident) {
        queryClient.setQueryData(['incidents', incidentId], {
          incident: {
            ...previousIncident.incident,
            status: 'ACKNOWLEDGED',
            acknowledgedAt: new Date().toISOString(),
          },
        });
      }

      // Show optimistic success
      toast.success('Incident acknowledged');

      return { previousIncident, previousList, incidentId };
    },
    onError: (error, variables, context) => {
      // Rollback on error
      if (context?.previousIncident) {
        queryClient.setQueryData(
          ['incidents', context.incidentId],
          context.previousIncident
        );
      }
      if (context?.previousList) {
        queryClient.setQueryData(['incidents'], context.previousList);
      }

      toast.error(`Failed to acknowledge: ${error.message}`);
    },
    onSettled: (data, error, { incidentId }) => {
      // Refetch to sync with server
      queryClient.invalidateQueries({ queryKey: ['incidents', incidentId] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
    },
  });
}

// Resolve mutation (not optimistic - requires confirmation per user decision)
export function useResolveIncident() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      incidentId,
      resolutionNote,
    }: {
      incidentId: string;
      resolutionNote?: string;
    }) => {
      const response = await apiFetch<ResolveResponse>(
        `/incidents/${incidentId}/resolve`,
        {
          method: 'POST',
          body: JSON.stringify({ resolutionNote }),
        }
      );
      return response.incident;
    },
    onSuccess: (data) => {
      toast.success('Incident resolved');
      queryClient.invalidateQueries({ queryKey: ['incidents', data.id] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
    },
    onError: (error) => {
      toast.error(`Failed to resolve: ${error.message}`);
    },
  });
}

// Close mutation
export function useCloseIncident() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ incidentId }: { incidentId: string }) => {
      const response = await apiFetch<ResolveResponse>(
        `/incidents/${incidentId}/close`,
        { method: 'POST' }
      );
      return response.incident;
    },
    onSuccess: (data) => {
      toast.success('Incident closed');
      queryClient.invalidateQueries({ queryKey: ['incidents', data.id] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
    },
    onError: (error) => {
      toast.error(`Failed to close: ${error.message}`);
    },
  });
}

// Reassign mutation
export function useReassignIncident() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      incidentId,
      userId,
      reason,
    }: {
      incidentId: string;
      userId: string;
      reason?: string;
    }) => {
      const response = await apiFetch<ResolveResponse>(
        `/incidents/${incidentId}/reassign`,
        {
          method: 'POST',
          body: JSON.stringify({ userId, reason }),
        }
      );
      return response.incident;
    },
    onSuccess: (data) => {
      toast.success('Incident reassigned');
      queryClient.invalidateQueries({ queryKey: ['incidents', data.id] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
    },
    onError: (error) => {
      toast.error(`Failed to reassign: ${error.message}`);
    },
  });
}

// Bulk acknowledge mutation
export function useBulkAcknowledge() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ incidentIds }: { incidentIds: string[] }) => {
      // Execute acknowledges in parallel
      const results = await Promise.allSettled(
        incidentIds.map((id) =>
          apiFetch<AcknowledgeResponse>(`/incidents/${id}/acknowledge`, {
            method: 'POST',
          })
        )
      );

      const succeeded = results.filter((r) => r.status === 'fulfilled').length;
      const failed = results.filter((r) => r.status === 'rejected').length;

      return { succeeded, failed, total: incidentIds.length };
    },
    onSuccess: (data) => {
      if (data.failed === 0) {
        toast.success(`Acknowledged ${data.succeeded} incidents`);
      } else {
        toast.warning(
          `Acknowledged ${data.succeeded}/${data.total} incidents (${data.failed} failed)`
        );
      }
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
    },
    onError: (error) => {
      toast.error(`Bulk acknowledge failed: ${error.message}`);
    },
  });
}

// Bulk resolve mutation
export function useBulkResolve() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ incidentIds }: { incidentIds: string[] }) => {
      const results = await Promise.allSettled(
        incidentIds.map((id) =>
          apiFetch<ResolveResponse>(`/incidents/${id}/resolve`, {
            method: 'POST',
          })
        )
      );

      const succeeded = results.filter((r) => r.status === 'fulfilled').length;
      const failed = results.filter((r) => r.status === 'rejected').length;

      return { succeeded, failed, total: incidentIds.length };
    },
    onSuccess: (data) => {
      if (data.failed === 0) {
        toast.success(`Resolved ${data.succeeded} incidents`);
      } else {
        toast.warning(
          `Resolved ${data.succeeded}/${data.total} incidents (${data.failed} failed)`
        );
      }
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
    },
    onError: (error) => {
      toast.error(`Bulk resolve failed: ${error.message}`);
    },
  });
}
```
  </action>
  <verify>
ls frontend/src/hooks/useIncidentMutations.ts
grep -q "useAcknowledgeIncident" frontend/src/hooks/useIncidentMutations.ts
grep -q "useBulkAcknowledge" frontend/src/hooks/useIncidentMutations.ts
cd frontend && npm run build
  </verify>
  <done>
Mutation hooks created for acknowledge (optimistic), resolve, close, reassign, and bulk actions. Optimistic updates with rollback on error.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Incident Actions and Bulk Actions Components</name>
  <files>
    frontend/src/components/IncidentActions.tsx
    frontend/src/components/BulkActions.tsx
    frontend/src/components/ResolveDialog.tsx
    frontend/src/pages/DashboardPage.tsx
  </files>
  <action>
Add shadcn/ui dialog and alert-dialog:
```bash
cd frontend && npx shadcn@latest add dialog alert-dialog textarea
```

Create frontend/src/components/ResolveDialog.tsx (confirmation per user decision):
```typescript
import { useState } from 'react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';

interface ResolveDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: (resolutionNote?: string) => void;
  incidentCount?: number;
}

export function ResolveDialog({
  open,
  onOpenChange,
  onConfirm,
  incidentCount = 1,
}: ResolveDialogProps) {
  const [note, setNote] = useState('');

  const handleConfirm = () => {
    onConfirm(note || undefined);
    setNote('');
  };

  const title =
    incidentCount > 1
      ? `Resolve ${incidentCount} incidents?`
      : 'Resolve this incident?';

  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>{title}</AlertDialogTitle>
          <AlertDialogDescription>
            This will mark the incident(s) as resolved. You can optionally add a
            resolution note.
          </AlertDialogDescription>
        </AlertDialogHeader>

        <div className="py-4">
          <Label htmlFor="resolution-note">Resolution Note (optional)</Label>
          <Textarea
            id="resolution-note"
            value={note}
            onChange={(e) => setNote(e.target.value)}
            placeholder="Describe the resolution..."
            className="mt-2"
            rows={3}
          />
        </div>

        <AlertDialogFooter>
          <AlertDialogCancel onClick={() => setNote('')}>Cancel</AlertDialogCancel>
          <AlertDialogAction onClick={handleConfirm}>
            Resolve
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}
```

Create frontend/src/components/IncidentActions.tsx:
```typescript
import { useState } from 'react';
import type { Incident } from '@/types/incident';
import {
  useAcknowledgeIncident,
  useResolveIncident,
  useCloseIncident,
} from '@/hooks/useIncidentMutations';
import { Button } from '@/components/ui/button';
import { ResolveDialog } from './ResolveDialog';
import { Check, CheckCheck, XCircle, Loader2 } from 'lucide-react';

interface IncidentActionsProps {
  incident: Incident;
  variant?: 'inline' | 'full';
}

export function IncidentActions({ incident, variant = 'inline' }: IncidentActionsProps) {
  const [showResolveDialog, setShowResolveDialog] = useState(false);

  const acknowledgeMutation = useAcknowledgeIncident();
  const resolveMutation = useResolveIncident();
  const closeMutation = useCloseIncident();

  const handleAcknowledge = () => {
    acknowledgeMutation.mutate({ incidentId: incident.id });
  };

  const handleResolve = (resolutionNote?: string) => {
    resolveMutation.mutate({ incidentId: incident.id, resolutionNote });
    setShowResolveDialog(false);
  };

  const handleClose = () => {
    closeMutation.mutate({ incidentId: incident.id });
  };

  const isLoading =
    acknowledgeMutation.isPending ||
    resolveMutation.isPending ||
    closeMutation.isPending;

  // Different layouts for inline (row) vs full (detail page)
  if (variant === 'inline') {
    return (
      <>
        <div className="flex items-center gap-2" onClick={(e) => e.stopPropagation()}>
          {incident.status === 'OPEN' && (
            <Button
              size="sm"
              variant="outline"
              onClick={handleAcknowledge}
              disabled={isLoading}
            >
              {acknowledgeMutation.isPending ? (
                <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                <>
                  <Check className="h-4 w-4 mr-1" />
                  Ack
                </>
              )}
            </Button>
          )}
          {['OPEN', 'ACKNOWLEDGED'].includes(incident.status) && (
            <Button
              size="sm"
              variant="outline"
              onClick={() => setShowResolveDialog(true)}
              disabled={isLoading}
            >
              <CheckCheck className="h-4 w-4 mr-1" />
              Resolve
            </Button>
          )}
        </div>

        <ResolveDialog
          open={showResolveDialog}
          onOpenChange={setShowResolveDialog}
          onConfirm={handleResolve}
        />
      </>
    );
  }

  // Full variant for detail page
  return (
    <>
      <div className="flex items-center gap-3 flex-wrap">
        {incident.status === 'OPEN' && (
          <Button onClick={handleAcknowledge} disabled={isLoading}>
            {acknowledgeMutation.isPending ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" />
            ) : (
              <Check className="h-4 w-4 mr-2" />
            )}
            Acknowledge
          </Button>
        )}
        {['OPEN', 'ACKNOWLEDGED'].includes(incident.status) && (
          <Button
            variant="outline"
            onClick={() => setShowResolveDialog(true)}
            disabled={isLoading}
          >
            <CheckCheck className="h-4 w-4 mr-2" />
            Resolve
          </Button>
        )}
        {incident.status === 'RESOLVED' && (
          <Button variant="outline" onClick={handleClose} disabled={isLoading}>
            {closeMutation.isPending ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" />
            ) : (
              <XCircle className="h-4 w-4 mr-2" />
            )}
            Close
          </Button>
        )}
      </div>

      <ResolveDialog
        open={showResolveDialog}
        onOpenChange={setShowResolveDialog}
        onConfirm={handleResolve}
      />
    </>
  );
}
```

Create frontend/src/components/BulkActions.tsx (per user decision):
```typescript
import { useState } from 'react';
import { useBulkAcknowledge, useBulkResolve } from '@/hooks/useIncidentMutations';
import { Button } from '@/components/ui/button';
import { ResolveDialog } from './ResolveDialog';
import { Check, CheckCheck, Loader2 } from 'lucide-react';

interface BulkActionsProps {
  selectedIds: Set<string>;
  onClearSelection: () => void;
}

export function BulkActions({ selectedIds, onClearSelection }: BulkActionsProps) {
  const [showResolveDialog, setShowResolveDialog] = useState(false);

  const bulkAcknowledge = useBulkAcknowledge();
  const bulkResolve = useBulkResolve();

  const count = selectedIds.size;
  const isLoading = bulkAcknowledge.isPending || bulkResolve.isPending;

  const handleBulkAcknowledge = () => {
    bulkAcknowledge.mutate(
      { incidentIds: Array.from(selectedIds) },
      { onSuccess: () => onClearSelection() }
    );
  };

  const handleBulkResolve = () => {
    bulkResolve.mutate(
      { incidentIds: Array.from(selectedIds) },
      { onSuccess: () => onClearSelection() }
    );
    setShowResolveDialog(false);
  };

  if (count === 0) return null;

  return (
    <>
      <div className="flex items-center gap-4 p-3 bg-muted rounded-lg">
        <span className="text-sm font-medium">{count} selected</span>

        <div className="flex items-center gap-2">
          <Button
            size="sm"
            variant="outline"
            onClick={handleBulkAcknowledge}
            disabled={isLoading}
          >
            {bulkAcknowledge.isPending ? (
              <Loader2 className="h-4 w-4 animate-spin mr-1" />
            ) : (
              <Check className="h-4 w-4 mr-1" />
            )}
            Acknowledge All
          </Button>

          <Button
            size="sm"
            variant="outline"
            onClick={() => setShowResolveDialog(true)}
            disabled={isLoading}
          >
            <CheckCheck className="h-4 w-4 mr-1" />
            Resolve All
          </Button>

          <Button size="sm" variant="ghost" onClick={onClearSelection}>
            Clear
          </Button>
        </div>
      </div>

      <ResolveDialog
        open={showResolveDialog}
        onOpenChange={setShowResolveDialog}
        onConfirm={handleBulkResolve}
        incidentCount={count}
      />
    </>
  );
}
```

Update frontend/src/pages/DashboardPage.tsx to integrate WebSocket and actions:

Add imports:
```typescript
import { useWebSocket } from '@/hooks/useWebSocket';
import { ConnectionStatus } from '@/components/ConnectionStatus';
import { BulkActions } from '@/components/BulkActions';
```

Add in component:
```typescript
const { connectionState, reconnectAttempt } = useWebSocket();
```

Add at top of return JSX:
```typescript
<ConnectionStatus state={connectionState} reconnectAttempt={reconnectAttempt} />
```

Replace bulk selection header with BulkActions:
```typescript
<BulkActions
  selectedIds={selectedIds}
  onClearSelection={() => setSelectedIds(new Set())}
/>
```

Also update IncidentRow.tsx to include actions in expanded state by importing and using IncidentActions component.
  </action>
  <verify>
ls frontend/src/components/IncidentActions.tsx
ls frontend/src/components/BulkActions.tsx
ls frontend/src/components/ResolveDialog.tsx
cd frontend && npm run build
  </verify>
  <done>
Incident action buttons (acknowledge, resolve, close) with optimistic updates. Bulk actions for selected incidents. Resolve confirmation dialog per user decision. WebSocket connection status indicator.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npm run build` - Compiles without errors
2. Start both backend (npm run dev) and frontend (cd frontend && npm run dev)
3. Open two browser tabs to http://localhost:3001/incidents
4. Acknowledge incident in tab 1 - verify tab 2 shows toast and updates
5. Verify acknowledge is instant (optimistic)
6. Verify resolve shows confirmation dialog
7. Disconnect network - verify connection status banner appears
8. Test bulk acknowledge with multiple selected incidents
</verification>

<success_criteria>
- [ ] WebSocket connects and subscribes to incidents
- [ ] Real-time updates when incidents change (toast + list refresh)
- [ ] Acknowledge uses optimistic update (instant UI feedback)
- [ ] Resolve shows confirmation dialog with optional note
- [ ] Close button appears only for resolved incidents
- [ ] Connection status banner when disconnected
- [ ] Auto-reconnection with attempt count
- [ ] Bulk acknowledge works for multiple selected incidents
- [ ] Bulk resolve shows confirmation with count
</success_criteria>

<output>
After completion, create `.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-05-SUMMARY.md`
</output>

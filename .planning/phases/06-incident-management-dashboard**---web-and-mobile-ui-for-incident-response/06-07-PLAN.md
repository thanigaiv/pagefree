---
phase: 06-incident-management-dashboard
plan: 07
type: execute
wave: 4
depends_on: ["06-03", "06-04"]
files_modified:
  - frontend/vite.config.ts
  - frontend/public/manifest.json
  - frontend/src/lib/pwa.ts
  - frontend/src/hooks/usePWA.ts
  - frontend/src/components/InstallPrompt.tsx
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "PWA can be installed to home screen"
    - "App works offline (read-only cached incidents)"
    - "Service worker caches API responses"
    - "Install prompt appears after first acknowledgment"
    - "Offline indicator shows when cached data displayed"
  artifacts:
    - path: "frontend/vite.config.ts"
      provides: "PWA plugin configuration"
      contains: "VitePWA"
    - path: "frontend/public/manifest.json"
      provides: "PWA manifest for installation"
      contains: "display.*standalone"
    - path: "frontend/src/lib/pwa.ts"
      provides: "PWA utilities"
      exports: ["promptPWAInstall"]
  key_links:
    - from: "frontend/vite.config.ts"
      to: "vite-plugin-pwa"
      via: "VitePWA plugin"
      pattern: "VitePWA"
    - from: "frontend/src/hooks/usePWA.ts"
      to: "frontend/src/lib/pwa.ts"
      via: "install prompt capture"
      pattern: "beforeinstallprompt"
---

<objective>
Set up Progressive Web App infrastructure with service worker and offline caching.

Purpose: Enable mobile-like experience with home screen installation and offline access. Per user decisions: offline view cached incidents (read-only), install prompt after first acknowledgment, PWA works on mobile and desktop.

Output: Installable PWA with service worker caching and offline support.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-CONTEXT.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-RESEARCH.md
@.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-03-SUMMARY.md

# Vite config
@frontend/vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install vite-plugin-pwa and Configure Service Worker</name>
  <files>
    frontend/package.json
    frontend/vite.config.ts
    frontend/public/icons/icon-192.png
    frontend/public/icons/icon-512.png
  </files>
  <action>
Install vite-plugin-pwa and workbox:
```bash
cd frontend && npm install -D vite-plugin-pwa workbox-window
```

Update frontend/vite.config.ts to include PWA plugin (per RESEARCH.md):
```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';
import path from 'path';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'robots.txt', 'icons/*.png'],
      manifest: {
        name: 'OnCall Platform',
        short_name: 'OnCall',
        description: 'Incident Management Dashboard',
        theme_color: '#0f172a',
        background_color: '#ffffff',
        display: 'standalone',
        orientation: 'portrait',
        scope: '/',
        start_url: '/',
        icons: [
          {
            src: 'icons/icon-192.png',
            sizes: '192x192',
            type: 'image/png',
          },
          {
            src: 'icons/icon-512.png',
            sizes: '512x512',
            type: 'image/png',
          },
          {
            src: 'icons/icon-512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'maskable',
          },
        ],
      },
      workbox: {
        // Precache static assets
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff,woff2}'],

        // Runtime caching for API (per user decision: offline view cached)
        runtimeCaching: [
          {
            // Cache incident list for offline viewing
            urlPattern: /\/api\/incidents(\?.*)?$/,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'incidents-list-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 5 * 60, // 5 minutes
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
              networkTimeoutSeconds: 3, // Fall back to cache if network slow
            },
          },
          {
            // Cache individual incidents
            urlPattern: /\/api\/incidents\/[^/]+$/,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'incidents-detail-cache',
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 5 * 60,
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
              networkTimeoutSeconds: 3,
            },
          },
          {
            // Cache timeline data
            urlPattern: /\/api\/incidents\/[^/]+\/timeline$/,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'timeline-cache',
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 5 * 60,
              },
              cacheableResponse: {
                statuses: [0, 200],
              },
            },
          },
          {
            // Cache user/team data (changes less frequently)
            urlPattern: /\/api\/(users|teams)/,
            handler: 'StaleWhileRevalidate',
            options: {
              cacheName: 'users-teams-cache',
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 30 * 60, // 30 minutes
              },
            },
          },
        ],
      },
      devOptions: {
        enabled: true, // Enable in dev for testing
        type: 'module',
      },
    }),
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3001,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true,
      },
    },
  },
});
```

Create placeholder PWA icons. In production, generate proper icons:

Create frontend/public/icons/ directory and add placeholder icon files:
```bash
mkdir -p frontend/public/icons
```

Create a simple SVG that can be used as icon (convert to PNG in production):

Create frontend/public/icons/icon.svg:
```svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
  <rect width="512" height="512" fill="#0f172a" rx="64"/>
  <path fill="#ffffff" d="M256 96c-88.4 0-160 71.6-160 160s71.6 160 160 160 160-71.6 160-160S344.4 96 256 96zm0 280c-66.2 0-120-53.8-120-120s53.8-120 120-120 120 53.8 120 120-53.8 120-120 120zm52-160h-40v-52c0-6.6-5.4-12-12-12s-12 5.4-12 12v64c0 6.6 5.4 12 12 12h52c6.6 0 12-5.4 12-12s-5.4-12-12-12z"/>
</svg>
```

Note: For production, convert SVG to PNG at 192x192 and 512x512 sizes using a tool like:
```bash
# Example using ImageMagick (if available)
# convert -background none frontend/public/icons/icon.svg -resize 192x192 frontend/public/icons/icon-192.png
# convert -background none frontend/public/icons/icon.svg -resize 512x512 frontend/public/icons/icon-512.png
```

For now, create simple placeholder PNGs by creating a node script or copying the SVG:
```bash
# Just copy SVG to serve as placeholder - real icons needed for production
cp frontend/public/icons/icon.svg frontend/public/icons/icon-192.png 2>/dev/null || echo "Create proper PNG icons for production"
cp frontend/public/icons/icon.svg frontend/public/icons/icon-512.png 2>/dev/null || echo "Create proper PNG icons for production"
```
  </action>
  <verify>
grep -q "vite-plugin-pwa" frontend/package.json
grep -q "VitePWA" frontend/vite.config.ts
ls frontend/public/icons/ || echo "Icons directory needed"
cd frontend && npm run build
  </verify>
  <done>
vite-plugin-pwa configured with manifest and Workbox caching. NetworkFirst strategy for API routes ensures fresh data when online, cached data when offline. Icons placeholder created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PWA Utilities and Install Prompt Hook</name>
  <files>
    frontend/src/lib/pwa.ts
    frontend/src/hooks/usePWA.ts
    frontend/src/components/InstallPrompt.tsx
  </files>
  <action>
Create frontend/src/lib/pwa.ts (per RESEARCH.md pattern):
```typescript
// PWA installation utilities

interface BeforeInstallPromptEvent extends Event {
  prompt(): Promise<void>;
  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;
}

let deferredPrompt: BeforeInstallPromptEvent | null = null;

// Capture the install prompt event
export function initPWAInstallCapture() {
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e as BeforeInstallPromptEvent;
    console.log('PWA install prompt captured');
  });

  // Track successful installation
  window.addEventListener('appinstalled', () => {
    console.log('PWA installed');
    deferredPrompt = null;
  });
}

// Check if install prompt is available
export function canInstallPWA(): boolean {
  return deferredPrompt !== null;
}

// Show the install prompt
export async function promptPWAInstall(): Promise<boolean> {
  if (!deferredPrompt) {
    console.log('Install prompt not available');
    return false;
  }

  // Show the install prompt
  deferredPrompt.prompt();

  // Wait for user response
  const { outcome } = await deferredPrompt.userChoice;
  console.log(`User ${outcome} the install prompt`);

  // Clear the deferred prompt
  deferredPrompt = null;

  return outcome === 'accepted';
}

// Check if running as installed PWA
export function isInstalledPWA(): boolean {
  return (
    window.matchMedia('(display-mode: standalone)').matches ||
    (window.navigator as any).standalone === true
  );
}

// Check if app is offline
export function isOffline(): boolean {
  return !navigator.onLine;
}

// Listen for online/offline changes
export function onOnlineStatusChange(callback: (online: boolean) => void): () => void {
  const handleOnline = () => callback(true);
  const handleOffline = () => callback(false);

  window.addEventListener('online', handleOnline);
  window.addEventListener('offline', handleOffline);

  return () => {
    window.removeEventListener('online', handleOnline);
    window.removeEventListener('offline', handleOffline);
  };
}
```

Create frontend/src/hooks/usePWA.ts:
```typescript
import { useState, useEffect, useRef, useCallback } from 'react';
import {
  initPWAInstallCapture,
  canInstallPWA,
  promptPWAInstall,
  isInstalledPWA,
  isOffline,
  onOnlineStatusChange,
} from '@/lib/pwa';
import { toast } from 'sonner';

interface UsePWAReturn {
  canInstall: boolean;
  isInstalled: boolean;
  isOnline: boolean;
  showInstallPrompt: () => Promise<boolean>;
  promptAfterAcknowledge: () => void;
}

export function usePWA(): UsePWAReturn {
  const [canInstall, setCanInstall] = useState(false);
  const [isInstalled, setIsInstalled] = useState(false);
  const [isOnline, setIsOnline] = useState(!isOffline());
  const hasPromptedRef = useRef(false);

  useEffect(() => {
    // Initialize install capture
    initPWAInstallCapture();

    // Check initial state
    setIsInstalled(isInstalledPWA());

    // Listen for install prompt availability
    const checkInstall = () => setCanInstall(canInstallPWA());

    // Check periodically (beforeinstallprompt is async)
    const interval = setInterval(checkInstall, 1000);
    setTimeout(() => clearInterval(interval), 10000); // Stop after 10s

    // Listen for online/offline
    const unsubscribe = onOnlineStatusChange((online) => {
      setIsOnline(online);
      if (!online) {
        toast.warning('You are offline. Viewing cached data.');
      } else {
        toast.success('Back online');
      }
    });

    return () => {
      clearInterval(interval);
      unsubscribe();
    };
  }, []);

  const showInstallPrompt = useCallback(async () => {
    const installed = await promptPWAInstall();
    if (installed) {
      setIsInstalled(true);
      setCanInstall(false);
      toast.success('App installed! Access from your home screen.');
    }
    return installed;
  }, []);

  // Per user decision: prompt after first acknowledgment
  const promptAfterAcknowledge = useCallback(() => {
    if (hasPromptedRef.current || !canInstall || isInstalled) {
      return;
    }

    hasPromptedRef.current = true;

    // Delay slightly so user sees acknowledgment success first
    setTimeout(() => {
      showInstallPrompt();
    }, 1500);
  }, [canInstall, isInstalled, showInstallPrompt]);

  return {
    canInstall,
    isInstalled,
    isOnline,
    showInstallPrompt,
    promptAfterAcknowledge,
  };
}
```

Create frontend/src/components/InstallPrompt.tsx:
```typescript
import { Button } from '@/components/ui/button';
import { Download } from 'lucide-react';

interface InstallPromptProps {
  onInstall: () => void;
  canInstall: boolean;
}

export function InstallPrompt({ onInstall, canInstall }: InstallPromptProps) {
  if (!canInstall) return null;

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={onInstall}
      className="gap-2"
    >
      <Download className="h-4 w-4" />
      Install App
    </Button>
  );
}
```

Create frontend/src/components/OfflineIndicator.tsx:
```typescript
import { WifiOff } from 'lucide-react';

interface OfflineIndicatorProps {
  isOnline: boolean;
}

export function OfflineIndicator({ isOnline }: OfflineIndicatorProps) {
  if (isOnline) return null;

  return (
    <div className="fixed bottom-4 left-4 right-4 md:left-auto md:right-4 md:w-auto bg-yellow-100 text-yellow-800 px-4 py-2 rounded-lg shadow-lg flex items-center gap-2 z-50">
      <WifiOff className="h-4 w-4" />
      <span className="text-sm font-medium">
        Offline - viewing cached data
      </span>
    </div>
  );
}
```
  </action>
  <verify>
ls frontend/src/lib/pwa.ts
ls frontend/src/hooks/usePWA.ts
ls frontend/src/components/InstallPrompt.tsx
cd frontend && npm run build
  </verify>
  <done>
PWA utilities for install prompt capture and offline detection. usePWA hook provides reactive state for install availability and online status. Install prompt and offline indicator components created.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate PWA Features into App</name>
  <files>
    frontend/src/App.tsx
    frontend/src/pages/DashboardPage.tsx
    frontend/src/hooks/useIncidentMutations.ts
  </files>
  <action>
Update frontend/src/App.tsx to include PWA initialization and offline indicator:

```typescript
import { Routes, Route, Navigate } from 'react-router-dom';
import { usePWA } from './hooks/usePWA';
import { OfflineIndicator } from './components/OfflineIndicator';
import DashboardPage from './pages/DashboardPage';
import IncidentDetailPage from './pages/IncidentDetailPage';

export default function App() {
  const { isOnline } = usePWA();

  return (
    <>
      <Routes>
        <Route path="/" element={<Navigate to="/incidents" replace />} />
        <Route path="/incidents" element={<DashboardPage />} />
        <Route path="/incidents/:id" element={<IncidentDetailPage />} />
      </Routes>

      {/* Offline indicator (per user decision) */}
      <OfflineIndicator isOnline={isOnline} />
    </>
  );
}
```

Update frontend/src/pages/DashboardPage.tsx to include install button and trigger prompt after acknowledge:

Add import:
```typescript
import { usePWA } from '@/hooks/usePWA';
import { InstallPrompt } from '@/components/InstallPrompt';
```

Add in component:
```typescript
const { canInstall, showInstallPrompt, promptAfterAcknowledge } = usePWA();
```

Pass promptAfterAcknowledge to incident actions or call it in bulk acknowledge success callback.

Add InstallPrompt button in the header area:
```typescript
<div className="flex items-center gap-2">
  <InstallPrompt canInstall={canInstall} onInstall={showInstallPrompt} />
  <Button
    variant="outline"
    size="sm"
    onClick={() => refetch()}
    disabled={isFetching}
  >
    <RefreshCw className={`h-4 w-4 mr-2 ${isFetching ? 'animate-spin' : ''}`} />
    Refresh
  </Button>
</div>
```

Update frontend/src/hooks/useIncidentMutations.ts to expose callback for PWA prompt:

In useAcknowledgeIncident, accept optional onAcknowledgeSuccess callback:
```typescript
export function useAcknowledgeIncident(options?: { onSuccess?: () => void }) {
  // ... existing code ...

  return useMutation({
    // ... existing config ...
    onSuccess: (data) => {
      // Call optional callback (for PWA install prompt)
      options?.onSuccess?.();
    },
    onSettled: (data, error, { incidentId }) => {
      queryClient.invalidateQueries({ queryKey: ['incidents', incidentId] });
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
    },
  });
}
```

Then in DashboardPage or IncidentActions, use:
```typescript
const acknowledgeMutation = useAcknowledgeIncident({
  onSuccess: promptAfterAcknowledge,
});
```

Create frontend/src/vite-env.d.ts (if not exists) to add PWA types:
```typescript
/// <reference types="vite/client" />
/// <reference types="vite-plugin-pwa/client" />
```
  </action>
  <verify>
grep -q "usePWA" frontend/src/App.tsx
grep -q "OfflineIndicator" frontend/src/App.tsx
cd frontend && npm run build
  </verify>
  <done>
PWA features integrated. Offline indicator shows when using cached data. Install prompt button in header. Install auto-prompted after first acknowledge per user decision.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npm run build` - Compiles without errors
2. `cd frontend && npm run preview` - Serve production build
3. Open Chrome DevTools -> Application -> Service Workers
4. Verify service worker registered
5. Check Manifest section - verify app info
6. Go offline (DevTools -> Network -> Offline)
7. Verify incidents still display (cached)
8. Verify offline indicator appears
9. Test install button if available
</verification>

<success_criteria>
- [ ] vite-plugin-pwa configured with Workbox
- [ ] PWA manifest with app name and icons
- [ ] Service worker registers on production build
- [ ] API responses cached with NetworkFirst strategy
- [ ] Offline indicator shows when using cached data
- [ ] Install button appears when PWA installable
- [ ] Install prompt triggers after first acknowledgment
- [ ] App works offline (shows cached incidents)
- [ ] Cache expires after 5 minutes
</success_criteria>

<output>
After completion, create `.planning/phases/06-incident-management-dashboard**---web-and-mobile-ui-for-incident-response/06-07-SUMMARY.md`
</output>

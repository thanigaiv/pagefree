---
phase: 12-service-dependencies-graph
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - frontend/src/types/service.ts
  - frontend/src/hooks/useServiceDependencies.ts
  - frontend/src/components/services/DependencyGraph.tsx
  - frontend/src/components/services/ServiceNode.tsx
  - frontend/src/pages/ServicesPage.tsx
autonomous: true

must_haves:
  truths:
    - "User can see upstream dependencies for a service"
    - "User can see downstream dependents for a service"
    - "User can add a dependency between two services via UI"
    - "User can remove a dependency via UI"
    - "User can view visual dependency graph with auto-layout"
    - "Cycle rejection error is displayed to user in toast"
  artifacts:
    - path: "frontend/src/hooks/useServiceDependencies.ts"
      provides: "React Query hooks for dependency operations"
      exports: ["useServiceDependencies", "useServiceDependents", "useServiceGraph", "useAddDependency", "useRemoveDependency"]
      min_lines: 60
    - path: "frontend/src/components/services/DependencyGraph.tsx"
      provides: "React Flow visualization of service dependencies"
      contains: "ReactFlow"
      min_lines: 80
    - path: "frontend/src/components/services/ServiceNode.tsx"
      provides: "Custom React Flow node for services"
      contains: "Handle"
      min_lines: 30
    - path: "frontend/src/pages/ServicesPage.tsx"
      provides: "Extended with dependency management UI"
      contains: "DependencyGraph"
  key_links:
    - from: "frontend/src/components/services/DependencyGraph.tsx"
      to: "frontend/src/hooks/useServiceDependencies.ts"
      via: "useServiceGraph hook"
      pattern: "useServiceGraph"
    - from: "frontend/src/pages/ServicesPage.tsx"
      to: "frontend/src/components/services/DependencyGraph.tsx"
      via: "component import"
      pattern: "DependencyGraph"
---

<objective>
Frontend dependency visualization and management UI

Purpose: Enable users to view service relationships as a visual graph and manage dependencies through intuitive add/remove interactions

Output: React Query hooks for dependency operations, React Flow-based DependencyGraph component, ServiceNode custom node, ServicesPage extended with graph view and dependency management dialogs
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-service-dependencies-graph/12-RESEARCH.md

# Depends on 12-01 for API endpoints
@.planning/phases/12-service-dependencies-graph/12-01-SUMMARY.md

# Phase 11 frontend patterns
@.planning/phases/11-service-model-foundation/11-02-SUMMARY.md

# Existing React Flow pattern to follow
@frontend/src/components/workflow/WorkflowCanvas.tsx

# Existing service files to extend
@frontend/src/hooks/useServices.ts
@frontend/src/types/service.ts
@frontend/src/pages/ServicesPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create service dependency types and React Query hooks</name>
  <files>frontend/src/types/service.ts, frontend/src/hooks/useServiceDependencies.ts</files>
  <action>
**Extend frontend/src/types/service.ts with:**

```typescript
// =============================================================================
// DEPENDENCY TYPES
// =============================================================================

// Simple service info for dependency lists
export interface ServiceDependency {
  id: string;
  name: string;
  status: ServiceStatus;
  team: {
    id: string;
    name: string;
  };
}

// Graph visualization types
export interface ServiceGraphNode {
  id: string;
  name: string;
  status: ServiceStatus;
  teamName: string;
  isFocused?: boolean;
}

export interface ServiceGraphEdge {
  source: string;
  target: string;
}

export interface ServiceGraph {
  nodes: ServiceGraphNode[];
  edges: ServiceGraphEdge[];
}

// API response types for dependencies
export interface DependenciesResponse {
  dependencies: ServiceDependency[];
}

export interface DependentsResponse {
  dependents: ServiceDependency[];
}

export interface GraphResponse {
  graph: ServiceGraph;
}
```

**Create frontend/src/hooks/useServiceDependencies.ts:**

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiFetch } from '@/lib/api';
import type {
  ServiceDependency,
  ServiceGraph,
  DependenciesResponse,
  DependentsResponse,
  GraphResponse
} from '@/types/service';

// =============================================================================
// QUERY HOOKS
// =============================================================================

/**
 * Fetch upstream dependencies (what this service depends on)
 */
export function useServiceDependencies(serviceId: string | undefined) {
  return useQuery({
    queryKey: ['service-dependencies', serviceId],
    queryFn: () =>
      apiFetch<DependenciesResponse>(`/services/${serviceId}/dependencies`)
        .then(r => r.dependencies),
    enabled: !!serviceId
  });
}

/**
 * Fetch downstream dependents (what depends on this service)
 */
export function useServiceDependents(serviceId: string | undefined) {
  return useQuery({
    queryKey: ['service-dependents', serviceId],
    queryFn: () =>
      apiFetch<DependentsResponse>(`/services/${serviceId}/dependents`)
        .then(r => r.dependents),
    enabled: !!serviceId
  });
}

/**
 * Fetch full dependency graph for visualization
 */
export function useServiceGraph(serviceId: string | undefined) {
  return useQuery({
    queryKey: ['service-graph', serviceId],
    queryFn: () =>
      apiFetch<GraphResponse>(`/services/${serviceId}/graph`)
        .then(r => r.graph),
    enabled: !!serviceId
  });
}

// =============================================================================
// MUTATION HOOKS
// =============================================================================

/**
 * Add a dependency (service depends on another service)
 */
export function useAddDependency() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ serviceId, dependsOnId }: { serviceId: string; dependsOnId: string }) =>
      apiFetch(`/services/${serviceId}/dependencies`, {
        method: 'POST',
        body: JSON.stringify({ dependsOnId })
      }),
    onSuccess: (_, { serviceId }) => {
      queryClient.invalidateQueries({ queryKey: ['service-dependencies', serviceId] });
      queryClient.invalidateQueries({ queryKey: ['service-dependents'] });
      queryClient.invalidateQueries({ queryKey: ['service-graph', serviceId] });
      queryClient.invalidateQueries({ queryKey: ['services'] });
    }
  });
}

/**
 * Remove a dependency
 */
export function useRemoveDependency() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ serviceId, dependsOnId }: { serviceId: string; dependsOnId: string }) =>
      apiFetch(`/services/${serviceId}/dependencies/${dependsOnId}`, {
        method: 'DELETE'
      }),
    onSuccess: (_, { serviceId }) => {
      queryClient.invalidateQueries({ queryKey: ['service-dependencies', serviceId] });
      queryClient.invalidateQueries({ queryKey: ['service-dependents'] });
      queryClient.invalidateQueries({ queryKey: ['service-graph', serviceId] });
    }
  });
}
```

Follow patterns from useServices.ts for consistency.
  </action>
  <verify>
TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
Dependency types added to service.ts. useServiceDependencies.ts exports 5 hooks: useServiceDependencies, useServiceDependents, useServiceGraph, useAddDependency, useRemoveDependency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DependencyGraph component and ServiceNode</name>
  <files>frontend/src/components/services/DependencyGraph.tsx, frontend/src/components/services/ServiceNode.tsx</files>
  <action>
**Create frontend/src/components/services/ServiceNode.tsx:**

Custom React Flow node for service visualization:

```typescript
import { memo } from 'react';
import { Handle, Position, type NodeProps } from '@xyflow/react';

interface ServiceNodeData {
  name: string;
  teamName: string;
  status: 'ACTIVE' | 'DEPRECATED' | 'ARCHIVED';
  isFocused?: boolean;
}

const statusStyles = {
  ACTIVE: 'bg-green-50 border-green-300 text-green-800',
  DEPRECATED: 'bg-yellow-50 border-yellow-300 text-yellow-800',
  ARCHIVED: 'bg-gray-100 border-gray-300 text-gray-500'
};

function ServiceNodeComponent({ data, selected }: NodeProps<ServiceNodeData>) {
  return (
    <div
      className={`
        px-4 py-3 rounded-lg border-2 shadow-sm min-w-[180px]
        ${statusStyles[data.status]}
        ${selected ? 'ring-2 ring-blue-500' : ''}
        ${data.isFocused ? 'ring-2 ring-purple-500 ring-offset-2' : ''}
      `}
    >
      <Handle
        type="target"
        position={Position.Left}
        className="w-3 h-3 !bg-gray-400"
      />
      <div className="font-medium text-sm truncate">{data.name}</div>
      <div className="text-xs opacity-70 truncate">{data.teamName}</div>
      <Handle
        type="source"
        position={Position.Right}
        className="w-3 h-3 !bg-gray-400"
      />
    </div>
  );
}

export const ServiceNode = memo(ServiceNodeComponent);
```

**Create frontend/src/components/services/DependencyGraph.tsx:**

React Flow-based graph visualization following WorkflowCanvas patterns:

```typescript
import { useMemo, useCallback } from 'react';
import {
  ReactFlow,
  Background,
  Controls,
  MiniMap,
  BackgroundVariant,
  type Node,
  type Edge,
  type NodeTypes,
  MarkerType,
  ReactFlowProvider
} from '@xyflow/react';
import dagre from 'dagre';
import '@xyflow/react/dist/style.css';

import { ServiceNode } from './ServiceNode';
import { useServiceGraph } from '@/hooks/useServiceDependencies';
import { Loader2 } from 'lucide-react';

const nodeTypes: NodeTypes = {
  service: ServiceNode
};

// Node dimensions for dagre layout
const NODE_WIDTH = 180;
const NODE_HEIGHT = 60;

/**
 * Auto-layout using dagre (pattern from WorkflowCanvas)
 */
function getLayoutedElements(nodes: Node[], edges: Edge[]): { nodes: Node[]; edges: Edge[] } {
  if (nodes.length === 0) return { nodes, edges };

  const g = new dagre.graphlib.Graph();
  g.setDefaultEdgeLabel(() => ({}));
  g.setGraph({
    rankdir: 'LR',  // Left to right (upstream -> downstream)
    nodesep: 60,
    ranksep: 100,
    marginx: 20,
    marginy: 20
  });

  nodes.forEach(node => g.setNode(node.id, { width: NODE_WIDTH, height: NODE_HEIGHT }));
  edges.forEach(edge => g.setEdge(edge.source, edge.target));

  dagre.layout(g);

  const layoutedNodes = nodes.map(node => {
    const pos = g.node(node.id);
    return {
      ...node,
      position: {
        x: pos.x - NODE_WIDTH / 2,
        y: pos.y - NODE_HEIGHT / 2
      }
    };
  });

  return { nodes: layoutedNodes, edges };
}

interface DependencyGraphProps {
  serviceId: string;
  onNodeClick?: (serviceId: string) => void;
}

function DependencyGraphInner({ serviceId, onNodeClick }: DependencyGraphProps) {
  const { data: graph, isLoading, error } = useServiceGraph(serviceId);

  // Convert API response to React Flow nodes/edges
  const { nodes, edges } = useMemo(() => {
    if (!graph) return { nodes: [], edges: [] };

    const rfNodes: Node[] = graph.nodes.map(node => ({
      id: node.id,
      type: 'service',
      position: { x: 0, y: 0 },  // Will be set by dagre
      data: {
        name: node.name,
        teamName: node.teamName,
        status: node.status,
        isFocused: node.isFocused
      }
    }));

    const rfEdges: Edge[] = graph.edges.map((edge, i) => ({
      id: `e-${edge.source}-${edge.target}`,
      source: edge.source,
      target: edge.target,
      style: { strokeWidth: 2, stroke: '#6b7280' },
      markerEnd: { type: MarkerType.ArrowClosed, color: '#6b7280' }
    }));

    return getLayoutedElements(rfNodes, rfEdges);
  }, [graph]);

  const handleNodeClick = useCallback((_: any, node: Node) => {
    if (onNodeClick) {
      onNodeClick(node.id);
    }
  }, [onNodeClick]);

  if (isLoading) {
    return (
      <div className="h-full flex items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-gray-400" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="h-full flex items-center justify-center text-red-500">
        Failed to load dependency graph
      </div>
    );
  }

  if (nodes.length === 0) {
    return (
      <div className="h-full flex items-center justify-center text-gray-500">
        No dependencies to display
      </div>
    );
  }

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      nodeTypes={nodeTypes}
      onNodeClick={handleNodeClick}
      fitView
      fitViewOptions={{ padding: 0.2, maxZoom: 1.5 }}
      nodesDraggable={false}
      nodesConnectable={false}
      elementsSelectable={true}
      className="bg-gray-50 dark:bg-gray-900"
    >
      <Background variant={BackgroundVariant.Dots} gap={16} size={1} />
      <Controls showInteractive={false} />
      {nodes.length >= 5 && (
        <MiniMap
          nodeStrokeWidth={3}
          pannable
          zoomable
          nodeColor={(node) => {
            const status = (node.data as any)?.status;
            if (status === 'ACTIVE') return '#22c55e';
            if (status === 'DEPRECATED') return '#f59e0b';
            return '#9ca3af';
          }}
        />
      )}
    </ReactFlow>
  );
}

// Wrap with ReactFlowProvider for proper context
export function DependencyGraph(props: DependencyGraphProps) {
  return (
    <ReactFlowProvider>
      <DependencyGraphInner {...props} />
    </ReactFlowProvider>
  );
}

export default DependencyGraph;
```

Follow patterns from WorkflowCanvas.tsx for dagre layout and React Flow setup.
  </action>
  <verify>
TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
ServiceNode.tsx renders service info with status colors and focus ring. DependencyGraph.tsx uses React Flow + dagre for auto-layout, handles loading/error/empty states, supports node click callbacks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend ServicesPage with dependency management UI</name>
  <files>frontend/src/pages/ServicesPage.tsx</files>
  <action>
Extend ServicesPage.tsx to add dependency management features:

**1. Add imports:**
```typescript
import { DependencyGraph } from '@/components/services/DependencyGraph';
import {
  useServiceDependencies,
  useServiceDependents,
  useAddDependency,
  useRemoveDependency
} from '@/hooks/useServiceDependencies';
import { Network, ArrowUpRight, ArrowDownLeft, Plus, Trash2 } from 'lucide-react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
```

**2. Add state for selected service and view mode:**
```typescript
const [selectedServiceId, setSelectedServiceId] = useState<string | null>(null);
const [viewMode, setViewMode] = useState<'grid' | 'graph'>('grid');
```

**3. Add view mode toggle in the header (near the search/filter controls):**
```typescript
<div className="flex gap-2">
  <Button
    variant={viewMode === 'grid' ? 'default' : 'outline'}
    size="sm"
    onClick={() => setViewMode('grid')}
  >
    <LayoutGrid className="h-4 w-4 mr-1" />
    Grid
  </Button>
  <Button
    variant={viewMode === 'graph' ? 'default' : 'outline'}
    size="sm"
    onClick={() => setViewMode('graph')}
    disabled={!selectedServiceId}
    title={!selectedServiceId ? 'Select a service to view its dependency graph' : ''}
  >
    <Network className="h-4 w-4 mr-1" />
    Graph
  </Button>
</div>
```

**4. Add graph view content (when viewMode === 'graph' && selectedServiceId):**
```typescript
{viewMode === 'graph' && selectedServiceId && (
  <div className="h-[500px] border rounded-lg overflow-hidden">
    <DependencyGraph
      serviceId={selectedServiceId}
      onNodeClick={(id) => setSelectedServiceId(id)}
    />
  </div>
)}
```

**5. Add ServiceDetailDialog or extend existing edit dialog with dependencies tab:**

Create a new dialog or extend the existing service card to show dependencies when clicked:

```typescript
// Inside the service card, add a "View Dependencies" button
<Button
  variant="ghost"
  size="sm"
  onClick={() => {
    setSelectedServiceId(service.id);
    setShowDependenciesDialog(true);
  }}
>
  <Network className="h-4 w-4" />
</Button>
```

**6. Create DependenciesDialog component (inline or separate):**

```typescript
function DependenciesDialog({
  service,
  open,
  onClose
}: {
  service: Service;
  open: boolean;
  onClose: () => void;
}) {
  const { data: dependencies = [], isLoading: loadingDeps } = useServiceDependencies(service.id);
  const { data: dependents = [], isLoading: loadingDependents } = useServiceDependents(service.id);
  const addDependency = useAddDependency();
  const removeDependency = useRemoveDependency();
  const { data: allServices } = useServices({ status: 'ACTIVE' });

  const [addDialogOpen, setAddDialogOpen] = useState(false);
  const [selectedDependsOn, setSelectedDependsOn] = useState('');

  // Filter out services that are already dependencies or self
  const availableServices = allServices?.services.filter(
    s => s.id !== service.id && !dependencies.some(d => d.id === s.id)
  ) || [];

  const handleAddDependency = async () => {
    if (!selectedDependsOn) return;
    try {
      await addDependency.mutateAsync({
        serviceId: service.id,
        dependsOnId: selectedDependsOn
      });
      setAddDialogOpen(false);
      setSelectedDependsOn('');
      toast.success('Dependency added');
    } catch (error: any) {
      // Handle cycle error
      if (error.message?.includes('cycle')) {
        toast.error('Cannot add dependency: would create a cycle');
      } else {
        toast.error('Failed to add dependency');
      }
    }
  };

  const handleRemoveDependency = async (dependsOnId: string) => {
    try {
      await removeDependency.mutateAsync({
        serviceId: service.id,
        dependsOnId
      });
      toast.success('Dependency removed');
    } catch (error) {
      toast.error('Failed to remove dependency');
    }
  };

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Dependencies: {service.name}</DialogTitle>
        </DialogHeader>

        <Tabs defaultValue="upstream">
          <TabsList>
            <TabsTrigger value="upstream">
              <ArrowUpRight className="h-4 w-4 mr-1" />
              Depends On ({dependencies.length})
            </TabsTrigger>
            <TabsTrigger value="downstream">
              <ArrowDownLeft className="h-4 w-4 mr-1" />
              Depended On By ({dependents.length})
            </TabsTrigger>
          </TabsList>

          <TabsContent value="upstream" className="space-y-4">
            <div className="flex justify-end">
              <Button size="sm" onClick={() => setAddDialogOpen(true)}>
                <Plus className="h-4 w-4 mr-1" />
                Add Dependency
              </Button>
            </div>

            {loadingDeps ? (
              <div className="text-center py-4">Loading...</div>
            ) : dependencies.length === 0 ? (
              <div className="text-center py-4 text-gray-500">
                This service has no dependencies
              </div>
            ) : (
              <div className="space-y-2">
                {dependencies.map(dep => (
                  <div
                    key={dep.id}
                    className="flex items-center justify-between p-3 border rounded-lg"
                  >
                    <div>
                      <div className="font-medium">{dep.name}</div>
                      <div className="text-sm text-gray-500">{dep.team.name}</div>
                    </div>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => handleRemoveDependency(dep.id)}
                    >
                      <Trash2 className="h-4 w-4 text-red-500" />
                    </Button>
                  </div>
                ))}
              </div>
            )}
          </TabsContent>

          <TabsContent value="downstream" className="space-y-4">
            {loadingDependents ? (
              <div className="text-center py-4">Loading...</div>
            ) : dependents.length === 0 ? (
              <div className="text-center py-4 text-gray-500">
                No services depend on this service
              </div>
            ) : (
              <div className="space-y-2">
                {dependents.map(dep => (
                  <div
                    key={dep.id}
                    className="flex items-center justify-between p-3 border rounded-lg"
                  >
                    <div>
                      <div className="font-medium">{dep.name}</div>
                      <div className="text-sm text-gray-500">{dep.team.name}</div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </TabsContent>
        </Tabs>

        {/* Add Dependency Sub-Dialog */}
        <Dialog open={addDialogOpen} onOpenChange={setAddDialogOpen}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Add Dependency</DialogTitle>
              <DialogDescription>
                Select a service that {service.name} depends on
              </DialogDescription>
            </DialogHeader>
            <Select value={selectedDependsOn} onValueChange={setSelectedDependsOn}>
              <SelectTrigger>
                <SelectValue placeholder="Select a service" />
              </SelectTrigger>
              <SelectContent>
                {availableServices.map(s => (
                  <SelectItem key={s.id} value={s.id}>
                    {s.name} ({s.team.name})
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <DialogFooter>
              <Button variant="outline" onClick={() => setAddDialogOpen(false)}>
                Cancel
              </Button>
              <Button
                onClick={handleAddDependency}
                disabled={!selectedDependsOn || addDependency.isPending}
              >
                {addDependency.isPending ? 'Adding...' : 'Add'}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </DialogContent>
    </Dialog>
  );
}
```

**7. Wire up service card click to open dependencies dialog:**

Add click handler to service cards to select them and show dependencies.

**8. Ensure toast shows cycle error clearly:**
When addDependency fails with cycle error, the API returns 400 with `{ error: 'Adding this dependency would create a cycle' }`. Catch this in the mutation and show: `toast.error('Cannot add dependency: would create a cycle')`
  </action>
  <verify>
1. `cd frontend && npm run build` succeeds
2. Start dev server and navigate to /admin/services
3. Click on a service card to view dependencies
4. Verify upstream/downstream tabs show correct data
5. Add a dependency and verify it appears
6. Try to create a cycle (A depends on B, B depends on A) and verify error toast appears
7. Switch to Graph view and verify visualization renders with dagre layout
  </verify>
  <done>
ServicesPage has:
- View mode toggle (Grid/Graph)
- Service selection for graph view
- DependenciesDialog with upstream/downstream tabs
- Add dependency dialog with service selector
- Remove dependency button
- Cycle error displayed in toast
- DependencyGraph visualization with click-to-navigate
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd frontend && npm run build` succeeds
2. Navigate to /admin/services
3. Click a service card to view dependencies
4. Upstream tab: shows services this one depends on, can add/remove
5. Downstream tab: shows services that depend on this one (read-only)
6. Add dependency: select from dropdown, click Add, appears in list
7. Cycle rejection: try A->B->A, toast shows "Cannot add: would create a cycle"
8. Graph view: toggle to Graph, see React Flow visualization with auto-layout
9. Click node in graph: navigates to that service
</verification>

<success_criteria>
- useServiceDependencies.ts exports 5 hooks matching API endpoints
- ServiceNode renders service info with status-based styling
- DependencyGraph uses React Flow + dagre for auto-layout
- ServicesPage shows grid/graph toggle and dependencies dialog
- Adding dependency shows success toast
- Cycle rejection shows error toast with clear message
- Graph visualization allows click navigation between services
</success_criteria>

<output>
After completion, create `.planning/phases/12-service-dependencies-graph/12-02-SUMMARY.md`
</output>

---
phase: 12-service-dependencies-graph
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/types/service.ts
  - src/services/service-dependency.service.ts
  - src/routes/service.routes.ts
autonomous: true

must_haves:
  truths:
    - "Service can have dependency on another service persisted in database"
    - "Dependency creation that would form a cycle is rejected with error"
    - "Upstream dependencies (what service depends on) are queryable"
    - "Downstream dependents (what depends on service) are queryable"
    - "Graph data for visualization is retrievable via API"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Self-referential many-to-many relation on Service model"
      contains: "@relation(\"ServiceDependency\")"
    - path: "src/services/service-dependency.service.ts"
      provides: "Cycle detection and dependency CRUD operations"
      exports: ["serviceDependencyService"]
      min_lines: 100
    - path: "src/routes/service.routes.ts"
      provides: "REST endpoints for dependencies"
      contains: "/dependencies"
  key_links:
    - from: "src/routes/service.routes.ts"
      to: "src/services/service-dependency.service.ts"
      via: "import serviceDependencyService"
      pattern: "serviceDependencyService\\."
    - from: "src/services/service-dependency.service.ts"
      to: "prisma"
      via: "database queries"
      pattern: "prisma\\.service\\."
---

<objective>
Backend service dependency management with cycle detection

Purpose: Enable services to declare upstream dependencies while preventing invalid circular configurations through server-side validation

Output: Prisma schema extension, service-dependency.service.ts with DFS cycle detection, REST endpoints for dependency CRUD and graph retrieval
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-service-dependencies-graph/12-RESEARCH.md

# Phase 11 built the Service model - extend it
@.planning/phases/11-service-model-foundation/11-01-SUMMARY.md

# Existing service files to extend
@src/services/service.service.ts
@src/routes/service.routes.ts
@src/types/service.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Prisma schema with self-referential dependency relation</name>
  <files>prisma/schema.prisma</files>
  <action>
Add self-referential many-to-many relationship to the Service model for dependencies:

```prisma
model Service {
  // ... existing fields ...

  // Self-referential many-to-many for dependencies (DEP-01, DEP-02)
  // "dependsOn" = services THIS service depends on (upstream)
  // "dependedOnBy" = services that depend on THIS service (downstream)
  dependsOn      Service[] @relation("ServiceDependency")
  dependedOnBy   Service[] @relation("ServiceDependency")
}
```

This creates an implicit `_ServiceDependency` join table with `A` (dependent) and `B` (dependency) columns.

After schema change, run `npx prisma db push` to apply migration.

Do NOT create an explicit junction model - Prisma handles this automatically with implicit many-to-many.
  </action>
  <verify>
Run `npx prisma db push` succeeds without errors. Check database has `_ServiceDependency` table with `A` and `B` columns.
  </verify>
  <done>
Service model has `dependsOn` and `dependedOnBy` relations. Database schema updated with join table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create service-dependency.service.ts with cycle detection</name>
  <files>src/services/service-dependency.service.ts, src/types/service.ts</files>
  <action>
Create `src/services/service-dependency.service.ts` with the following methods:

**Types to add to src/types/service.ts:**
```typescript
export interface ServiceDependency {
  id: string;
  name: string;
  status: ServiceStatus;
  team: { id: string; name: string };
}

export interface ServiceGraphNode {
  id: string;
  name: string;
  status: ServiceStatus;
  teamName: string;
  isFocused?: boolean;
}

export interface ServiceGraphEdge {
  source: string;
  target: string;
}

export interface ServiceGraph {
  nodes: ServiceGraphNode[];
  edges: ServiceGraphEdge[];
}
```

**ServiceDependencyService class:**

1. `addDependency(serviceId: string, dependsOnId: string, userId: string)`:
   - Validate both services exist and are not the same (self-dependency = error)
   - Validate neither service is ARCHIVED (cannot add deps to/from archived)
   - Call `wouldCreateCycle()` with existing edges + proposed edge
   - If cycle detected, throw Error('Adding this dependency would create a cycle')
   - Use Prisma connect: `prisma.service.update({ where: { id: serviceId }, data: { dependsOn: { connect: { id: dependsOnId } } } })`
   - Audit log: action='service.dependency.added', resourceId=serviceId, metadata={ dependsOnId }
   - Return updated service with dependencies included

2. `removeDependency(serviceId: string, dependsOnId: string, userId: string)`:
   - Use Prisma disconnect: `prisma.service.update({ where: { id: serviceId }, data: { dependsOn: { disconnect: { id: dependsOnId } } } })`
   - Audit log: action='service.dependency.removed'
   - Return updated service

3. `getUpstream(serviceId: string)` - Direct dependencies (what this service depends on):
   - `prisma.service.findUnique({ where: { id: serviceId }, include: { dependsOn: { include: { team: { select: { id, name } } } } } })`
   - Return `dependsOn` array

4. `getDownstream(serviceId: string)` - Direct dependents (what depends on this service):
   - `prisma.service.findUnique({ where: { id: serviceId }, include: { dependedOnBy: { include: { team: { select: { id, name } } } } } })`
   - Return `dependedOnBy` array

5. `getGraph(serviceId: string, maxDepth: number = 10)` - Full connected subgraph for visualization:
   - Use recursive CTE to get all connected service IDs (both directions) up to maxDepth
   - Fetch full Service data for those IDs
   - Fetch edges from `_ServiceDependency` where both A and B are in the connected set
   - Return { nodes: ServiceGraphNode[], edges: ServiceGraphEdge[] }
   - Mark the focal service with `isFocused: true`

6. `private wouldCreateCycle(sourceId: string, targetId: string, existingEdges: { a: string; b: string }[])`:
   - Build adjacency map from existing edges + proposed edge (sourceId -> targetId)
   - DFS from targetId to see if sourceId is reachable
   - If reachable, return true (cycle exists)
   - Pattern from WorkflowCanvas.tsx lines 171-207

**SQL for getGraph recursive CTE:**
```sql
WITH RECURSIVE connected AS (
  SELECT id FROM "Service" WHERE id = $1
  UNION
  SELECT "B" as id FROM "_ServiceDependency" sd
  JOIN connected c ON sd."A" = c.id
  UNION
  SELECT "A" as id FROM "_ServiceDependency" sd
  JOIN connected c ON sd."B" = c.id
)
SELECT DISTINCT id FROM connected LIMIT 100
```

Export singleton: `export const serviceDependencyService = new ServiceDependencyService();`
  </action>
  <verify>
File compiles without TypeScript errors: `npx tsc --noEmit src/services/service-dependency.service.ts`
  </verify>
  <done>
ServiceDependencyService exists with addDependency (cycle check), removeDependency, getUpstream, getDownstream, getGraph methods. Types exported from service.ts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add dependency REST endpoints to service.routes.ts</name>
  <files>src/routes/service.routes.ts</files>
  <action>
Extend `src/routes/service.routes.ts` with these endpoints:

**Import at top:**
```typescript
import { serviceDependencyService } from '../services/service-dependency.service.js';
```

**Endpoints to add (all require auth, placed after existing service routes):**

1. `GET /api/services/:serviceId/dependencies` - List upstream dependencies (DEP-05)
   - Call `serviceDependencyService.getUpstream(serviceId)`
   - Return `{ dependencies: ServiceDependency[] }`

2. `GET /api/services/:serviceId/dependents` - List downstream dependents (DEP-05)
   - Call `serviceDependencyService.getDownstream(serviceId)`
   - Return `{ dependents: ServiceDependency[] }`

3. `POST /api/services/:serviceId/dependencies` - Add dependency (DEP-01)
   - Body schema: `{ dependsOnId: z.string().min(1) }`
   - Authorization: platform admin OR team admin of the service's owning team
   - Call `serviceDependencyService.addDependency(serviceId, dependsOnId, userId)`
   - On error 'cycle', return 400 with `{ error: 'Adding this dependency would create a cycle' }`
   - On success, return 201 with `{ service }` (includes updated dependencies)

4. `DELETE /api/services/:serviceId/dependencies/:dependsOnId` - Remove dependency (DEP-02)
   - Authorization: platform admin OR team admin of the service's owning team
   - Call `serviceDependencyService.removeDependency(serviceId, dependsOnId, userId)`
   - Return 200 with `{ service }`

5. `GET /api/services/:serviceId/graph` - Get graph data for visualization (DEP-04)
   - Query param: `depth` (optional, default 10, max 20)
   - Call `serviceDependencyService.getGraph(serviceId, depth)`
   - Return `{ graph: { nodes: [], edges: [] } }`

**Authorization pattern (copy from existing PATCH routes):**
```typescript
const existing = await serviceService.get(req.params.serviceId);
if (!existing) return res.status(404).json({ error: 'Service not found' });

const user = req.user as any;
const isPlatformAdmin = user.platformRole === 'PLATFORM_ADMIN';
const isTeamAdmin = user.teamMembers?.some(
  (m: any) => m.teamId === existing.teamId && m.role === 'TEAM_ADMIN'
);

if (!isPlatformAdmin && !isTeamAdmin) {
  return res.status(403).json({ error: 'Not authorized to modify this service' });
}
```

**Error handling for cycle detection:**
```typescript
try {
  const service = await serviceDependencyService.addDependency(...);
  return res.status(201).json({ service });
} catch (error: any) {
  if (error.message?.includes('cycle')) {
    return res.status(400).json({ error: 'Adding this dependency would create a cycle' });
  }
  // ... other error handling
}
```
  </action>
  <verify>
Server starts without errors: `npm run build && npm run dev` (or check TypeScript compilation).
Test endpoints manually:
- `curl http://localhost:3000/api/services/{id}/dependencies` returns 200
- `curl http://localhost:3000/api/services/{id}/dependents` returns 200
- `curl http://localhost:3000/api/services/{id}/graph` returns 200
  </verify>
  <done>
Five new endpoints added: GET dependencies, GET dependents, POST dependencies (with cycle rejection), DELETE dependencies, GET graph. All endpoints return correct response shapes.
  </done>
</task>

</tasks>

<verification>
1. Schema migration applied: `_ServiceDependency` table exists in database
2. TypeScript compiles: `npm run build` succeeds
3. Server runs: `npm run dev` starts without errors
4. API responses correct:
   - GET /api/services/:id/dependencies -> { dependencies: [] }
   - GET /api/services/:id/dependents -> { dependents: [] }
   - POST /api/services/:id/dependencies with cycle -> 400 error
   - GET /api/services/:id/graph -> { graph: { nodes: [], edges: [] } }
</verification>

<success_criteria>
- Service model has dependsOn/dependedOnBy self-referential relations
- ServiceDependencyService implements DFS cycle detection
- REST endpoints exist for all dependency operations (CRUD + graph)
- Cycle creation returns 400 error with descriptive message
- Upstream and downstream queries return correct directions
</success_criteria>

<output>
After completion, create `.planning/phases/12-service-dependencies-graph/12-01-SUMMARY.md`
</output>

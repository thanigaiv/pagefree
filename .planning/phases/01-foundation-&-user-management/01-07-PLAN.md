---
phase: 01-foundation-&-user-management
plan: 07
type: execute
wave: 5
depends_on: ["01-04", "01-06"]
files_modified:
  - src/routes/user.routes.ts
  - src/services/user.service.ts
  - src/services/contact.service.ts
  - src/services/notification.service.ts
  - src/routes/notification.routes.ts
  - src/routes/mobile.routes.ts
  - src/index.ts
  - package.json
autonomous: true
user_setup:
  - service: aws_ses
    why: "Email sending for verification codes"
    env_vars:
      - name: AWS_REGION
        source: "AWS Console - SES region (e.g., us-east-1)"
      - name: AWS_SES_FROM_EMAIL
        source: "Verified sender email in AWS SES"
      - name: AWS_ACCESS_KEY_ID
        source: "AWS Console -> IAM -> Create user with SES permissions"
      - name: AWS_SECRET_ACCESS_KEY
        source: "AWS Console -> IAM -> Access key secret"
    dashboard_config:
      - task: "Verify sender email address"
        location: "AWS Console -> SES -> Verified identities"
  - service: twilio
    why: "SMS sending for verification codes"
    env_vars:
      - name: TWILIO_ACCOUNT_SID
        source: "Twilio Console -> Account Info"
      - name: TWILIO_AUTH_TOKEN
        source: "Twilio Console -> Account Info"
      - name: TWILIO_PHONE_NUMBER
        source: "Twilio Console -> Phone Numbers -> Your number"
    dashboard_config:
      - task: "Purchase phone number"
        location: "Twilio Console -> Phone Numbers -> Buy a Number"

must_haves:
  truths:
    - "User can view their profile"
    - "User can update notification preferences"
    - "User can initiate contact verification"
    - "Contact verification codes are sent via email/SMS"
    - "Contact verification codes expire after 15 minutes"
    - "Mobile app can obtain long-lived refresh token"
    - "Mobile app can refresh session using refresh token"
  artifacts:
    - path: "src/routes/user.routes.ts"
      provides: "User profile API"
      exports: ["userRouter"]
    - path: "src/services/contact.service.ts"
      provides: "Contact verification service"
      exports: ["contactService"]
    - path: "src/services/notification.service.ts"
      provides: "Basic email/SMS sending"
      exports: ["notificationService"]
    - path: "src/routes/notification.routes.ts"
      provides: "Notification preferences API"
      exports: ["notificationRouter"]
    - path: "src/routes/mobile.routes.ts"
      provides: "Mobile refresh token API"
      exports: ["mobileRouter"]
  key_links:
    - from: "src/routes/user.routes.ts"
      to: "prisma.user"
      via: "profile queries"
      pattern: "prisma\\.user\\.findUnique"
    - from: "src/services/contact.service.ts"
      to: "prisma.contactVerification"
      via: "verification records"
      pattern: "prisma\\.contactVerification"
    - from: "src/services/contact.service.ts"
      to: "src/services/notification.service.ts"
      via: "send verification messages"
      pattern: "notificationService\\.send"
    - from: "src/routes/mobile.routes.ts"
      to: "prisma.refreshToken"
      via: "token issuance and validation"
      pattern: "prisma\\.refreshToken\\.(create|findFirst)"
---

<objective>
Implement user profile viewing, notification preferences management, contact verification with actual email/SMS sending, and mobile refresh token flow.

Purpose: Per user decision, profile data is read-only (synced from Okta), but notification preferences are managed in platform. Contact verification is required for on-call engineers with independent verification (send test notifications). Mobile devices need long-lived refresh tokens for 24/7 on-call scenarios.
Output: User profile API, notification preferences CRUD, contact verification with email/SMS delivery, mobile refresh token issuance and validation.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
@.planning/phases/01-foundation-&-user-management/01-01-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-04-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user profile service and routes</name>
  <files>
    src/services/user.service.ts
    src/routes/user.routes.ts
  </files>
  <action>
    1. Create src/services/user.service.ts:
       ```typescript
       import { prisma } from '../config/database';
       import { auditService } from './audit.service';

       export class UserService {
         // Get user profile with all related data
         async getProfile(userId: string) {
           const user = await prisma.user.findUnique({
             where: { id: userId },
             include: {
               teamMembers: {
                 where: { team: { isActive: true } },
                 include: {
                   team: {
                     select: {
                       id: true,
                       name: true,
                       description: true
                     }
                   }
                 }
               },
               notificationPreferences: true,
               devices: {
                 select: {
                   id: true,
                   platform: true,
                   deviceName: true,
                   lastSeenAt: true
                 }
               }
             }
           });

           if (!user) return null;

           return {
             id: user.id,
             email: user.email,
             firstName: user.firstName,
             lastName: user.lastName,
             phone: user.phone,
             platformRole: user.platformRole,
             syncedFromOkta: user.syncedFromOkta,
             // Verification status
             verification: {
               email: user.emailVerified,
               phone: user.phoneVerified,
               push: user.pushEnabled
             },
             // Teams with roles
             teams: user.teamMembers.map(m => ({
               id: m.team.id,
               name: m.team.name,
               description: m.team.description,
               role: m.role,
               joinedAt: m.joinedAt
             })),
             // Notification preferences
             notificationPreferences: user.notificationPreferences.map(p => ({
               channel: p.channel,
               enabled: p.enabled,
               priority: p.priority
             })),
             // Registered devices
             devices: user.devices,
             createdAt: user.createdAt,
             updatedAt: user.updatedAt
           };
         }

         // List all active users (for admin views)
         async listUsers(params: {
           teamId?: string;
           role?: string;
           includeInactive?: boolean;
           limit?: number;
           offset?: number;
         }) {
           const where: any = {};

           if (!params.includeInactive) {
             where.isActive = true;
           }

           if (params.teamId) {
             where.teamMembers = {
               some: { teamId: params.teamId }
             };
           }

           if (params.role) {
             where.platformRole = params.role;
           }

           const [users, total] = await Promise.all([
             prisma.user.findMany({
               where,
               select: {
                 id: true,
                 email: true,
                 firstName: true,
                 lastName: true,
                 platformRole: true,
                 isActive: true,
                 emailVerified: true,
                 phoneVerified: true,
                 pushEnabled: true,
                 createdAt: true,
                 teamMembers: {
                   include: {
                     team: { select: { id: true, name: true } }
                   }
                 }
               },
               skip: params.offset || 0,
               take: params.limit || 50,
               orderBy: { lastName: 'asc' }
             }),
             prisma.user.count({ where })
           ]);

           return { users, total };
         }

         // Update platform role (admin only)
         async updateRole(userId: string, newRole: 'PLATFORM_ADMIN' | 'USER', adminUserId: string) {
           const user = await prisma.user.update({
             where: { id: userId },
             data: { platformRole: newRole }
           });

           await auditService.log({
             action: 'user.role.updated',
             userId: adminUserId,
             resourceType: 'user',
             resourceId: userId,
             metadata: {
               newRole,
               targetUser: user.email
             }
           });

           return user;
         }
       }

       export const userService = new UserService();
       ```

    2. Create src/routes/user.routes.ts:
       ```typescript
       import { Router } from 'express';
       import { z } from 'zod';
       import { requireAuth, requirePlatformAdmin } from '../middleware/auth';
       import { userService } from '../services/user.service';

       export const userRouter = Router();

       // All user routes require authentication
       userRouter.use(requireAuth);

       // GET /api/users/me - Get current user's profile
       userRouter.get('/me', async (req, res) => {
         try {
           const profile = await userService.getProfile((req.user as any).id);
           if (!profile) {
             return res.status(404).json({ error: 'User not found' });
           }
           res.json(profile);
         } catch (error) {
           res.status(500).json({ error: 'Failed to get profile' });
         }
       });

       // GET /api/users/:id - Get specific user's profile (admin or self)
       userRouter.get('/:id', async (req, res) => {
         const currentUser = req.user as any;
         const targetId = req.params.id;

         // Can view self or if platform admin
         if (targetId !== currentUser.id && currentUser.platformRole !== 'PLATFORM_ADMIN') {
           return res.status(403).json({ error: 'Cannot view other users' });
         }

         try {
           const profile = await userService.getProfile(targetId);
           if (!profile) {
             return res.status(404).json({ error: 'User not found' });
           }
           res.json(profile);
         } catch (error) {
           res.status(500).json({ error: 'Failed to get profile' });
         }
       });

       // GET /api/users - List users (admin only)
       const ListUsersSchema = z.object({
         teamId: z.string().optional(),
         role: z.enum(['PLATFORM_ADMIN', 'USER']).optional(),
         includeInactive: z.coerce.boolean().optional(),
         limit: z.coerce.number().min(1).max(100).default(50),
         offset: z.coerce.number().min(0).default(0)
       });

       userRouter.get('/', requirePlatformAdmin, async (req, res) => {
         try {
           const params = ListUsersSchema.parse(req.query);
           const result = await userService.listUsers(params);
           res.json(result);
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid query parameters' });
           }
           res.status(500).json({ error: 'Failed to list users' });
         }
       });

       // PATCH /api/users/:id/role - Update user's platform role (admin only)
       const UpdateRoleSchema = z.object({
         role: z.enum(['PLATFORM_ADMIN', 'USER'])
       });

       userRouter.patch('/:id/role', requirePlatformAdmin, async (req, res) => {
         try {
           const { role } = UpdateRoleSchema.parse(req.body);
           const user = await userService.updateRole(
             req.params.id,
             role,
             (req.user as any).id
           );
           res.json({
             id: user.id,
             email: user.email,
             platformRole: user.platformRole
           });
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid role' });
           }
           res.status(500).json({ error: 'Failed to update role' });
         }
       });

       // Note: Profile data (name, email, phone) is read-only - synced from Okta via SCIM
       // No PUT/PATCH for profile fields - redirect users to update in Okta
       ```
  </action>
  <verify>
    npx tsc --noEmit passes
    Routes export correctly
  </verify>
  <done>
    User profile API with self-view, admin list, and role management. Profile data read-only per user decision.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create basic notification service and update contact verification to send actual messages</name>
  <files>
    src/services/notification.service.ts
    src/services/contact.service.ts
    package.json
  </files>
  <action>
    1. Install notification dependencies:
       ```bash
       npm install @aws-sdk/client-ses twilio
       ```

    2. Create src/services/notification.service.ts:
       ```typescript
       import { SESClient, SendEmailCommand } from '@aws-sdk/client-ses';
       import twilio from 'twilio';
       import { env } from '../config/env';

       export class NotificationService {
         private sesClient: SESClient;
         private twilioClient: any;

         constructor() {
           // Initialize AWS SES
           this.sesClient = new SESClient({
             region: env.AWS_REGION,
             credentials: {
               accessKeyId: env.AWS_ACCESS_KEY_ID,
               secretAccessKey: env.AWS_SECRET_ACCESS_KEY
             }
           });

           // Initialize Twilio
           this.twilioClient = twilio(
             env.TWILIO_ACCOUNT_SID,
             env.TWILIO_AUTH_TOKEN
           );
         }

         async sendEmail(to: string, subject: string, body: string): Promise<boolean> {
           try {
             const command = new SendEmailCommand({
               Source: env.AWS_SES_FROM_EMAIL,
               Destination: { ToAddresses: [to] },
               Message: {
                 Subject: { Data: subject },
                 Body: {
                   Text: { Data: body },
                   Html: { Data: body } // Send same content as HTML
                 }
               }
             });

             await this.sesClient.send(command);
             return true;
           } catch (error) {
             console.error('Email send failed:', error);
             return false;
           }
         }

         async sendSMS(to: string, body: string): Promise<boolean> {
           try {
             await this.twilioClient.messages.create({
               from: env.TWILIO_PHONE_NUMBER,
               to,
               body
             });
             return true;
           } catch (error) {
             console.error('SMS send failed:', error);
             return false;
           }
         }

         // Format verification email
         buildVerificationEmail(code: string): { subject: string; body: string } {
           return {
             subject: 'OnCall Platform - Email Verification Code',
             body: `
Your verification code is: ${code}

This code will expire in 15 minutes.

If you did not request this code, please ignore this email.

-- OnCall Platform
             `.trim()
           };
         }

         // Format verification SMS
         buildVerificationSMS(code: string): string {
           return `OnCall Platform verification code: ${code}. Expires in 15 minutes.`;
         }
       }

       export const notificationService = new NotificationService();
       ```

    3. Update src/services/contact.service.ts to use notification service:
       ```typescript
       import crypto from 'crypto';
       import { prisma } from '../config/database';
       import { auditService } from './audit.service';
       import { notificationService } from './notification.service';

       type VerificationMethod = 'email' | 'sms' | 'push';

       export class ContactVerificationService {
         private CODE_EXPIRY_MINUTES = 15;
         private CODE_LENGTH = 6;

         // Generate 6-digit numeric code
         private generateCode(): string {
           return crypto.randomInt(100000, 999999).toString();
         }

         // Initiate verification for a contact method
         async sendVerification(userId: string, method: VerificationMethod, value: string) {
           // Check for recent verification to prevent spam
           const recent = await prisma.contactVerification.findFirst({
             where: {
               userId,
               method,
               value,
               createdAt: { gt: new Date(Date.now() - 60 * 1000) } // Last 1 minute
             }
           });

           if (recent) {
             throw new Error('Verification already sent recently. Please wait.');
           }

           const code = this.generateCode();
           const expiresAt = new Date(Date.now() + this.CODE_EXPIRY_MINUTES * 60 * 1000);

           // Invalidate any existing pending verifications for this method
           await prisma.contactVerification.updateMany({
             where: {
               userId,
               method,
               verified: false
             },
             data: {
               expiresAt: new Date() // Expire immediately
             }
           });

           // Create new verification
           const verification = await prisma.contactVerification.create({
             data: {
               userId,
               method,
               value: this.maskValue(method, value), // Store masked value for security
               code,
               expiresAt
             }
           });

           // Send the actual verification message
           // Per user decision: "Independent verification required even though data comes from Okta (send test notifications)"
           let sendSuccess = false;
           try {
             sendSuccess = await this.sendVerificationMessage(method, value, code);
           } catch (error) {
             console.error(`Failed to send ${method} verification:`, error);
             // Don't throw - verification still created for retry
           }

           await auditService.log({
             action: 'contact.verification.sent',
             userId,
             metadata: {
               method,
               value: this.maskValue(method, value),
               expiresAt: expiresAt.toISOString(),
               sendSuccess
             }
           });

           return {
             id: verification.id,
             method,
             expiresAt,
             sendSuccess,
             // In dev mode, include code for testing
             ...(process.env.NODE_ENV === 'development' && { code })
           };
         }

         // Verify the code
         async verifyCode(userId: string, method: VerificationMethod, code: string) {
           const verification = await prisma.contactVerification.findFirst({
             where: {
               userId,
               method,
               code,
               verified: false,
               expiresAt: { gt: new Date() }
             }
           });

           if (!verification) {
             await auditService.log({
               action: 'contact.verification.failed',
               userId,
               metadata: { method, reason: 'invalid_or_expired_code' }
             });
             throw new Error('Invalid or expired verification code');
           }

           // Mark as verified
           await prisma.contactVerification.update({
             where: { id: verification.id },
             data: {
               verified: true,
               verifiedAt: new Date()
             }
           });

           // Update user's verification status
           const updateData: any = {};
           if (method === 'email') updateData.emailVerified = true;
           if (method === 'sms') updateData.phoneVerified = true;
           if (method === 'push') updateData.pushEnabled = true;

           await prisma.user.update({
             where: { id: userId },
             data: updateData
           });

           await auditService.log({
             action: 'contact.verification.completed',
             userId,
             metadata: { method }
           });

           return { success: true, method };
         }

         // Check verification status
         async getVerificationStatus(userId: string) {
           const user = await prisma.user.findUnique({
             where: { id: userId },
             select: {
               email: true,
               phone: true,
               emailVerified: true,
               phoneVerified: true,
               pushEnabled: true,
               devices: {
                 select: { id: true, platform: true }
               }
             }
           });

           if (!user) return null;

           // Per user decision: All three required for on-call engineers
           const allVerified = user.emailVerified && user.phoneVerified && user.pushEnabled;

           return {
             email: {
               value: user.email ? this.maskValue('email', user.email) : null,
               verified: user.emailVerified
             },
             phone: {
               value: user.phone ? this.maskValue('sms', user.phone) : null,
               verified: user.phoneVerified
             },
             push: {
               verified: user.pushEnabled,
               deviceCount: user.devices.length
             },
             allVerified,
             canBeOnCall: allVerified
           };
         }

         // Mask value for security
         private maskValue(method: VerificationMethod, value: string): string {
           if (method === 'email') {
             const [local, domain] = value.split('@');
             return `${local.slice(0, 2)}***@${domain}`;
           }
           if (method === 'sms') {
             return `***${value.slice(-4)}`;
           }
           return '***';
         }

         // Send verification message using notification service
         private async sendVerificationMessage(method: VerificationMethod, value: string, code: string): Promise<boolean> {
           if (method === 'email') {
             const { subject, body } = notificationService.buildVerificationEmail(code);
             return await notificationService.sendEmail(value, subject, body);
           }

           if (method === 'sms') {
             const body = notificationService.buildVerificationSMS(code);
             return await notificationService.sendSMS(value, body);
           }

           if (method === 'push') {
             // Push verification: User must have registered device
             // This is verified by device registration, not by sending a code
             return true;
           }

           return false;
         }
       }

       export const contactService = new ContactVerificationService();
       ```

    4. Update .env.example:
       ```
       # AWS SES for email (verification codes)
       AWS_REGION=us-east-1
       AWS_SES_FROM_EMAIL=noreply@oncall.example.com
       AWS_ACCESS_KEY_ID=
       AWS_SECRET_ACCESS_KEY=

       # Twilio for SMS (verification codes)
       TWILIO_ACCOUNT_SID=
       TWILIO_AUTH_TOKEN=
       TWILIO_PHONE_NUMBER=
       ```

    5. Update src/config/env.ts to include new env vars:
       ```typescript
       // Add to schema:
       AWS_REGION: z.string().default('us-east-1'),
       AWS_SES_FROM_EMAIL: z.string().email(),
       AWS_ACCESS_KEY_ID: z.string(),
       AWS_SECRET_ACCESS_KEY: z.string(),
       TWILIO_ACCOUNT_SID: z.string(),
       TWILIO_AUTH_TOKEN: z.string(),
       TWILIO_PHONE_NUMBER: z.string(),
       ```
  </action>
  <verify>
    npm install completes successfully
    npx tsc --noEmit passes
    NotificationService exports correctly
    ContactVerificationService updated to use notificationService
  </verify>
  <done>
    Basic email/SMS sending implemented using AWS SES and Twilio. Contact verification now sends actual messages per user decision.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create notification preferences routes, mobile refresh token routes, and mount all routes</name>
  <files>
    src/routes/notification.routes.ts
    src/routes/mobile.routes.ts
    src/index.ts
  </files>
  <action>
    1. Create src/routes/notification.routes.ts:
       ```typescript
       import { Router } from 'express';
       import { z } from 'zod';
       import { prisma } from '../config/database';
       import { requireAuth } from '../middleware/auth';
       import { contactService } from '../services/contact.service';
       import { auditService } from '../services/audit.service';

       export const notificationRouter = Router();

       notificationRouter.use(requireAuth);

       // GET /api/notifications/preferences - Get current user's preferences
       notificationRouter.get('/preferences', async (req, res) => {
         try {
           const userId = (req.user as any).id;

           const preferences = await prisma.notificationPreference.findMany({
             where: { userId },
             orderBy: { priority: 'asc' }
           });

           res.json({
             preferences: preferences.map(p => ({
               id: p.id,
               channel: p.channel,
               enabled: p.enabled,
               priority: p.priority
             }))
           });
         } catch (error) {
           res.status(500).json({ error: 'Failed to get preferences' });
         }
       });

       // PUT /api/notifications/preferences - Update preferences
       const UpdatePreferencesSchema = z.object({
         preferences: z.array(z.object({
           channel: z.enum(['EMAIL', 'SMS', 'PUSH', 'SLACK', 'VOICE']),
           enabled: z.boolean(),
           priority: z.number().min(1).max(10)
         }))
       });

       notificationRouter.put('/preferences', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { preferences } = UpdatePreferencesSchema.parse(req.body);

           // Delete existing and recreate (simplest approach)
           await prisma.notificationPreference.deleteMany({
             where: { userId }
           });

           const created = await prisma.notificationPreference.createMany({
             data: preferences.map(p => ({
               userId,
               channel: p.channel,
               enabled: p.enabled,
               priority: p.priority
             }))
           });

           await auditService.log({
             action: 'user.preferences.updated',
             userId,
             metadata: {
               channels: preferences.map(p => p.channel)
             }
           });

           // Fetch and return the created preferences
           const updated = await prisma.notificationPreference.findMany({
             where: { userId },
             orderBy: { priority: 'asc' }
           });

           res.json({ preferences: updated });
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid preferences data' });
           }
           res.status(500).json({ error: 'Failed to update preferences' });
         }
       });

       // GET /api/notifications/verification/status - Get verification status
       notificationRouter.get('/verification/status', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const status = await contactService.getVerificationStatus(userId);

           if (!status) {
             return res.status(404).json({ error: 'User not found' });
           }

           res.json(status);
         } catch (error) {
           res.status(500).json({ error: 'Failed to get verification status' });
         }
       });

       // POST /api/notifications/verification/send - Send verification code
       const SendVerificationSchema = z.object({
         method: z.enum(['email', 'sms', 'push']),
         value: z.string().optional() // Required for email/sms, not for push
       });

       notificationRouter.post('/verification/send', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { method, value } = SendVerificationSchema.parse(req.body);

           // For email/sms, get value from user profile if not provided
           let targetValue = value;
           if (!targetValue && (method === 'email' || method === 'sms')) {
             const user = await prisma.user.findUnique({
               where: { id: userId },
               select: { email: true, phone: true }
             });

             if (method === 'email') targetValue = user?.email;
             if (method === 'sms') targetValue = user?.phone;
           }

           if (!targetValue && method !== 'push') {
             return res.status(400).json({
               error: `No ${method === 'email' ? 'email' : 'phone'} address available`
             });
           }

           const result = await contactService.sendVerification(
             userId,
             method,
             targetValue || ''
           );

           res.json(result);
         } catch (error) {
           if (error.message?.includes('already sent')) {
             return res.status(429).json({ error: error.message });
           }
           res.status(500).json({ error: 'Failed to send verification' });
         }
       });

       // POST /api/notifications/verification/verify - Verify code
       const VerifyCodeSchema = z.object({
         method: z.enum(['email', 'sms', 'push']),
         code: z.string().length(6)
       });

       notificationRouter.post('/verification/verify', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { method, code } = VerifyCodeSchema.parse(req.body);

           const result = await contactService.verifyCode(userId, method, code);
           res.json(result);
         } catch (error) {
           if (error.message?.includes('Invalid or expired')) {
             return res.status(400).json({ error: error.message });
           }
           res.status(500).json({ error: 'Failed to verify code' });
         }
       });

       // POST /api/notifications/devices - Register device for push
       const RegisterDeviceSchema = z.object({
         platform: z.enum(['ios', 'android', 'web']),
         deviceToken: z.string(),
         deviceName: z.string().optional()
       });

       notificationRouter.post('/devices', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { platform, deviceToken, deviceName } = RegisterDeviceSchema.parse(req.body);

           const device = await prisma.userDevice.upsert({
             where: {
               userId_deviceToken: { userId, deviceToken }
             },
             create: {
               userId,
               platform,
               deviceToken,
               deviceName,
               lastSeenAt: new Date()
             },
             update: {
               platform,
               deviceName,
               lastSeenAt: new Date()
             }
           });

           await auditService.log({
             action: 'device.registered',
             userId,
             metadata: { platform, deviceId: device.id }
           });

           res.json({
             id: device.id,
             platform: device.platform,
             deviceName: device.deviceName
           });
         } catch (error) {
           res.status(500).json({ error: 'Failed to register device' });
         }
       });

       // DELETE /api/notifications/devices/:id - Unregister device
       notificationRouter.delete('/devices/:id', async (req, res) => {
         try {
           const userId = (req.user as any).id;

           await prisma.userDevice.deleteMany({
             where: {
               id: req.params.id,
               userId // Ensure user owns the device
             }
           });

           await auditService.log({
             action: 'device.unregistered',
             userId,
             metadata: { deviceId: req.params.id }
           });

           res.json({ success: true });
         } catch (error) {
           res.status(500).json({ error: 'Failed to unregister device' });
         }
       });
       ```

    2. Create src/routes/mobile.routes.ts for refresh token flow:
       ```typescript
       import { Router } from 'express';
       import crypto from 'crypto';
       import { z } from 'zod';
       import { prisma } from '../config/database';
       import { requireAuth } from '../middleware/auth';
       import { auditService } from '../services/audit.service';

       export const mobileRouter = Router();

       // POST /api/mobile/token - Issue refresh token after Okta auth
       // Per user decision: "Long-lived refresh tokens after initial Okta auth (for 24/7 on-call scenarios)"
       const IssueTokenSchema = z.object({
         deviceInfo: z.string().optional()
       });

       mobileRouter.post('/token', requireAuth, async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { deviceInfo } = IssueTokenSchema.parse(req.body);

           // Generate secure random token
           const token = crypto.randomBytes(32).toString('hex');

           // Hash token before storing (don't store plaintext)
           const hashedToken = crypto.createHash('sha256').update(token).digest('hex');

           // Create refresh token with 90-day expiry
           const refreshToken = await prisma.refreshToken.create({
             data: {
               userId,
               token: hashedToken,
               deviceInfo: deviceInfo || req.get('user-agent') || 'unknown',
               expiresAt: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days
               lastUsedAt: new Date()
             }
           });

           await auditService.log({
             action: 'mobile.token.issued',
             userId,
             metadata: {
               tokenId: refreshToken.id,
               deviceInfo: refreshToken.deviceInfo
             }
           });

           // Return plaintext token to client (only time it's visible)
           res.json({
             refreshToken: token,
             expiresAt: refreshToken.expiresAt
           });
         } catch (error) {
           res.status(500).json({ error: 'Failed to issue refresh token' });
         }
       });

       // POST /api/mobile/refresh - Refresh session using refresh token
       const RefreshSessionSchema = z.object({
         refreshToken: z.string()
       });

       mobileRouter.post('/refresh', async (req, res) => {
         try {
           const { refreshToken } = RefreshSessionSchema.parse(req.body);

           // Hash provided token to compare with stored hash
           const hashedToken = crypto.createHash('sha256').update(refreshToken).digest('hex');

           // Find valid refresh token
           const tokenRecord = await prisma.refreshToken.findFirst({
             where: {
               token: hashedToken,
               expiresAt: { gt: new Date() }
             },
             include: {
               user: {
                 select: {
                   id: true,
                   email: true,
                   firstName: true,
                   lastName: true,
                   platformRole: true,
                   isActive: true,
                   teamMembers: {
                     where: { team: { isActive: true } },
                     include: {
                       team: { select: { id: true, name: true } }
                     }
                   }
                 }
               }
             }
           });

           if (!tokenRecord) {
             await auditService.log({
               action: 'mobile.refresh.failed',
               severity: 'WARN',
               metadata: { reason: 'invalid_or_expired_token' }
             });
             return res.status(401).json({ error: 'Invalid or expired refresh token' });
           }

           // Check if user is still active
           if (!tokenRecord.user.isActive) {
             await auditService.log({
               action: 'mobile.refresh.failed',
               userId: tokenRecord.user.id,
               severity: 'WARN',
               metadata: { reason: 'user_deactivated' }
             });
             return res.status(401).json({ error: 'User account is deactivated' });
           }

           // Update last used timestamp
           await prisma.refreshToken.update({
             where: { id: tokenRecord.id },
             data: { lastUsedAt: new Date() }
           });

           await auditService.log({
             action: 'mobile.refresh.success',
             userId: tokenRecord.user.id,
             metadata: { tokenId: tokenRecord.id }
           });

           // Return user session data
           res.json({
             user: {
               id: tokenRecord.user.id,
               email: tokenRecord.user.email,
               firstName: tokenRecord.user.firstName,
               lastName: tokenRecord.user.lastName,
               platformRole: tokenRecord.user.platformRole,
               teams: tokenRecord.user.teamMembers.map(m => ({
                 id: m.team.id,
                 name: m.team.name,
                 role: m.role
               }))
             }
           });
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid request' });
           }
           res.status(500).json({ error: 'Failed to refresh session' });
         }
       });

       // DELETE /api/mobile/token - Revoke refresh token (logout)
       const RevokeTokenSchema = z.object({
         refreshToken: z.string()
       });

       mobileRouter.delete('/token', async (req, res) => {
         try {
           const { refreshToken } = RevokeTokenSchema.parse(req.body);
           const hashedToken = crypto.createHash('sha256').update(refreshToken).digest('hex');

           const tokenRecord = await prisma.refreshToken.findFirst({
             where: { token: hashedToken }
           });

           if (tokenRecord) {
             await prisma.refreshToken.delete({
               where: { id: tokenRecord.id }
             });

             await auditService.log({
               action: 'mobile.token.revoked',
               userId: tokenRecord.userId,
               metadata: { tokenId: tokenRecord.id }
             });
           }

           res.json({ success: true });
         } catch (error) {
           res.status(500).json({ error: 'Failed to revoke token' });
         }
       });

       // GET /api/mobile/tokens - List user's active refresh tokens
       mobileRouter.get('/tokens', requireAuth, async (req, res) => {
         try {
           const userId = (req.user as any).id;

           const tokens = await prisma.refreshToken.findMany({
             where: {
               userId,
               expiresAt: { gt: new Date() }
             },
             select: {
               id: true,
               deviceInfo: true,
               lastUsedAt: true,
               expiresAt: true,
               createdAt: true
             },
             orderBy: { lastUsedAt: 'desc' }
           });

           res.json({ tokens });
         } catch (error) {
           res.status(500).json({ error: 'Failed to list tokens' });
         }
       });
       ```

    3. Update src/index.ts to mount all user routes:
       ```typescript
       import { userRouter } from './routes/user.routes';
       import { notificationRouter } from './routes/notification.routes';
       import { mobileRouter } from './routes/mobile.routes';

       // Mount user routes
       app.use('/api/users', userRouter);
       app.use('/api/notifications', notificationRouter);
       app.use('/api/mobile', mobileRouter);
       ```
  </action>
  <verify>
    npm run dev starts without errors
    GET /api/users/me returns current user profile
    GET /api/notifications/preferences returns preferences
    POST /api/notifications/verification/send sends email/SMS with code
    POST /api/mobile/token issues refresh token
    POST /api/mobile/refresh validates token and returns user data
  </verify>
  <done>
    Notification preferences CRUD, contact verification flow with actual email/SMS sending, device registration, and mobile refresh token issuance/validation flow implemented per user decisions.
  </done>
</task>

</tasks>

<verification>
1. GET /api/users/me returns user profile with teams and verification status
2. Profile data is read-only (no PUT/PATCH for name/email/phone)
3. PUT /api/notifications/preferences updates notification channels
4. POST /api/notifications/verification/send creates verification and sends actual email/SMS
5. POST /api/notifications/verification/verify validates code and updates user
6. POST /api/notifications/devices registers device for push notifications
7. Verification status shows canBeOnCall: true only when all three verified
8. POST /api/mobile/token issues 90-day refresh token after Okta auth
9. POST /api/mobile/refresh validates refresh token and returns user session data
10. DELETE /api/mobile/token revokes refresh token
</verification>

<success_criteria>
- User profile read-only (per user decision: synced from Okta)
- Notification preferences managed in platform (per user decision)
- Contact verification sends actual email/SMS (per user decision: "Independent verification required even though data comes from Okta")
- Mobile refresh tokens issued with 90-day expiry (per user decision: "Long-lived refresh tokens after initial Okta auth for 24/7 on-call scenarios")
- Refresh token validation supports mobile app sessions
- 15-minute code expiry implemented
- All preference changes logged to audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-07-SUMMARY.md`
</output>

---
phase: 01-foundation-&-user-management
plan: 07
type: execute
wave: 5
depends_on: ["01-04", "01-06"]
files_modified:
  - src/routes/user.routes.ts
  - src/services/user.service.ts
  - src/services/contact.service.ts
  - src/routes/notification.routes.ts
autonomous: true

must_haves:
  truths:
    - "User can view their profile"
    - "User can update notification preferences"
    - "User can initiate contact verification"
    - "Contact verification codes expire after 15 minutes"
  artifacts:
    - path: "src/routes/user.routes.ts"
      provides: "User profile API"
      exports: ["userRouter"]
    - path: "src/services/contact.service.ts"
      provides: "Contact verification service"
      exports: ["contactService"]
    - path: "src/routes/notification.routes.ts"
      provides: "Notification preferences API"
      exports: ["notificationRouter"]
  key_links:
    - from: "src/routes/user.routes.ts"
      to: "prisma.user"
      via: "profile queries"
      pattern: "prisma\\.user\\.findUnique"
    - from: "src/services/contact.service.ts"
      to: "prisma.contactVerification"
      via: "verification records"
      pattern: "prisma\\.contactVerification"
---

<objective>
Implement user profile viewing and notification preferences management with contact verification.

Purpose: Per user decision, profile data is read-only (synced from Okta), but notification preferences are managed in platform. Contact verification is required for on-call engineers.
Output: User profile API, notification preferences CRUD, contact verification with code expiry.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
@.planning/phases/01-foundation-&-user-management/01-01-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-04-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create user profile service and routes</name>
  <files>
    src/services/user.service.ts
    src/routes/user.routes.ts
  </files>
  <action>
    1. Create src/services/user.service.ts:
       ```typescript
       import { prisma } from '../config/database';
       import { auditService } from './audit.service';

       export class UserService {
         // Get user profile with all related data
         async getProfile(userId: string) {
           const user = await prisma.user.findUnique({
             where: { id: userId },
             include: {
               teamMembers: {
                 where: { team: { isActive: true } },
                 include: {
                   team: {
                     select: {
                       id: true,
                       name: true,
                       description: true
                     }
                   }
                 }
               },
               notificationPreferences: true,
               devices: {
                 select: {
                   id: true,
                   platform: true,
                   deviceName: true,
                   lastSeenAt: true
                 }
               }
             }
           });

           if (!user) return null;

           return {
             id: user.id,
             email: user.email,
             firstName: user.firstName,
             lastName: user.lastName,
             phone: user.phone,
             platformRole: user.platformRole,
             syncedFromOkta: user.syncedFromOkta,
             // Verification status
             verification: {
               email: user.emailVerified,
               phone: user.phoneVerified,
               push: user.pushEnabled
             },
             // Teams with roles
             teams: user.teamMembers.map(m => ({
               id: m.team.id,
               name: m.team.name,
               description: m.team.description,
               role: m.role,
               joinedAt: m.joinedAt
             })),
             // Notification preferences
             notificationPreferences: user.notificationPreferences.map(p => ({
               channel: p.channel,
               enabled: p.enabled,
               priority: p.priority
             })),
             // Registered devices
             devices: user.devices,
             createdAt: user.createdAt,
             updatedAt: user.updatedAt
           };
         }

         // List all active users (for admin views)
         async listUsers(params: {
           teamId?: string;
           role?: string;
           includeInactive?: boolean;
           limit?: number;
           offset?: number;
         }) {
           const where: any = {};

           if (!params.includeInactive) {
             where.isActive = true;
           }

           if (params.teamId) {
             where.teamMembers = {
               some: { teamId: params.teamId }
             };
           }

           if (params.role) {
             where.platformRole = params.role;
           }

           const [users, total] = await Promise.all([
             prisma.user.findMany({
               where,
               select: {
                 id: true,
                 email: true,
                 firstName: true,
                 lastName: true,
                 platformRole: true,
                 isActive: true,
                 emailVerified: true,
                 phoneVerified: true,
                 pushEnabled: true,
                 createdAt: true,
                 teamMembers: {
                   include: {
                     team: { select: { id: true, name: true } }
                   }
                 }
               },
               skip: params.offset || 0,
               take: params.limit || 50,
               orderBy: { lastName: 'asc' }
             }),
             prisma.user.count({ where })
           ]);

           return { users, total };
         }

         // Update platform role (admin only)
         async updateRole(userId: string, newRole: 'PLATFORM_ADMIN' | 'USER', adminUserId: string) {
           const user = await prisma.user.update({
             where: { id: userId },
             data: { platformRole: newRole }
           });

           await auditService.log({
             action: 'user.role.updated',
             userId: adminUserId,
             resourceType: 'user',
             resourceId: userId,
             metadata: {
               newRole,
               targetUser: user.email
             }
           });

           return user;
         }
       }

       export const userService = new UserService();
       ```

    2. Create src/routes/user.routes.ts:
       ```typescript
       import { Router } from 'express';
       import { z } from 'zod';
       import { requireAuth, requirePlatformAdmin } from '../middleware/auth';
       import { userService } from '../services/user.service';

       export const userRouter = Router();

       // All user routes require authentication
       userRouter.use(requireAuth);

       // GET /api/users/me - Get current user's profile
       userRouter.get('/me', async (req, res) => {
         try {
           const profile = await userService.getProfile((req.user as any).id);
           if (!profile) {
             return res.status(404).json({ error: 'User not found' });
           }
           res.json(profile);
         } catch (error) {
           res.status(500).json({ error: 'Failed to get profile' });
         }
       });

       // GET /api/users/:id - Get specific user's profile (admin or self)
       userRouter.get('/:id', async (req, res) => {
         const currentUser = req.user as any;
         const targetId = req.params.id;

         // Can view self or if platform admin
         if (targetId !== currentUser.id && currentUser.platformRole !== 'PLATFORM_ADMIN') {
           return res.status(403).json({ error: 'Cannot view other users' });
         }

         try {
           const profile = await userService.getProfile(targetId);
           if (!profile) {
             return res.status(404).json({ error: 'User not found' });
           }
           res.json(profile);
         } catch (error) {
           res.status(500).json({ error: 'Failed to get profile' });
         }
       });

       // GET /api/users - List users (admin only)
       const ListUsersSchema = z.object({
         teamId: z.string().optional(),
         role: z.enum(['PLATFORM_ADMIN', 'USER']).optional(),
         includeInactive: z.coerce.boolean().optional(),
         limit: z.coerce.number().min(1).max(100).default(50),
         offset: z.coerce.number().min(0).default(0)
       });

       userRouter.get('/', requirePlatformAdmin, async (req, res) => {
         try {
           const params = ListUsersSchema.parse(req.query);
           const result = await userService.listUsers(params);
           res.json(result);
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid query parameters' });
           }
           res.status(500).json({ error: 'Failed to list users' });
         }
       });

       // PATCH /api/users/:id/role - Update user's platform role (admin only)
       const UpdateRoleSchema = z.object({
         role: z.enum(['PLATFORM_ADMIN', 'USER'])
       });

       userRouter.patch('/:id/role', requirePlatformAdmin, async (req, res) => {
         try {
           const { role } = UpdateRoleSchema.parse(req.body);
           const user = await userService.updateRole(
             req.params.id,
             role,
             (req.user as any).id
           );
           res.json({
             id: user.id,
             email: user.email,
             platformRole: user.platformRole
           });
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid role' });
           }
           res.status(500).json({ error: 'Failed to update role' });
         }
       });

       // Note: Profile data (name, email, phone) is read-only - synced from Okta via SCIM
       // No PUT/PATCH for profile fields - redirect users to update in Okta
       ```
  </action>
  <verify>
    npx tsc --noEmit passes
    Routes export correctly
  </verify>
  <done>
    User profile API with self-view, admin list, and role management. Profile data read-only per user decision.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create contact verification service</name>
  <files>
    src/services/contact.service.ts
  </files>
  <action>
    Create src/services/contact.service.ts:
    ```typescript
    import crypto from 'crypto';
    import { prisma } from '../config/database';
    import { auditService } from './audit.service';

    type VerificationMethod = 'email' | 'sms' | 'push';

    export class ContactVerificationService {
      private CODE_EXPIRY_MINUTES = 15;
      private CODE_LENGTH = 6;

      // Generate 6-digit numeric code
      private generateCode(): string {
        return crypto.randomInt(100000, 999999).toString();
      }

      // Initiate verification for a contact method
      async sendVerification(userId: string, method: VerificationMethod, value: string) {
        // Check for recent verification to prevent spam
        const recent = await prisma.contactVerification.findFirst({
          where: {
            userId,
            method,
            value,
            createdAt: { gt: new Date(Date.now() - 60 * 1000) } // Last 1 minute
          }
        });

        if (recent) {
          throw new Error('Verification already sent recently. Please wait.');
        }

        const code = this.generateCode();
        const expiresAt = new Date(Date.now() + this.CODE_EXPIRY_MINUTES * 60 * 1000);

        // Invalidate any existing pending verifications for this method
        await prisma.contactVerification.updateMany({
          where: {
            userId,
            method,
            verified: false
          },
          data: {
            expiresAt: new Date() // Expire immediately
          }
        });

        // Create new verification
        const verification = await prisma.contactVerification.create({
          data: {
            userId,
            method,
            value: this.maskValue(method, value), // Store masked value for security
            code,
            expiresAt
          }
        });

        // Send the actual verification message
        // NOTE: Actual sending implemented in Phase 5 (Multi-Channel Notifications)
        // For now, log the code (would be sent via email/SMS/push in production)
        await this.sendVerificationMessage(method, value, code);

        await auditService.log({
          action: 'contact.verification.sent',
          userId,
          metadata: {
            method,
            value: this.maskValue(method, value),
            expiresAt: expiresAt.toISOString()
          }
        });

        return {
          id: verification.id,
          method,
          expiresAt,
          // In dev mode, include code for testing
          ...(process.env.NODE_ENV === 'development' && { code })
        };
      }

      // Verify the code
      async verifyCode(userId: string, method: VerificationMethod, code: string) {
        const verification = await prisma.contactVerification.findFirst({
          where: {
            userId,
            method,
            code,
            verified: false,
            expiresAt: { gt: new Date() }
          }
        });

        if (!verification) {
          await auditService.log({
            action: 'contact.verification.failed',
            userId,
            metadata: { method, reason: 'invalid_or_expired_code' }
          });
          throw new Error('Invalid or expired verification code');
        }

        // Mark as verified
        await prisma.contactVerification.update({
          where: { id: verification.id },
          data: {
            verified: true,
            verifiedAt: new Date()
          }
        });

        // Update user's verification status
        const updateData: any = {};
        if (method === 'email') updateData.emailVerified = true;
        if (method === 'sms') updateData.phoneVerified = true;
        if (method === 'push') updateData.pushEnabled = true;

        await prisma.user.update({
          where: { id: userId },
          data: updateData
        });

        await auditService.log({
          action: 'contact.verification.completed',
          userId,
          metadata: { method }
        });

        return { success: true, method };
      }

      // Check verification status
      async getVerificationStatus(userId: string) {
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: {
            email: true,
            phone: true,
            emailVerified: true,
            phoneVerified: true,
            pushEnabled: true,
            devices: {
              select: { id: true, platform: true }
            }
          }
        });

        if (!user) return null;

        // Per user decision: All three required for on-call engineers
        const allVerified = user.emailVerified && user.phoneVerified && user.pushEnabled;

        return {
          email: {
            value: user.email ? this.maskValue('email', user.email) : null,
            verified: user.emailVerified
          },
          phone: {
            value: user.phone ? this.maskValue('sms', user.phone) : null,
            verified: user.phoneVerified
          },
          push: {
            verified: user.pushEnabled,
            deviceCount: user.devices.length
          },
          allVerified,
          canBeOnCall: allVerified
        };
      }

      // Mask value for security
      private maskValue(method: VerificationMethod, value: string): string {
        if (method === 'email') {
          const [local, domain] = value.split('@');
          return `${local.slice(0, 2)}***@${domain}`;
        }
        if (method === 'sms') {
          return `***${value.slice(-4)}`;
        }
        return '***';
      }

      // Send verification message (stub - implemented in Phase 5)
      private async sendVerificationMessage(method: VerificationMethod, value: string, code: string) {
        // TODO: Implement actual sending in Phase 5
        // For now, log to console in development
        if (process.env.NODE_ENV === 'development') {
          console.log(`[DEV] Verification code for ${method} (${value}): ${code}`);
        }

        // In production, this would:
        // - email: Call email service
        // - sms: Call Twilio/SNS
        // - push: Send push notification to registered devices
      }
    }

    export const contactService = new ContactVerificationService();
    ```
  </action>
  <verify>
    npx tsc --noEmit passes
    ContactVerificationService exports correctly
  </verify>
  <done>
    Contact verification service with 15-minute code expiry, masked values, and verification status tracking
  </done>
</task>

<task type="auto">
  <name>Task 3: Create notification preferences routes and mount all user routes</name>
  <files>
    src/routes/notification.routes.ts
    src/index.ts
  </files>
  <action>
    1. Create src/routes/notification.routes.ts:
       ```typescript
       import { Router } from 'express';
       import { z } from 'zod';
       import { prisma } from '../config/database';
       import { requireAuth } from '../middleware/auth';
       import { contactService } from '../services/contact.service';
       import { auditService } from '../services/audit.service';

       export const notificationRouter = Router();

       notificationRouter.use(requireAuth);

       // GET /api/notifications/preferences - Get current user's preferences
       notificationRouter.get('/preferences', async (req, res) => {
         try {
           const userId = (req.user as any).id;

           const preferences = await prisma.notificationPreference.findMany({
             where: { userId },
             orderBy: { priority: 'asc' }
           });

           res.json({
             preferences: preferences.map(p => ({
               id: p.id,
               channel: p.channel,
               enabled: p.enabled,
               priority: p.priority
             }))
           });
         } catch (error) {
           res.status(500).json({ error: 'Failed to get preferences' });
         }
       });

       // PUT /api/notifications/preferences - Update preferences
       const UpdatePreferencesSchema = z.object({
         preferences: z.array(z.object({
           channel: z.enum(['EMAIL', 'SMS', 'PUSH', 'SLACK', 'VOICE']),
           enabled: z.boolean(),
           priority: z.number().min(1).max(10)
         }))
       });

       notificationRouter.put('/preferences', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { preferences } = UpdatePreferencesSchema.parse(req.body);

           // Delete existing and recreate (simplest approach)
           await prisma.notificationPreference.deleteMany({
             where: { userId }
           });

           const created = await prisma.notificationPreference.createMany({
             data: preferences.map(p => ({
               userId,
               channel: p.channel,
               enabled: p.enabled,
               priority: p.priority
             }))
           });

           await auditService.log({
             action: 'user.preferences.updated',
             userId,
             metadata: {
               channels: preferences.map(p => p.channel)
             }
           });

           // Fetch and return the created preferences
           const updated = await prisma.notificationPreference.findMany({
             where: { userId },
             orderBy: { priority: 'asc' }
           });

           res.json({ preferences: updated });
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid preferences data' });
           }
           res.status(500).json({ error: 'Failed to update preferences' });
         }
       });

       // GET /api/notifications/verification/status - Get verification status
       notificationRouter.get('/verification/status', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const status = await contactService.getVerificationStatus(userId);

           if (!status) {
             return res.status(404).json({ error: 'User not found' });
           }

           res.json(status);
         } catch (error) {
           res.status(500).json({ error: 'Failed to get verification status' });
         }
       });

       // POST /api/notifications/verification/send - Send verification code
       const SendVerificationSchema = z.object({
         method: z.enum(['email', 'sms', 'push']),
         value: z.string().optional() // Required for email/sms, not for push
       });

       notificationRouter.post('/verification/send', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { method, value } = SendVerificationSchema.parse(req.body);

           // For email/sms, get value from user profile if not provided
           let targetValue = value;
           if (!targetValue && (method === 'email' || method === 'sms')) {
             const user = await prisma.user.findUnique({
               where: { id: userId },
               select: { email: true, phone: true }
             });

             if (method === 'email') targetValue = user?.email;
             if (method === 'sms') targetValue = user?.phone;
           }

           if (!targetValue && method !== 'push') {
             return res.status(400).json({
               error: `No ${method === 'email' ? 'email' : 'phone'} address available`
             });
           }

           const result = await contactService.sendVerification(
             userId,
             method,
             targetValue || ''
           );

           res.json(result);
         } catch (error) {
           if (error.message?.includes('already sent')) {
             return res.status(429).json({ error: error.message });
           }
           res.status(500).json({ error: 'Failed to send verification' });
         }
       });

       // POST /api/notifications/verification/verify - Verify code
       const VerifyCodeSchema = z.object({
         method: z.enum(['email', 'sms', 'push']),
         code: z.string().length(6)
       });

       notificationRouter.post('/verification/verify', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { method, code } = VerifyCodeSchema.parse(req.body);

           const result = await contactService.verifyCode(userId, method, code);
           res.json(result);
         } catch (error) {
           if (error.message?.includes('Invalid or expired')) {
             return res.status(400).json({ error: error.message });
           }
           res.status(500).json({ error: 'Failed to verify code' });
         }
       });

       // POST /api/notifications/devices - Register device for push
       const RegisterDeviceSchema = z.object({
         platform: z.enum(['ios', 'android', 'web']),
         deviceToken: z.string(),
         deviceName: z.string().optional()
       });

       notificationRouter.post('/devices', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           const { platform, deviceToken, deviceName } = RegisterDeviceSchema.parse(req.body);

           const device = await prisma.userDevice.upsert({
             where: {
               userId_deviceToken: { userId, deviceToken }
             },
             create: {
               userId,
               platform,
               deviceToken,
               deviceName,
               lastSeenAt: new Date()
             },
             update: {
               platform,
               deviceName,
               lastSeenAt: new Date()
             }
           });

           await auditService.log({
             action: 'device.registered',
             userId,
             metadata: { platform, deviceId: device.id }
           });

           res.json({
             id: device.id,
             platform: device.platform,
             deviceName: device.deviceName
           });
         } catch (error) {
           res.status(500).json({ error: 'Failed to register device' });
         }
       });

       // DELETE /api/notifications/devices/:id - Unregister device
       notificationRouter.delete('/devices/:id', async (req, res) => {
         try {
           const userId = (req.user as any).id;

           await prisma.userDevice.deleteMany({
             where: {
               id: req.params.id,
               userId // Ensure user owns the device
             }
           });

           await auditService.log({
             action: 'device.unregistered',
             userId,
             metadata: { deviceId: req.params.id }
           });

           res.json({ success: true });
         } catch (error) {
           res.status(500).json({ error: 'Failed to unregister device' });
         }
       });
       ```

    2. Update src/index.ts to mount user and notification routes:
       ```typescript
       import { userRouter } from './routes/user.routes';
       import { notificationRouter } from './routes/notification.routes';

       // Mount user routes
       app.use('/api/users', userRouter);
       app.use('/api/notifications', notificationRouter);
       ```
  </action>
  <verify>
    npm run dev starts without errors
    GET /api/users/me returns current user profile
    GET /api/notifications/preferences returns preferences
    POST /api/notifications/verification/send initiates verification
  </verify>
  <done>
    Notification preferences CRUD, contact verification flow, device registration for push notifications
  </done>
</task>

</tasks>

<verification>
1. GET /api/users/me returns user profile with teams and verification status
2. Profile data is read-only (no PUT/PATCH for name/email/phone)
3. PUT /api/notifications/preferences updates notification channels
4. POST /api/notifications/verification/send creates verification with 15-min expiry
5. POST /api/notifications/verification/verify validates code and updates user
6. POST /api/notifications/devices registers device for push notifications
7. Verification status shows canBeOnCall: true only when all three verified
</verification>

<success_criteria>
- User profile read-only (per user decision: synced from Okta)
- Notification preferences managed in platform (per user decision)
- Contact verification required for on-call (per user decision: all three methods required)
- 15-minute code expiry implemented
- All preference changes logged to audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-07-SUMMARY.md`
</output>

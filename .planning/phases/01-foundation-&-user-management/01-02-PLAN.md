---
phase: 01-foundation-&-user-management
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/audit.service.ts
  - src/middleware/auditLogger.ts
  - src/routes/audit.routes.ts
  - src/jobs/auditCleanup.ts
  - src/types/audit.ts
autonomous: true

must_haves:
  truths:
    - "All user actions create audit events"
    - "Audit logs can be queried by user, team, or action"
    - "Audit retention cleanup removes events older than 90 days"
  artifacts:
    - path: "src/services/audit.service.ts"
      provides: "Audit event creation and querying"
      exports: ["AuditService", "auditService"]
    - path: "src/middleware/auditLogger.ts"
      provides: "Request-level audit middleware"
      exports: ["auditMiddleware"]
    - path: "src/routes/audit.routes.ts"
      provides: "Audit log API endpoints"
      exports: ["auditRouter"]
  key_links:
    - from: "src/services/audit.service.ts"
      to: "prisma.auditEvent"
      via: "database writes"
      pattern: "prisma\\.auditEvent\\.create"
    - from: "src/middleware/auditLogger.ts"
      to: "src/services/audit.service.ts"
      via: "service call"
      pattern: "auditService\\.log"
---

<objective>
Implement comprehensive audit logging infrastructure that captures all user actions with queryable metadata.

Purpose: Audit logging is foundational for compliance and security. Per user decision, log everything including auth events, incident actions, and config changes.
Output: AuditService with log/query methods, middleware for automatic request logging, cleanup job for 90-day retention.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
@.planning/phases/01-foundation-&-user-management/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuditService with log and query methods</name>
  <files>
    src/types/audit.ts
    src/services/audit.service.ts
  </files>
  <action>
    1. Create src/types/audit.ts with TypeScript types:
       ```typescript
       export type AuditSeverity = 'INFO' | 'WARN' | 'HIGH';

       export interface AuditLogParams {
         action: string;           // e.g., "user.login", "team.settings.updated"
         userId?: string;          // Actor performing the action
         teamId?: string;          // Team context if applicable
         resourceType?: string;    // e.g., "user", "team", "incident"
         resourceId?: string;      // ID of affected resource
         metadata?: Record<string, unknown>;
         severity?: AuditSeverity;
         ipAddress?: string;
         userAgent?: string;
       }

       export interface AuditQueryParams {
         userId?: string;
         teamId?: string;
         action?: string;
         resourceType?: string;
         resourceId?: string;
         severity?: AuditSeverity;
         startDate?: Date;
         endDate?: Date;
         limit?: number;
         offset?: number;
       }
       ```

    2. Create src/services/audit.service.ts:
       - Class AuditService with constructor taking PrismaClient
       - Method: log(params: AuditLogParams) -> Promise<AuditEvent>
         - Creates audit event with current timestamp (Prisma handles UTC)
         - Defaults severity to 'INFO' if not provided
         - Returns created audit event

       - Method: query(params: AuditQueryParams) -> Promise<{events: AuditEvent[], total: number}>
         - Builds Prisma where clause from params
         - Supports date range filtering with gte/lte
         - Includes user and team relations (select: id, email, firstName, lastName for user; id, name for team)
         - Orders by timestamp desc
         - Returns paginated results with total count

       - Method: getByResource(resourceType: string, resourceId: string) -> Promise<AuditEvent[]>
         - Convenience method for getting all events for a specific resource

       - Method: cleanup(retentionDays: number = 90) -> Promise<{deletedCount: number}>
         - Calculates cutoff date (now - retentionDays)
         - Deletes all events with timestamp < cutoff
         - Returns count of deleted records

       - Export singleton: export const auditService = new AuditService(prisma);

    Action naming conventions to follow (per user decisions):
    - auth.* for authentication events (auth.login.okta, auth.login.breakglass, auth.logout, auth.session.expired)
    - user.* for user lifecycle (user.provisioned, user.deprovisioned, user.profile.updated)
    - team.* for team actions (team.created, team.archived, team.member.added, team.member.removed)
    - contact.* for verification (contact.verification.sent, contact.verification.completed)
  </action>
  <verify>
    npx tsc --noEmit passes
    AuditService class exports correctly
  </verify>
  <done>
    AuditService can log events and query with filters, cleanup method implemented for 90-day retention
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit middleware and API routes</name>
  <files>
    src/middleware/auditLogger.ts
    src/routes/audit.routes.ts
  </files>
  <action>
    1. Create src/middleware/auditLogger.ts:
       - Middleware function that extracts request context for audit logging
       - Attaches helper method to request object: req.audit(action, metadata)
       - Helper automatically includes:
         - userId from req.user?.id (if authenticated)
         - ipAddress from req.ip
         - userAgent from req.get('user-agent')
         - Any additional metadata passed

       Implementation:
       ```typescript
       declare global {
         namespace Express {
           interface Request {
             audit: (action: string, params?: Partial<AuditLogParams>) => Promise<AuditEvent>;
           }
         }
       }

       export function auditMiddleware(req: Request, res: Response, next: NextFunction) {
         req.audit = async (action: string, params: Partial<AuditLogParams> = {}) => {
           return auditService.log({
             action,
             userId: (req.user as any)?.id,
             ipAddress: req.ip,
             userAgent: req.get('user-agent'),
             ...params
           });
         };
         next();
       }
       ```

    2. Create src/routes/audit.routes.ts:
       - GET /api/audit - Query audit logs (paginated)
         - Query params: userId, teamId, action, resourceType, resourceId, startDate, endDate, limit, offset
         - Parse dates from ISO strings
         - Validate with Zod
         - Return { events: [...], total: number, limit, offset }
         - NOTE: Access control will be added in Plan 03 (RBAC). For now, mark with TODO comment.

       - GET /api/audit/:resourceType/:resourceId - Get audit trail for specific resource
         - Returns all events for that resource, ordered by timestamp desc

       - POST /api/audit/cleanup - Trigger manual cleanup (admin only)
         - Returns { deletedCount: number }
         - NOTE: Auth/admin check deferred to Plan 03

       Use Zod for query param validation:
       ```typescript
       const AuditQuerySchema = z.object({
         userId: z.string().optional(),
         teamId: z.string().optional(),
         action: z.string().optional(),
         resourceType: z.string().optional(),
         resourceId: z.string().optional(),
         startDate: z.string().datetime().optional(),
         endDate: z.string().datetime().optional(),
         limit: z.coerce.number().min(1).max(1000).default(100),
         offset: z.coerce.number().min(0).default(0)
       });
       ```
  </action>
  <verify>
    npx tsc --noEmit passes
    Routes export auditRouter
  </verify>
  <done>
    Audit middleware attaches helper to requests, API routes expose query and cleanup endpoints
  </done>
</task>

<task type="auto">
  <name>Task 3: Create scheduled cleanup job and integrate with app</name>
  <files>
    src/jobs/auditCleanup.ts
    src/index.ts
  </files>
  <action>
    1. Create src/jobs/auditCleanup.ts:
       - Standalone function runAuditCleanup() that can be called from cron or manually
       - Calls auditService.cleanup(90)
       - Logs result using Pino logger
       - Handles errors gracefully (logs but doesn't crash)

       For local dev, use setInterval to run daily:
       ```typescript
       export function scheduleAuditCleanup() {
         // Run cleanup daily at startup and then every 24 hours
         const runCleanup = async () => {
           try {
             const result = await auditService.cleanup(90);
             logger.info({ deletedCount: result.deletedCount }, 'Audit cleanup completed');
           } catch (error) {
             logger.error({ error }, 'Audit cleanup failed');
           }
         };

         // Run once at startup after 1 minute delay
         setTimeout(runCleanup, 60 * 1000);

         // Schedule daily
         setInterval(runCleanup, 24 * 60 * 60 * 1000);
       }
       ```

       Note: In production, this would be replaced with AWS EventBridge or a proper cron scheduler.

    2. Update src/index.ts:
       - Import auditMiddleware
       - Apply middleware globally: app.use(auditMiddleware)
       - Import and mount auditRouter: app.use('/api', auditRouter)
       - Call scheduleAuditCleanup() in production mode

    3. Add startup audit event:
       ```typescript
       // Log server startup
       auditService.log({
         action: 'system.startup',
         metadata: { version: process.env.npm_package_version },
         severity: 'INFO'
       });
       ```
  </action>
  <verify>
    npm run dev starts without errors
    curl http://localhost:3000/api/audit returns { events: [...], total: number }
    Startup audit event appears in database
  </verify>
  <done>
    Audit cleanup scheduled, middleware integrated, API endpoints accessible, startup event logged
  </done>
</task>

</tasks>

<verification>
1. AuditService.log() creates events in database with correct UTC timestamp
2. AuditService.query() returns filtered and paginated results
3. req.audit() helper available in route handlers
4. GET /api/audit returns audit events
5. POST /api/audit/cleanup deletes old events
6. Cleanup job scheduled to run daily
</verification>

<success_criteria>
- Audit events persisted with all required metadata (userId, teamId, action, timestamp, IP, user-agent)
- Query API supports filtering by user, team, action, date range
- Cleanup removes events older than 90 days (per user decision)
- All timestamps stored in UTC (per critical pitfall)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-02-SUMMARY.md`
</output>

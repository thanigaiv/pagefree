---
phase: 01-foundation-&-user-management
plan: 10
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - prisma/schema.prisma
  - src/services/apiKey.service.ts
  - src/middleware/apiKeyAuth.ts
  - src/routes/apiKey.routes.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Platform admin can create API keys for services"
    - "External services can authenticate using API key"
    - "API keys have scopes limiting access"
    - "API key usage is logged to audit trail"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "ApiKey model"
      contains: "model ApiKey"
    - path: "src/services/apiKey.service.ts"
      provides: "API key creation and validation"
      exports: ["ApiKeyService", "apiKeyService"]
    - path: "src/middleware/apiKeyAuth.ts"
      provides: "API key authentication middleware"
      exports: ["apiKeyAuth"]
    - path: "src/routes/apiKey.routes.ts"
      provides: "API key management endpoints"
      exports: ["apiKeyRouter"]
  key_links:
    - from: "src/middleware/apiKeyAuth.ts"
      to: "prisma.apiKey"
      via: "key validation"
      pattern: "prisma\\.apiKey\\.findFirst"
    - from: "src/services/apiKey.service.ts"
      to: "prisma.apiKey"
      via: "key creation"
      pattern: "prisma\\.apiKey\\.create"
---

<objective>
Implement API key infrastructure for external service authentication.

Purpose: Per user decision, "API keys per service for external webhooks (DataDog, New Relic), separate from Okta". External monitoring tools need to authenticate webhook requests using API keys, not Okta SSO.
Output: ApiKey model, API key creation/validation service, authentication middleware, and management API.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-01-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-02-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ApiKey model to Prisma schema</name>
  <files>
    prisma/schema.prisma
  </files>
  <action>
    Add ApiKey model to existing schema:

    ```prisma
    model ApiKey {
      id          String   @id @default(cuid())
      name        String   // Descriptive name (e.g., "DataDog Production")
      keyHash     String   @unique  // SHA-256 hash of the API key
      keyPrefix   String   // First 8 chars for identification (e.g., "sk_prod_")

      // Service metadata
      service     String   // Service name: datadog, newrelic, custom
      description String?  // Optional description

      // Scopes define what the key can access
      scopes      String[] // e.g., ["webhooks:write", "alerts:write"]

      // Ownership and lifecycle
      createdById String
      createdBy   User     @relation(fields: [createdById], references: [id])
      isActive    Boolean  @default(true)

      // Usage tracking
      lastUsedAt  DateTime? @db.Timestamptz
      usageCount  Int       @default(0)

      // Expiry (optional)
      expiresAt   DateTime? @db.Timestamptz

      createdAt   DateTime  @default(now()) @db.Timestamptz
      updatedAt   DateTime  @updatedAt @db.Timestamptz

      @@index([keyHash])
      @@index([keyPrefix])
      @@index([service])
    }
    ```

    Update User model to add the relation:
    ```prisma
    model User {
      // ... existing fields ...
      apiKeysCreated ApiKey[] @relation("ApiKeyCreator")
    }
    ```

    Run migration:
    ```bash
    npx prisma db push
    npx prisma generate
    ```
  </action>
  <verify>
    npx prisma validate passes
    npx prisma generate succeeds
  </verify>
  <done>
    ApiKey model added to schema with keyHash, scopes, service metadata, and usage tracking
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API key service for key generation and validation</name>
  <files>
    src/services/apiKey.service.ts
  </files>
  <action>
    Create src/services/apiKey.service.ts:

    ```typescript
    import crypto from 'crypto';
    import { prisma } from '../config/database';
    import { auditService } from './audit.service';

    export type ApiKeyScope =
      | 'webhooks:write'
      | 'alerts:write'
      | 'incidents:read'
      | 'incidents:write'
      | 'admin:read'
      | 'admin:write';

    export interface CreateApiKeyParams {
      name: string;
      service: string;
      description?: string;
      scopes: ApiKeyScope[];
      expiresAt?: Date;
      createdById: string;
    }

    export class ApiKeyService {
      private readonly KEY_LENGTH = 32; // 32 bytes = 64 hex chars

      // Generate a new API key
      private generateKey(prefix: string = 'sk'): string {
        const randomBytes = crypto.randomBytes(this.KEY_LENGTH);
        const keyBody = randomBytes.toString('hex');
        return `${prefix}_${keyBody}`;
      }

      // Hash API key for storage (never store plaintext)
      private hashKey(key: string): string {
        return crypto.createHash('sha256').update(key).digest('hex');
      }

      // Extract prefix from key (first 8 chars for display)
      private extractPrefix(key: string): string {
        return key.substring(0, 8);
      }

      // Create a new API key
      async create(params: CreateApiKeyParams): Promise<{ key: string; record: any }> {
        // Generate key with service-specific prefix
        const servicePrefix = params.service === 'datadog' ? 'dd' :
                             params.service === 'newrelic' ? 'nr' :
                             'sk';

        const key = this.generateKey(servicePrefix);
        const keyHash = this.hashKey(key);
        const keyPrefix = this.extractPrefix(key);

        // Create database record
        const record = await prisma.apiKey.create({
          data: {
            name: params.name,
            keyHash,
            keyPrefix,
            service: params.service,
            description: params.description,
            scopes: params.scopes,
            createdById: params.createdById,
            expiresAt: params.expiresAt
          },
          include: {
            createdBy: {
              select: {
                id: true,
                email: true,
                firstName: true,
                lastName: true
              }
            }
          }
        });

        await auditService.log({
          action: 'apikey.created',
          userId: params.createdById,
          resourceType: 'apikey',
          resourceId: record.id,
          severity: 'HIGH',
          metadata: {
            name: params.name,
            service: params.service,
            scopes: params.scopes,
            keyPrefix
          }
        });

        // Return plaintext key (ONLY time it's visible)
        return { key, record };
      }

      // Validate API key and return associated record
      async validate(key: string): Promise<{
        valid: boolean;
        apiKey?: any;
        reason?: string;
      }> {
        const keyHash = this.hashKey(key);

        const apiKey = await prisma.apiKey.findFirst({
          where: {
            keyHash,
            isActive: true
          },
          include: {
            createdBy: {
              select: {
                id: true,
                email: true,
                platformRole: true
              }
            }
          }
        });

        if (!apiKey) {
          return { valid: false, reason: 'invalid_key' };
        }

        // Check expiry
        if (apiKey.expiresAt && apiKey.expiresAt < new Date()) {
          return { valid: false, reason: 'expired_key' };
        }

        // Update usage stats (async, don't block validation)
        this.recordUsage(apiKey.id).catch(err =>
          console.error('Failed to record API key usage:', err)
        );

        return { valid: true, apiKey };
      }

      // Check if key has required scope
      hasScope(apiKey: any, requiredScope: ApiKeyScope): boolean {
        return apiKey.scopes.includes(requiredScope);
      }

      // Record API key usage
      private async recordUsage(apiKeyId: string): Promise<void> {
        await prisma.apiKey.update({
          where: { id: apiKeyId },
          data: {
            lastUsedAt: new Date(),
            usageCount: { increment: 1 }
          }
        });
      }

      // List API keys (for admin UI)
      async list(params: {
        service?: string;
        includeInactive?: boolean;
        limit?: number;
        offset?: number;
      }) {
        const where: any = {};

        if (!params.includeInactive) {
          where.isActive = true;
        }

        if (params.service) {
          where.service = params.service;
        }

        const [keys, total] = await Promise.all([
          prisma.apiKey.findMany({
            where,
            select: {
              id: true,
              name: true,
              keyPrefix: true,
              service: true,
              description: true,
              scopes: true,
              isActive: true,
              lastUsedAt: true,
              usageCount: true,
              expiresAt: true,
              createdAt: true,
              createdBy: {
                select: {
                  id: true,
                  email: true,
                  firstName: true,
                  lastName: true
                }
              }
            },
            skip: params.offset || 0,
            take: params.limit || 50,
            orderBy: { createdAt: 'desc' }
          }),
          prisma.apiKey.count({ where })
        ]);

        return { keys, total };
      }

      // Revoke API key
      async revoke(apiKeyId: string, revokedById: string): Promise<void> {
        const apiKey = await prisma.apiKey.update({
          where: { id: apiKeyId },
          data: { isActive: false }
        });

        await auditService.log({
          action: 'apikey.revoked',
          userId: revokedById,
          resourceType: 'apikey',
          resourceId: apiKeyId,
          severity: 'HIGH',
          metadata: {
            name: apiKey.name,
            service: apiKey.service,
            keyPrefix: apiKey.keyPrefix
          }
        });
      }

      // Delete API key (hard delete - use with caution)
      async delete(apiKeyId: string, deletedById: string): Promise<void> {
        const apiKey = await prisma.apiKey.findUnique({
          where: { id: apiKeyId }
        });

        if (!apiKey) {
          throw new Error('API key not found');
        }

        await prisma.apiKey.delete({
          where: { id: apiKeyId }
        });

        await auditService.log({
          action: 'apikey.deleted',
          userId: deletedById,
          resourceType: 'apikey',
          resourceId: apiKeyId,
          severity: 'HIGH',
          metadata: {
            name: apiKey.name,
            service: apiKey.service,
            keyPrefix: apiKey.keyPrefix
          }
        });
      }
    }

    export const apiKeyService = new ApiKeyService();
    ```
  </action>
  <verify>
    npx tsc --noEmit passes
    ApiKeyService exports correctly
  </verify>
  <done>
    API key service with generation, validation, scope checking, and usage tracking
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API key authentication middleware and management routes</name>
  <files>
    src/middleware/apiKeyAuth.ts
    src/routes/apiKey.routes.ts
    src/index.ts
  </files>
  <action>
    1. Create src/middleware/apiKeyAuth.ts:
       ```typescript
       import { Request, Response, NextFunction } from 'express';
       import { apiKeyService, ApiKeyScope } from '../services/apiKey.service';
       import { auditService } from '../services/audit.service';

       // Extend Express Request to include apiKey
       declare global {
         namespace Express {
           interface Request {
             apiKey?: any;
           }
         }
       }

       // Middleware to authenticate via API key
       export function apiKeyAuth(requiredScope?: ApiKeyScope) {
         return async (req: Request, res: Response, next: NextFunction) => {
           // Extract API key from Authorization header
           // Format: "Bearer sk_xxx" or "ApiKey sk_xxx"
           const authHeader = req.headers.authorization;

           if (!authHeader) {
             await auditService.log({
               action: 'apikey.auth.missing',
               severity: 'WARN',
               metadata: { path: req.path },
               ipAddress: req.ip
             });

             return res.status(401).json({ error: 'API key required' });
           }

           // Extract key (support both "Bearer" and "ApiKey" prefixes)
           let key: string;
           if (authHeader.startsWith('Bearer ')) {
             key = authHeader.substring(7);
           } else if (authHeader.startsWith('ApiKey ')) {
             key = authHeader.substring(7);
           } else {
             return res.status(401).json({ error: 'Invalid authorization format. Use: Authorization: Bearer <key>' });
           }

           // Validate key
           const validation = await apiKeyService.validate(key);

           if (!validation.valid) {
             await auditService.log({
               action: 'apikey.auth.failed',
               severity: 'HIGH',
               metadata: {
                 path: req.path,
                 reason: validation.reason
               },
               ipAddress: req.ip,
               userAgent: req.get('user-agent')
             });

             return res.status(401).json({ error: 'Invalid or expired API key' });
           }

           // Check required scope if specified
           if (requiredScope && !apiKeyService.hasScope(validation.apiKey, requiredScope)) {
             await auditService.log({
               action: 'apikey.auth.insufficient_scope',
               severity: 'WARN',
               metadata: {
                 path: req.path,
                 requiredScope,
                 apiKeyId: validation.apiKey.id,
                 service: validation.apiKey.service
               },
               ipAddress: req.ip
             });

             return res.status(403).json({ error: `Insufficient scope. Required: ${requiredScope}` });
           }

           // Attach API key to request
           req.apiKey = validation.apiKey;

           // Log successful authentication (async, don't block)
           auditService.log({
             action: 'apikey.auth.success',
             metadata: {
               apiKeyId: validation.apiKey.id,
               service: validation.apiKey.service,
               path: req.path
             },
             ipAddress: req.ip
           }).catch(err => console.error('Audit log failed:', err));

           next();
         };
       }
       ```

    2. Create src/routes/apiKey.routes.ts:
       ```typescript
       import { Router } from 'express';
       import { z } from 'zod';
       import { requireAuth, requirePlatformAdmin } from '../middleware/auth';
       import { apiKeyService, ApiKeyScope } from '../services/apiKey.service';

       export const apiKeyRouter = Router();

       // All API key management routes require platform admin
       apiKeyRouter.use(requireAuth);
       apiKeyRouter.use(requirePlatformAdmin);

       // POST /api/keys - Create new API key
       const CreateKeySchema = z.object({
         name: z.string().min(3).max(100),
         service: z.string().min(1),
         description: z.string().optional(),
         scopes: z.array(z.string()),
         expiresInDays: z.number().min(1).max(365).optional()
       });

       apiKeyRouter.post('/', async (req, res) => {
         try {
           const parsed = CreateKeySchema.parse(req.body);
           const userId = (req.user as any).id;

           // Calculate expiry if specified
           const expiresAt = parsed.expiresInDays
             ? new Date(Date.now() + parsed.expiresInDays * 24 * 60 * 60 * 1000)
             : undefined;

           const { key, record } = await apiKeyService.create({
             name: parsed.name,
             service: parsed.service,
             description: parsed.description,
             scopes: parsed.scopes as ApiKeyScope[],
             expiresAt,
             createdById: userId
           });

           // Return key ONCE (only time user sees plaintext)
           res.status(201).json({
             key, // Plaintext key - save this!
             id: record.id,
             name: record.name,
             keyPrefix: record.keyPrefix,
             service: record.service,
             scopes: record.scopes,
             expiresAt: record.expiresAt,
             createdAt: record.createdAt
           });
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid request data' });
           }
           console.error('Create API key error:', error);
           res.status(500).json({ error: 'Failed to create API key' });
         }
       });

       // GET /api/keys - List API keys
       const ListKeysSchema = z.object({
         service: z.string().optional(),
         includeInactive: z.coerce.boolean().optional(),
         limit: z.coerce.number().min(1).max(100).default(50),
         offset: z.coerce.number().min(0).default(0)
       });

       apiKeyRouter.get('/', async (req, res) => {
         try {
           const params = ListKeysSchema.parse(req.query);
           const result = await apiKeyService.list(params);
           res.json(result);
         } catch (error) {
           if (error.name === 'ZodError') {
             return res.status(400).json({ error: 'Invalid query parameters' });
           }
           res.status(500).json({ error: 'Failed to list API keys' });
         }
       });

       // DELETE /api/keys/:id - Revoke API key
       apiKeyRouter.delete('/:id', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           await apiKeyService.revoke(req.params.id, userId);
           res.json({ success: true, message: 'API key revoked' });
         } catch (error) {
           console.error('Revoke API key error:', error);
           res.status(500).json({ error: 'Failed to revoke API key' });
         }
       });

       // DELETE /api/keys/:id/permanent - Permanently delete API key
       apiKeyRouter.delete('/:id/permanent', async (req, res) => {
         try {
           const userId = (req.user as any).id;
           await apiKeyService.delete(req.params.id, userId);
           res.json({ success: true, message: 'API key deleted permanently' });
         } catch (error) {
           console.error('Delete API key error:', error);
           res.status(500).json({ error: 'Failed to delete API key' });
         }
       });
       ```

    3. Update src/index.ts to mount API key routes:
       ```typescript
       import { apiKeyRouter } from './routes/apiKey.routes';

       // Mount API key management routes
       app.use('/api/keys', apiKeyRouter);
       ```

    4. Document common usage patterns in code comments:
       ```typescript
       // Example: Protect webhook endpoint with API key
       // import { apiKeyAuth } from './middleware/apiKeyAuth';
       //
       // app.post('/webhooks/datadog',
       //   apiKeyAuth('webhooks:write'),
       //   async (req, res) => {
       //     // req.apiKey contains validated key info
       //     // Handle webhook...
       //   }
       // );
       ```
  </action>
  <verify>
    npm run dev starts without errors
    POST /api/keys creates API key and returns plaintext (once)
    GET /api/keys returns list of keys (without plaintext)
    DELETE /api/keys/:id revokes key
    apiKeyAuth middleware validates key from Authorization header
  </verify>
  <done>
    API key authentication middleware with scope checking, management API for create/list/revoke operations, all actions logged to audit trail
  </done>
</task>

</tasks>

<verification>
1. ApiKey model exists in schema with keyHash, scopes, service metadata
2. POST /api/keys creates key with specified scopes and service
3. POST /api/keys returns plaintext key ONCE (subsequent reads show prefix only)
4. GET /api/keys lists all API keys with usage stats
5. DELETE /api/keys/:id revokes key (soft delete via isActive flag)
6. apiKeyAuth middleware validates key from Authorization header
7. apiKeyAuth middleware checks required scope if specified
8. All API key operations logged to audit trail with HIGH severity
9. API keys are hashed before storage (never stored in plaintext)
10. Usage tracking updates lastUsedAt and usageCount on each use
</verification>

<success_criteria>
- API keys separate from Okta SSO (per user decision: "API keys per service for external webhooks, separate from Okta")
- Keys scoped to specific operations (webhooks:write, alerts:write, etc.)
- Keys associated with service name (DataDog, New Relic, custom)
- Plaintext key visible only at creation time
- Usage tracking for monitoring and auditing
- Revocation capability for compromised keys
- All operations require platform admin role
- Audit trail captures all key lifecycle events
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-10-SUMMARY.md`
</output>

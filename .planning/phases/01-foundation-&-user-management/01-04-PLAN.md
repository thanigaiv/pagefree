---
phase: 01-foundation-&-user-management
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/auth/strategies/okta.ts
  - src/auth/session.ts
  - src/routes/auth.routes.ts
  - src/webhooks/okta.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: okta
    why: "SSO authentication provider"
    env_vars:
      - name: OKTA_DOMAIN
        source: "Okta Admin Console -> Settings -> Account -> Your Okta domain"
      - name: OKTA_CLIENT_ID
        source: "Okta Admin Console -> Applications -> Your App -> Client ID"
      - name: OKTA_CLIENT_SECRET
        source: "Okta Admin Console -> Applications -> Your App -> Client Credentials -> Client secret"
      - name: OKTA_ISSUER
        source: "Okta Admin Console -> Security -> API -> Authorization Servers -> Issuer URI"
      - name: OKTA_WEBHOOK_SECRET
        source: "Okta Admin Console -> Workflow -> Event Hooks -> Your Hook -> Secret"
    dashboard_config:
      - task: "Create OIDC Web Application"
        location: "Okta Admin Console -> Applications -> Create App Integration -> OIDC - OpenID Connect -> Web Application"
      - task: "Add callback URL"
        location: "Add http://localhost:3000/auth/callback to Sign-in redirect URIs"
      - task: "Create Event Hook for session/user events"
        location: "Okta Admin Console -> Workflow -> Event Hooks -> Create Event Hook"

must_haves:
  truths:
    - "User can authenticate via Okta SSO"
    - "Session persists across requests in PostgreSQL"
    - "Session invalidates when Okta session expires"
    - "User is soft-deleted when deactivated in Okta"
  artifacts:
    - path: "src/auth/strategies/okta.ts"
      provides: "Passport OIDC strategy for Okta"
      exports: ["configureOktaStrategy"]
    - path: "src/auth/session.ts"
      provides: "Session configuration with PostgreSQL store"
      exports: ["sessionMiddleware"]
    - path: "src/routes/auth.routes.ts"
      provides: "Auth routes (login, callback, logout)"
      exports: ["authRouter"]
    - path: "src/webhooks/okta.ts"
      provides: "Okta event hook handlers"
      exports: ["oktaWebhookRouter"]
  key_links:
    - from: "src/routes/auth.routes.ts"
      to: "passport.authenticate('okta')"
      via: "strategy invocation"
      pattern: "passport\\.authenticate\\('okta'"
    - from: "src/webhooks/okta.ts"
      to: "prisma.user.update"
      via: "user deactivation"
      pattern: "isActive:\\s*false"
---

<objective>
Implement Okta SSO authentication with session management and event hook integration.

Purpose: Per user decision, Okta is the primary authentication method (not email/password). Sessions must be invalidated when Okta session expires or user is removed.
Output: Working Okta OIDC login flow, PostgreSQL session store, event hook handler for session/user lifecycle.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
@.planning/phases/01-foundation-&-user-management/01-01-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-02-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Passport OIDC strategy and session store</name>
  <files>
    src/auth/strategies/okta.ts
    src/auth/session.ts
  </files>
  <action>
    1. Create src/auth/strategies/okta.ts:
       ```typescript
       import passport from 'passport';
       import { Strategy as OpenIDConnectStrategy } from 'passport-openidconnect';
       import { prisma } from '../config/database';
       import { auditService } from '../services/audit.service';
       import { env } from '../config/env';

       export function configureOktaStrategy() {
         passport.use('okta', new OpenIDConnectStrategy({
           issuer: env.OKTA_ISSUER,
           authorizationURL: `${env.OKTA_DOMAIN}/oauth2/v1/authorize`,
           tokenURL: `${env.OKTA_DOMAIN}/oauth2/v1/token`,
           userInfoURL: `${env.OKTA_DOMAIN}/oauth2/v1/userinfo`,
           clientID: env.OKTA_CLIENT_ID,
           clientSecret: env.OKTA_CLIENT_SECRET,
           callbackURL: '/auth/callback',
           scope: ['openid', 'profile', 'email']
         }, async (issuer, profile, done) => {
           try {
             // Find user by Okta ID (set via SCIM) or email
             let user = await prisma.user.findFirst({
               where: {
                 OR: [
                   { oktaId: profile.id },
                   { email: profile.emails?.[0]?.value }
                 ]
               },
               include: {
                 teamMembers: {
                   include: { team: { select: { id: true, name: true, isActive: true } } }
                 }
               }
             });

             if (!user) {
               // User not provisioned via SCIM yet - create minimal record
               // SCIM will update with full details later
               user = await prisma.user.create({
                 data: {
                   oktaId: profile.id,
                   email: profile.emails?.[0]?.value || '',
                   firstName: profile.name?.givenName || '',
                   lastName: profile.name?.familyName || '',
                   syncedFromOkta: true
                 },
                 include: {
                   teamMembers: {
                     include: { team: { select: { id: true, name: true, isActive: true } } }
                   }
                 }
               });

               await auditService.log({
                 action: 'user.created.okta_login',
                 userId: user.id,
                 metadata: { oktaId: profile.id, email: user.email }
               });
             }

             // Check if user is active
             if (!user.isActive) {
               return done(null, false, { message: 'Account is deactivated' });
             }

             // Log successful authentication
             await auditService.log({
               action: 'auth.login.okta',
               userId: user.id,
               severity: 'INFO'
             });

             return done(null, user);
           } catch (error) {
             return done(error);
           }
         }));

         // Serialize user ID to session
         passport.serializeUser((user: any, done) => {
           done(null, user.id);
         });

         // Deserialize user from session - MUST include teamMembers for RBAC
         passport.deserializeUser(async (id: string, done) => {
           try {
             const user = await prisma.user.findUnique({
               where: { id },
               include: {
                 teamMembers: {
                   where: { team: { isActive: true } }, // Only active teams
                   include: { team: { select: { id: true, name: true, isActive: true } } }
                 }
               }
             });

             if (!user || !user.isActive) {
               return done(null, false);
             }

             done(null, user);
           } catch (error) {
             done(error);
           }
         });
       }
       ```

    2. Create src/auth/session.ts:
       ```typescript
       import session from 'express-session';
       import connectPgSimple from 'connect-pg-simple';
       import { Pool } from 'pg';
       import { env } from '../config/env';

       const PgSession = connectPgSimple(session);

       // Create dedicated pool for sessions (separate from Prisma)
       const sessionPool = new Pool({
         connectionString: env.DATABASE_URL
       });

       export const sessionMiddleware = session({
         store: new PgSession({
           pool: sessionPool,
           tableName: 'Session', // Matches Prisma schema
           createTableIfMissing: false // Table created by Prisma migration
         }),
         secret: env.SESSION_SECRET,
         resave: false,
         saveUninitialized: false,
         cookie: {
           secure: env.NODE_ENV === 'production',
           httpOnly: true,
           maxAge: 24 * 60 * 60 * 1000, // 24 hours
           sameSite: 'lax'
         },
         name: 'oncall.sid'
       });
       ```

       Note: Session table uses sid, sess, expire columns per connect-pg-simple requirements.
       Prisma schema from Plan 01 defines this model.
  </action>
  <verify>
    npx tsc --noEmit passes
    Both files export correctly
  </verify>
  <done>
    Passport OIDC strategy configured for Okta, session store using PostgreSQL
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth routes and integrate with Express</name>
  <files>
    src/routes/auth.routes.ts
    src/index.ts
  </files>
  <action>
    1. Create src/routes/auth.routes.ts:
       ```typescript
       import { Router } from 'express';
       import passport from 'passport';
       import { auditService } from '../services/audit.service';
       import { requireAuth } from '../middleware/auth';

       export const authRouter = Router();

       // Initiate Okta login
       authRouter.get('/login', passport.authenticate('okta'));

       // Okta callback
       authRouter.get('/callback',
         passport.authenticate('okta', {
           failureRedirect: '/auth/login-failed',
           failureMessage: true
         }),
         (req, res) => {
           // Successful authentication
           // Redirect to frontend dashboard (or return JSON for API clients)
           const returnTo = req.session?.returnTo || '/dashboard';
           delete req.session?.returnTo;
           res.redirect(returnTo);
         }
       );

       // Login failed handler
       authRouter.get('/login-failed', (req, res) => {
         res.status(401).json({
           error: 'Authentication failed',
           message: req.session?.messages?.[0] || 'Unable to authenticate with Okta'
         });
       });

       // Logout
       authRouter.post('/logout', requireAuth, async (req, res) => {
         const userId = (req.user as any).id;

         await auditService.log({
           action: 'auth.logout',
           userId,
           ipAddress: req.ip,
           userAgent: req.get('user-agent')
         });

         req.logout((err) => {
           if (err) {
             return res.status(500).json({ error: 'Logout failed' });
           }

           req.session.destroy((err) => {
             if (err) {
               return res.status(500).json({ error: 'Session destruction failed' });
             }
             res.clearCookie('oncall.sid');
             res.json({ success: true });
           });
         });
       });

       // Get current user
       authRouter.get('/me', requireAuth, (req, res) => {
         const user = req.user as any;
         res.json({
           id: user.id,
           email: user.email,
           firstName: user.firstName,
           lastName: user.lastName,
           platformRole: user.platformRole,
           teams: user.teamMembers.map(m => ({
             id: m.team.id,
             name: m.team.name,
             role: m.role
           }))
         });
       });

       // Check auth status (doesn't require auth)
       authRouter.get('/status', (req, res) => {
         res.json({
           authenticated: req.isAuthenticated(),
           user: req.isAuthenticated() ? {
             id: (req.user as any).id,
             email: (req.user as any).email
           } : null
         });
       });
       ```

    2. Update src/index.ts to integrate auth:
       ```typescript
       import passport from 'passport';
       import { sessionMiddleware } from './auth/session';
       import { configureOktaStrategy } from './auth/strategies/okta';
       import { authRouter } from './routes/auth.routes';

       // Before routes:
       app.use(sessionMiddleware);
       app.use(passport.initialize());
       app.use(passport.session());

       // Configure strategies
       configureOktaStrategy();

       // Mount auth routes
       app.use('/auth', authRouter);
       ```

       Order matters:
       1. Session middleware (before Passport)
       2. Passport initialize
       3. Passport session
       4. Audit middleware
       5. Routes
  </action>
  <verify>
    npm run dev starts without errors
    GET /auth/status returns { authenticated: false }
    GET /auth/login redirects to Okta (if Okta env vars configured)
  </verify>
  <done>
    Auth routes implemented - login redirects to Okta, callback handles auth, logout destroys session
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Okta event hook handlers for session invalidation</name>
  <files>
    src/webhooks/okta.ts
    src/index.ts
  </files>
  <action>
    1. Create src/webhooks/okta.ts:
       ```typescript
       import { Router } from 'express';
       import crypto from 'crypto';
       import { prisma } from '../config/database';
       import { auditService } from '../services/audit.service';
       import { env } from '../config/env';

       export const oktaWebhookRouter = Router();

       // Verify Okta webhook signature
       function verifyOktaSignature(req: any): boolean {
         // Handle one-time verification challenge
         if (req.headers['x-okta-verification-challenge']) {
           return true;
         }

         const oktaSignature = req.headers['x-okta-signature'] as string;
         if (!oktaSignature || !env.OKTA_WEBHOOK_SECRET) {
           return false;
         }

         const payload = JSON.stringify(req.body);
         const hmac = crypto.createHmac('sha256', env.OKTA_WEBHOOK_SECRET);
         hmac.update(payload);
         const expectedSignature = hmac.digest('base64');

         try {
           return crypto.timingSafeEqual(
             Buffer.from(oktaSignature),
             Buffer.from(expectedSignature)
           );
         } catch {
           return false;
         }
       }

       // Event hook endpoint
       oktaWebhookRouter.post('/events', async (req, res) => {
         // Handle one-time verification challenge
         if (req.headers['x-okta-verification-challenge']) {
           return res.json({
             verification: req.headers['x-okta-verification-challenge']
           });
         }

         // Verify signature
         if (!verifyOktaSignature(req)) {
           await auditService.log({
             action: 'webhook.okta.signature_invalid',
             severity: 'HIGH',
             metadata: { headers: req.headers }
           });
           return res.status(401).json({ error: 'Invalid signature' });
         }

         const { data } = req.body;

         try {
           for (const event of data?.events || []) {
             await handleOktaEvent(event);
           }
           res.json({ success: true });
         } catch (error) {
           await auditService.log({
             action: 'webhook.okta.error',
             severity: 'HIGH',
             metadata: { error: String(error) }
           });
           res.status(500).json({ error: 'Event processing failed' });
         }
       });

       async function handleOktaEvent(event: any) {
         const eventType = event.eventType;

         switch (eventType) {
           case 'user.session.end':
             await handleSessionEnd(event);
             break;

           case 'user.lifecycle.deactivate':
             await handleUserDeactivation(event);
             break;

           case 'user.lifecycle.activate':
             await handleUserActivation(event);
             break;

           case 'user.lifecycle.suspend':
             // Treat suspend same as deactivate
             await handleUserDeactivation(event);
             break;

           default:
             // Log unhandled event types for future implementation
             await auditService.log({
               action: 'webhook.okta.unhandled',
               metadata: { eventType, eventId: event.eventId }
             });
         }
       }

       async function handleSessionEnd(event: any) {
         const oktaUserId = event.actor?.id;
         if (!oktaUserId) return;

         const user = await prisma.user.findUnique({
           where: { oktaId: oktaUserId }
         });

         if (!user) return;

         // Delete all sessions for this user
         // connect-pg-simple stores JSON with user ID in sess column
         await prisma.session.deleteMany({
           where: {
             sess: {
               path: ['passport', 'user'],
               equals: user.id
             }
           }
         });

         await auditService.log({
           action: 'auth.session.okta_expired',
           userId: user.id,
           severity: 'INFO',
           metadata: { oktaEventId: event.eventId }
         });
       }

       async function handleUserDeactivation(event: any) {
         // Target is the user being deactivated
         const oktaUserId = event.target?.[0]?.id;
         if (!oktaUserId) return;

         const user = await prisma.user.findUnique({
           where: { oktaId: oktaUserId }
         });

         if (!user) return;

         // Soft delete the user (per user decision)
         await prisma.user.update({
           where: { id: user.id },
           data: {
             isActive: false,
             deactivatedAt: new Date()
           }
         });

         // Delete all sessions
         await prisma.session.deleteMany({
           where: {
             sess: {
               path: ['passport', 'user'],
               equals: user.id
             }
           }
         });

         // Revoke all refresh tokens
         await prisma.refreshToken.deleteMany({
           where: { userId: user.id }
         });

         await auditService.log({
           action: 'user.deactivated',
           userId: user.id,
           severity: 'HIGH',
           metadata: {
             source: 'okta_webhook',
             oktaEventId: event.eventId,
             eventType: event.eventType
           }
         });
       }

       async function handleUserActivation(event: any) {
         const oktaUserId = event.target?.[0]?.id;
         if (!oktaUserId) return;

         const user = await prisma.user.findUnique({
           where: { oktaId: oktaUserId }
         });

         if (!user) return;

         // Reactivate the user
         await prisma.user.update({
           where: { id: user.id },
           data: {
             isActive: true,
             deactivatedAt: null
           }
         });

         await auditService.log({
           action: 'user.reactivated',
           userId: user.id,
           severity: 'INFO',
           metadata: {
             source: 'okta_webhook',
             oktaEventId: event.eventId
           }
         });
       }
       ```

    2. Update src/index.ts to mount webhook router:
       ```typescript
       import { oktaWebhookRouter } from './webhooks/okta';

       // Mount before auth middleware (webhooks use their own auth)
       app.use('/webhooks/okta', oktaWebhookRouter);
       ```

    Note: The session deletion query uses Prisma JSON path filtering.
    This works with PostgreSQL jsonb columns.
  </action>
  <verify>
    npx tsc --noEmit passes
    POST /webhooks/okta/events with x-okta-verification-challenge returns challenge
    Okta webhook handler logs events correctly
  </verify>
  <done>
    Okta event hooks handle session.end (invalidates sessions), user.deactivate (soft delete), user.activate (reactivate)
  </done>
</task>

</tasks>

<verification>
1. GET /auth/login redirects to Okta authorization URL
2. After Okta callback, user session is created in PostgreSQL
3. GET /auth/me returns current user with team memberships
4. POST /auth/logout destroys session and clears cookie
5. Okta verification challenge returns challenge value
6. user.lifecycle.deactivate event soft-deletes user and invalidates sessions
</verification>

<success_criteria>
- Okta SSO flow works end-to-end (login, callback, session)
- Sessions stored in PostgreSQL (not memory)
- Session invalidation on Okta session.end webhook
- Soft delete on Okta user.deactivate webhook (per user decision)
- All auth events logged to audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-04-SUMMARY.md`
</output>

---
phase: 01-foundation-&-user-management
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/auth/strategies/local.ts
  - src/routes/auth.routes.ts
  - src/middleware/rateLimiter.ts
  - src/scripts/createBreakGlass.ts
autonomous: true

must_haves:
  truths:
    - "Break-glass accounts can authenticate when Okta is down"
    - "Break-glass login is rate limited"
    - "Break-glass logins are logged with HIGH severity"
  artifacts:
    - path: "src/auth/strategies/local.ts"
      provides: "Passport local strategy for break-glass accounts"
      exports: ["configureLocalStrategy"]
    - path: "src/middleware/rateLimiter.ts"
      provides: "Rate limiting for auth endpoints"
      exports: ["loginRateLimiter"]
    - path: "src/scripts/createBreakGlass.ts"
      provides: "CLI script to create break-glass admin"
  key_links:
    - from: "src/routes/auth.routes.ts"
      to: "passport.authenticate('local')"
      via: "emergency login route"
      pattern: "/emergency.*passport\\.authenticate\\('local'"
---

<objective>
Implement break-glass local admin authentication for emergency access when Okta is unavailable.

Purpose: Per user decision, break-glass accounts are for "Okta is down during critical incident" scenarios. These use email/password auth and bypass Okta completely.
Output: Local Passport strategy, rate-limited emergency login route, CLI script to create break-glass accounts.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
@.planning/phases/01-foundation-&-user-management/01-01-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-02-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiter middleware for authentication</name>
  <files>
    src/middleware/rateLimiter.ts
  </files>
  <action>
    Create src/middleware/rateLimiter.ts using rate-limiter-flexible:

    ```typescript
    import { RateLimiterMemory, RateLimiterRes } from 'rate-limiter-flexible';
    import { Request, Response, NextFunction } from 'express';
    import { auditService } from '../services/audit.service';

    // In-memory rate limiter for break-glass login
    // Using memory because:
    // 1. Break-glass is emergency-only, low volume
    // 2. Simpler than Redis/Postgres for this use case
    // 3. If server restarts, rate limits reset (acceptable for emergency access)

    const breakGlassLimiter = new RateLimiterMemory({
      keyPrefix: 'breakglass',
      points: 5,           // 5 attempts
      duration: 60 * 15,   // per 15 minutes
      blockDuration: 60 * 60 // Block for 1 hour after exceeding
    });

    // More strict limiter for failed attempts specifically
    const failedLoginLimiter = new RateLimiterMemory({
      keyPrefix: 'failed_login',
      points: 3,           // 3 failed attempts
      duration: 60 * 5,    // per 5 minutes
      blockDuration: 60 * 30 // Block for 30 minutes
    });

    export async function loginRateLimiter(req: Request, res: Response, next: NextFunction) {
      // Use combination of email + IP for rate limit key
      const email = req.body.email || 'unknown';
      const ip = req.ip || 'unknown';
      const key = `${email}_${ip}`;

      try {
        await breakGlassLimiter.consume(key);
        next();
      } catch (rejRes) {
        const rateLimiterRes = rejRes as RateLimiterRes;
        const secs = Math.round(rateLimiterRes.msBeforeNext / 1000) || 1;

        await auditService.log({
          action: 'auth.rate_limit.exceeded',
          metadata: {
            email,
            ip,
            blockedForSeconds: secs,
            endpoint: 'emergency_login'
          },
          ipAddress: ip,
          severity: 'WARN'
        });

        res.set('Retry-After', String(secs));
        res.status(429).json({
          error: 'Too many login attempts',
          message: 'Please try again later',
          retryAfter: secs
        });
      }
    }

    // Call this after failed login attempt to track failures separately
    export async function recordFailedLogin(email: string, ip: string) {
      const key = `${email}_${ip}`;
      try {
        await failedLoginLimiter.consume(key);
      } catch {
        // Already rate limited, this is expected
      }
    }

    // Check if user is blocked due to failed attempts
    export async function isBlockedFromLogin(email: string, ip: string): Promise<boolean> {
      const key = `${email}_${ip}`;
      try {
        const res = await failedLoginLimiter.get(key);
        return res !== null && res.remainingPoints <= 0;
      } catch {
        return false;
      }
    }
    ```

    Note: Using in-memory rate limiter is acceptable for break-glass because:
    - Break-glass is emergency-only (rare use)
    - If we needed distributed rate limiting, we'd use RateLimiterPostgres
    - For this use case, simplicity > distributed state
  </action>
  <verify>
    npx tsc --noEmit passes
    Rate limiter exports correctly
  </verify>
  <done>
    Rate limiter middleware blocks excessive login attempts with appropriate backoff
  </done>
</task>

<task type="auto">
  <name>Task 2: Create local Passport strategy and emergency login route</name>
  <files>
    src/auth/strategies/local.ts
    src/routes/auth.routes.ts
  </files>
  <action>
    1. Create src/auth/strategies/local.ts:
       ```typescript
       import passport from 'passport';
       import { Strategy as LocalStrategy } from 'passport-local';
       import bcrypt from 'bcrypt';
       import { prisma } from '../config/database';
       import { auditService } from '../services/audit.service';
       import { recordFailedLogin } from '../middleware/rateLimiter';

       export function configureLocalStrategy() {
         passport.use('local', new LocalStrategy({
           usernameField: 'email',
           passwordField: 'password',
           passReqToCallback: true // Get access to req for IP/user-agent
         }, async (req, email, password, done) => {
           const ip = req.ip || 'unknown';
           const userAgent = req.get('user-agent') || 'unknown';

           try {
             // CRITICAL: Only allow break-glass accounts
             const user = await prisma.user.findFirst({
               where: {
                 email: email.toLowerCase(),
                 isBreakGlassAccount: true,
                 isActive: true
               },
               include: {
                 teamMembers: {
                   where: { team: { isActive: true } },
                   include: { team: { select: { id: true, name: true, isActive: true } } }
                 }
               }
             });

             if (!user) {
               await recordFailedLogin(email, ip);
               await auditService.log({
                 action: 'auth.breakglass.failed',
                 severity: 'HIGH',
                 metadata: {
                   email,
                   reason: 'account_not_found_or_not_breakglass'
                 },
                 ipAddress: ip,
                 userAgent
               });
               return done(null, false, { message: 'Invalid credentials' });
             }

             if (!user.passwordHash) {
               await recordFailedLogin(email, ip);
               await auditService.log({
                 action: 'auth.breakglass.failed',
                 userId: user.id,
                 severity: 'HIGH',
                 metadata: { reason: 'no_password_set' },
                 ipAddress: ip,
                 userAgent
               });
               return done(null, false, { message: 'Invalid credentials' });
             }

             const isValid = await bcrypt.compare(password, user.passwordHash);

             if (!isValid) {
               await recordFailedLogin(email, ip);
               await auditService.log({
                 action: 'auth.breakglass.failed',
                 userId: user.id,
                 severity: 'HIGH',
                 metadata: { reason: 'invalid_password' },
                 ipAddress: ip,
                 userAgent
               });
               return done(null, false, { message: 'Invalid credentials' });
             }

             // SUCCESS - Log with HIGH severity (break-glass is sensitive)
             await auditService.log({
               action: 'auth.breakglass.success',
               userId: user.id,
               severity: 'HIGH',
               metadata: {
                 email: user.email,
                 note: 'Break-glass emergency login used'
               },
               ipAddress: ip,
               userAgent
             });

             return done(null, user);
           } catch (error) {
             await auditService.log({
               action: 'auth.breakglass.error',
               severity: 'HIGH',
               metadata: { error: String(error) },
               ipAddress: ip,
               userAgent
             });
             return done(error);
           }
         }));
       }
       ```

    2. Update src/routes/auth.routes.ts to add emergency login:
       ```typescript
       import { loginRateLimiter } from '../middleware/rateLimiter';
       import { configureLocalStrategy } from '../auth/strategies/local';

       // Initialize local strategy (call in app setup)
       // configureLocalStrategy(); // Already called in index.ts

       // Emergency login endpoint (break-glass only)
       authRouter.post('/emergency',
         loginRateLimiter,
         (req, res, next) => {
           passport.authenticate('local', (err, user, info) => {
             if (err) {
               return res.status(500).json({ error: 'Authentication error' });
             }

             if (!user) {
               // Generic error message to not reveal account existence
               return res.status(401).json({
                 error: 'Invalid credentials',
                 message: 'Email or password is incorrect'
               });
             }

             req.logIn(user, (err) => {
               if (err) {
                 return res.status(500).json({ error: 'Session creation failed' });
               }

               res.json({
                 success: true,
                 user: {
                   id: user.id,
                   email: user.email,
                   firstName: user.firstName,
                   lastName: user.lastName,
                   platformRole: user.platformRole,
                   isBreakGlassAccount: true
                 },
                 warning: 'You are using emergency break-glass access. Normal authentication via Okta is recommended.'
               });
             });
           })(req, res, next);
         }
       );
       ```

    3. Update src/index.ts to configure local strategy:
       ```typescript
       import { configureLocalStrategy } from './auth/strategies/local';

       // After configureOktaStrategy()
       configureLocalStrategy();
       ```

    Important security notes (add as comments):
    - Break-glass route is ONLY for emergencies when Okta is unavailable
    - All break-glass logins logged with HIGH severity
    - Rate limiting prevents brute force
    - Generic error messages prevent account enumeration
  </action>
  <verify>
    npx tsc --noEmit passes
    POST /auth/emergency endpoint exists
    Rate limiter applied to emergency route
  </verify>
  <done>
    Break-glass login route with rate limiting, all attempts logged with HIGH severity
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CLI script for break-glass account creation</name>
  <files>
    src/scripts/createBreakGlass.ts
    package.json
  </files>
  <action>
    1. Create src/scripts/createBreakGlass.ts:
       ```typescript
       #!/usr/bin/env npx tsx

       /**
        * Create Break-Glass Admin Account
        *
        * Usage: npm run create-breakglass
        *
        * This script creates a break-glass admin account for emergency access.
        * Break-glass accounts:
        * - Use email/password authentication (not Okta)
        * - Have PLATFORM_ADMIN role
        * - Are for use ONLY when Okta is unavailable
        * - Should be stored securely (e.g., 1Password, LastPass)
        *
        * Per user decision: "Break-glass accounts are specifically for
        * Okta is down during critical incident scenarios"
        */

       import { prisma } from '../config/database';
       import bcrypt from 'bcrypt';
       import crypto from 'crypto';
       import { auditService } from '../services/audit.service';
       import readline from 'readline';

       const rl = readline.createInterface({
         input: process.stdin,
         output: process.stdout
       });

       function question(prompt: string): Promise<string> {
         return new Promise((resolve) => {
           rl.question(prompt, resolve);
         });
       }

       async function main() {
         console.log('\n=== Create Break-Glass Admin Account ===\n');
         console.log('WARNING: This creates an emergency admin account.');
         console.log('Only create 2-3 break-glass accounts for the organization.');
         console.log('Store credentials securely (1Password, LastPass, etc.)\n');

         // Check existing break-glass accounts
         const existing = await prisma.user.count({
           where: { isBreakGlassAccount: true }
         });

         if (existing >= 3) {
           console.log(`WARNING: ${existing} break-glass accounts already exist.`);
           const proceed = await question('Continue anyway? (yes/no): ');
           if (proceed.toLowerCase() !== 'yes') {
             console.log('Aborted.');
             process.exit(0);
           }
         }

         // Gather info
         const email = await question('Email: ');
         if (!email || !email.includes('@')) {
           console.error('Invalid email address');
           process.exit(1);
         }

         // Check if email exists
         const existingUser = await prisma.user.findUnique({
           where: { email: email.toLowerCase() }
         });

         if (existingUser) {
           console.error(`User with email ${email} already exists.`);
           if (!existingUser.isBreakGlassAccount) {
             console.error('This is a regular Okta user, not a break-glass account.');
           }
           process.exit(1);
         }

         const firstName = await question('First Name: ');
         const lastName = await question('Last Name: ');

         // Generate secure password
         const generatePassword = await question('Generate random password? (yes/no): ');
         let password: string;

         if (generatePassword.toLowerCase() === 'yes') {
           password = crypto.randomBytes(16).toString('base64').slice(0, 20);
           console.log(`\nGenerated password: ${password}`);
           console.log('SAVE THIS PASSWORD SECURELY - it cannot be recovered!\n');
         } else {
           password = await question('Password (min 12 chars): ');
           if (password.length < 12) {
             console.error('Password must be at least 12 characters');
             process.exit(1);
           }
           const confirm = await question('Confirm password: ');
           if (password !== confirm) {
             console.error('Passwords do not match');
             process.exit(1);
           }
         }

         // Hash password
         const passwordHash = await bcrypt.hash(password, 12);

         // Create user
         const user = await prisma.user.create({
           data: {
             email: email.toLowerCase(),
             firstName,
             lastName,
             passwordHash,
             isBreakGlassAccount: true,
             platformRole: 'PLATFORM_ADMIN',
             isActive: true,
             syncedFromOkta: false
           }
         });

         // Log creation
         await auditService.log({
           action: 'user.breakglass.created',
           userId: user.id,
           severity: 'HIGH',
           metadata: {
             email: user.email,
             createdBy: 'CLI script'
           }
         });

         console.log('\n=== Break-Glass Account Created ===');
         console.log(`ID: ${user.id}`);
         console.log(`Email: ${user.email}`);
         console.log(`Name: ${user.firstName} ${user.lastName}`);
         console.log(`Role: PLATFORM_ADMIN`);
         console.log('\nLogin URL: /auth/emergency');
         console.log('\nREMEMBER: Store these credentials securely!');

         rl.close();
         await prisma.$disconnect();
       }

       main().catch((error) => {
         console.error('Error:', error);
         process.exit(1);
       });
       ```

    2. Update package.json scripts:
       ```json
       {
         "scripts": {
           "create-breakglass": "tsx src/scripts/createBreakGlass.ts"
         }
       }
       ```

    3. Add to .gitignore (if not already):
       - Never commit break-glass credentials
       - The script itself is fine to commit

    Note: In production, this would be run once during initial setup.
    Credentials should go directly into a secure vault, never in documentation.
  </action>
  <verify>
    npm run create-breakglass runs without syntax errors (can Ctrl+C out)
    Script prompts for email, name, password
  </verify>
  <done>
    CLI script creates break-glass admin accounts with secure password hashing
  </done>
</task>

</tasks>

<verification>
1. POST /auth/emergency returns 429 after 5 attempts in 15 minutes
2. Break-glass login only works for isBreakGlassAccount: true users
3. All break-glass login attempts (success/failure) logged with HIGH severity
4. CLI script creates user with isBreakGlassAccount: true and PLATFORM_ADMIN role
5. Break-glass accounts not exposed via SCIM (verified in Plan 06)
</verification>

<success_criteria>
- Break-glass authentication works independently of Okta
- Rate limiting prevents brute force attacks
- HIGH severity audit logging for all break-glass activity
- CLI tool for secure account creation
- Password hashed with bcrypt (12 rounds)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-05-SUMMARY.md`
</output>

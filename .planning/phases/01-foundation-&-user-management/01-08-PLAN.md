---
phase: 01-foundation-&-user-management
plan: 08
type: execute
wave: 5
depends_on: ["01-04", "01-06"]
files_modified:
  - src/routes/team.routes.ts
  - src/services/team.service.ts
  - src/types/team.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create teams with tags"
    - "Admin can manage team membership"
    - "Users can view all teams (full visibility)"
    - "Team admins can update their team settings"
  artifacts:
    - path: "src/routes/team.routes.ts"
      provides: "Team management API"
      exports: ["teamRouter"]
    - path: "src/services/team.service.ts"
      provides: "Team business logic"
      exports: ["teamService"]
  key_links:
    - from: "src/routes/team.routes.ts"
      to: "src/services/team.service.ts"
      via: "service calls"
      pattern: "teamService\\."
    - from: "src/services/team.service.ts"
      to: "prisma.team"
      via: "database operations"
      pattern: "prisma\\.team"
---

<objective>
Implement team management with flat structure, tags, membership management, and team settings.

Purpose: Per user decision, teams are flat with organizational and technical tags. Hybrid provisioning: initial teams from Okta groups, platform admins can create additional teams.
Output: Complete team CRUD, membership management, tag system, team settings API.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
@.planning/phases/01-foundation-&-user-management/01-03-SUMMARY.md
@.planning/phases/01-foundation-&-user-management/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create team types and service</name>
  <files>
    src/types/team.ts
    src/services/team.service.ts
  </files>
  <action>
    1. Create src/types/team.ts:
       ```typescript
       import { TagType, TeamRole } from '@prisma/client';

       export interface CreateTeamInput {
         name: string;
         description?: string;
         tags?: { type: TagType; value: string }[];
         slackChannel?: string;
       }

       export interface UpdateTeamInput {
         name?: string;
         description?: string;
         slackChannel?: string;
         maintenanceMode?: boolean;
         notificationDefaults?: Record<string, any>;
         escalationDefaults?: Record<string, any>;
       }

       export interface TeamMemberInput {
         userId: string;
         role: TeamRole;
       }

       export interface TeamWithMembers {
         id: string;
         name: string;
         description: string | null;
         isActive: boolean;
         syncedFromOkta: boolean;
         slackChannel: string | null;
         maintenanceMode: boolean;
         tags: { type: TagType; value: string }[];
         members: {
           userId: string;
           email: string;
           firstName: string;
           lastName: string;
           role: TeamRole;
           joinedAt: Date;
         }[];
         memberCount: number;
         responderCount: number;
         hasAdmin: boolean;
         createdAt: Date;
         updatedAt: Date;
       }

       // Predefined tag values (per user decision: organizational + technical)
       export const ORGANIZATIONAL_TAGS = ['Engineering', 'Product', 'SRE', 'Security', 'Support'];
       export const TECHNICAL_TAGS = ['Backend', 'Frontend', 'Mobile', 'Payments', 'Auth', 'Infrastructure', 'Data'];
       ```

    2. Create src/services/team.service.ts:
       ```typescript
       import { prisma } from '../config/database';
       import { auditService } from './audit.service';
       import { CreateTeamInput, UpdateTeamInput, TeamMemberInput, TeamWithMembers } from '../types/team';
       import { TeamRole } from '@prisma/client';

       export class TeamService {
         // Create new team (platform admin only)
         async create(input: CreateTeamInput, createdByUserId: string): Promise<TeamWithMembers> {
           const team = await prisma.team.create({
             data: {
               name: input.name,
               description: input.description,
               slackChannel: input.slackChannel,
               syncedFromOkta: false,
               isActive: true,
               tags: input.tags ? {
                 create: input.tags.map(t => ({
                   tagType: t.type,
                   tagValue: t.value
                 }))
               } : undefined
             },
             include: {
               tags: true,
               members: {
                 include: {
                   user: {
                     select: { id: true, email: true, firstName: true, lastName: true }
                   }
                 }
               }
             }
           });

           await auditService.log({
             action: 'team.created',
             userId: createdByUserId,
             teamId: team.id,
             metadata: {
               name: team.name,
               source: 'platform'
             }
           });

           return this.formatTeam(team);
         }

         // Get team by ID
         async get(teamId: string): Promise<TeamWithMembers | null> {
           const team = await prisma.team.findUnique({
             where: { id: teamId },
             include: {
               tags: true,
               members: {
                 include: {
                   user: {
                     select: { id: true, email: true, firstName: true, lastName: true, isActive: true }
                   }
                 },
                 where: { user: { isActive: true } } // Only active users
               }
             }
           });

           if (!team) return null;
           return this.formatTeam(team);
         }

         // List all teams (full visibility per user decision)
         async list(params: {
           includeArchived?: boolean;
           tagType?: string;
           tagValue?: string;
           limit?: number;
           offset?: number;
         }) {
           const where: any = {};

           if (!params.includeArchived) {
             where.isActive = true;
           }

           if (params.tagType || params.tagValue) {
             where.tags = {
               some: {
                 ...(params.tagType && { tagType: params.tagType }),
                 ...(params.tagValue && { tagValue: params.tagValue })
               }
             };
           }

           const [teams, total] = await Promise.all([
             prisma.team.findMany({
               where,
               include: {
                 tags: true,
                 members: {
                   include: {
                     user: {
                       select: { id: true, email: true, firstName: true, lastName: true, isActive: true }
                     }
                   },
                   where: { user: { isActive: true } }
                 },
                 _count: { select: { members: true } }
               },
               skip: params.offset || 0,
               take: params.limit || 50,
               orderBy: { name: 'asc' }
             }),
             prisma.team.count({ where })
           ]);

           return {
             teams: teams.map(t => this.formatTeam(t)),
             total
           };
         }

         // Update team (team admin or platform admin)
         async update(teamId: string, input: UpdateTeamInput, updatedByUserId: string): Promise<TeamWithMembers | null> {
           const team = await prisma.team.update({
             where: { id: teamId },
             data: {
               name: input.name,
               description: input.description,
               slackChannel: input.slackChannel,
               maintenanceMode: input.maintenanceMode,
               notificationDefaults: input.notificationDefaults,
               escalationDefaults: input.escalationDefaults
             },
             include: {
               tags: true,
               members: {
                 include: {
                   user: {
                     select: { id: true, email: true, firstName: true, lastName: true, isActive: true }
                   }
                 }
               }
             }
           });

           await auditService.log({
             action: 'team.updated',
             userId: updatedByUserId,
             teamId: team.id,
             metadata: {
               changes: Object.keys(input).filter(k => input[k] !== undefined)
             }
           });

           return this.formatTeam(team);
         }

         // Archive team (soft delete)
         async archive(teamId: string, archivedByUserId: string): Promise<boolean> {
           await prisma.team.update({
             where: { id: teamId },
             data: {
               isActive: false,
               archivedAt: new Date()
             }
           });

           await auditService.log({
             action: 'team.archived',
             userId: archivedByUserId,
             teamId,
             severity: 'HIGH',
             metadata: { reason: 'manual_archive' }
           });

           return true;
         }

         // Add member to team
         async addMember(teamId: string, input: TeamMemberInput, addedByUserId: string) {
           // Check if user is already a member
           const existing = await prisma.teamMember.findUnique({
             where: {
               userId_teamId: { userId: input.userId, teamId }
             }
           });

           if (existing) {
             throw new Error('User is already a member of this team');
           }

           const member = await prisma.teamMember.create({
             data: {
               userId: input.userId,
               teamId,
               role: input.role
             },
             include: {
               user: {
                 select: { id: true, email: true, firstName: true, lastName: true }
               }
             }
           });

           await auditService.log({
             action: 'team.member.added',
             userId: addedByUserId,
             teamId,
             metadata: {
               addedUserId: input.userId,
               role: input.role
             }
           });

           return {
             userId: member.userId,
             email: member.user.email,
             firstName: member.user.firstName,
             lastName: member.user.lastName,
             role: member.role,
             joinedAt: member.joinedAt
           };
         }

         // Update member role
         async updateMemberRole(teamId: string, userId: string, newRole: TeamRole, updatedByUserId: string) {
           const member = await prisma.teamMember.update({
             where: {
               userId_teamId: { userId, teamId }
             },
             data: { role: newRole },
             include: {
               user: {
                 select: { id: true, email: true, firstName: true, lastName: true }
               }
             }
           });

           await auditService.log({
             action: 'team.member.role_changed',
             userId: updatedByUserId,
             teamId,
             metadata: {
               targetUserId: userId,
               newRole
             }
           });

           return {
             userId: member.userId,
             email: member.user.email,
             role: member.role
           };
         }

         // Remove member from team
         async removeMember(teamId: string, userId: string, removedByUserId: string, selfRemoval = false) {
           await prisma.teamMember.delete({
             where: {
               userId_teamId: { userId, teamId }
             }
           });

           await auditService.log({
             action: selfRemoval ? 'team.member.self_removed' : 'team.member.removed',
             userId: removedByUserId,
             teamId,
             metadata: {
               removedUserId: userId,
               selfRemoval
             }
           });

           return true;
         }

         // Update team tags
         async updateTags(teamId: string, tags: { type: string; value: string }[], updatedByUserId: string) {
           // Delete existing tags and recreate
           await prisma.teamTag.deleteMany({
             where: { teamId }
           });

           await prisma.teamTag.createMany({
             data: tags.map(t => ({
               teamId,
               tagType: t.type as any,
               tagValue: t.value
             }))
           });

           await auditService.log({
             action: 'team.tags.updated',
             userId: updatedByUserId,
             teamId,
             metadata: { tags }
           });

           return true;
         }

         // Get team health metrics (per user decision: visible to all)
         async getHealthMetrics(teamId: string) {
           const team = await prisma.team.findUnique({
             where: { id: teamId },
             include: {
               members: {
                 where: { user: { isActive: true } },
                 include: {
                   user: {
                     select: { emailVerified: true, phoneVerified: true, pushEnabled: true }
                   }
                 }
               }
             }
           });

           if (!team) return null;

           const responders = team.members.filter(m =>
             m.role === 'TEAM_ADMIN' || m.role === 'RESPONDER'
           );

           const fullyVerifiedResponders = responders.filter(m =>
             m.user.emailVerified && m.user.phoneVerified && m.user.pushEnabled
           );

           // Warnings per user decision: "warn if <3 responders or no admin"
           const warnings: string[] = [];
           if (responders.length < 3) {
             warnings.push('Team has fewer than 3 responders');
           }
           if (!team.members.some(m => m.role === 'TEAM_ADMIN')) {
             warnings.push('Team has no admin');
           }
           if (fullyVerifiedResponders.length < responders.length) {
             warnings.push(`${responders.length - fullyVerifiedResponders.length} responder(s) have unverified contact methods`);
           }

           return {
             memberCount: team.members.length,
             responderCount: responders.length,
             fullyVerifiedResponderCount: fullyVerifiedResponders.length,
             hasAdmin: team.members.some(m => m.role === 'TEAM_ADMIN'),
             maintenanceMode: team.maintenanceMode,
             warnings
           };
         }

         // Format team for API response
         private formatTeam(team: any): TeamWithMembers {
           const members = team.members || [];
           const responders = members.filter(m =>
             m.role === 'TEAM_ADMIN' || m.role === 'RESPONDER'
           );

           return {
             id: team.id,
             name: team.name,
             description: team.description,
             isActive: team.isActive,
             syncedFromOkta: team.syncedFromOkta,
             slackChannel: team.slackChannel,
             maintenanceMode: team.maintenanceMode,
             tags: (team.tags || []).map(t => ({
               type: t.tagType,
               value: t.tagValue
             })),
             members: members.map(m => ({
               userId: m.user.id,
               email: m.user.email,
               firstName: m.user.firstName,
               lastName: m.user.lastName,
               role: m.role,
               joinedAt: m.joinedAt
             })),
             memberCount: members.length,
             responderCount: responders.length,
             hasAdmin: members.some(m => m.role === 'TEAM_ADMIN'),
             createdAt: team.createdAt,
             updatedAt: team.updatedAt
           };
         }
       }

       export const teamService = new TeamService();
       ```
  </action>
  <verify>
    npx tsc --noEmit passes
    TeamService exports correctly
  </verify>
  <done>
    Team service with CRUD, membership management, tags, health metrics, and archiving
  </done>
</task>

<task type="auto">
  <name>Task 2: Create team routes with proper authorization</name>
  <files>
    src/routes/team.routes.ts
  </files>
  <action>
    Create src/routes/team.routes.ts:
    ```typescript
    import { Router } from 'express';
    import { z } from 'zod';
    import { requireAuth, requirePlatformAdmin, requireTeamRole } from '../middleware/auth';
    import { teamService } from '../services/team.service';
    import { ORGANIZATIONAL_TAGS, TECHNICAL_TAGS } from '../types/team';

    export const teamRouter = Router();

    // All team routes require authentication
    teamRouter.use(requireAuth);

    // GET /api/teams - List all teams (full visibility per user decision)
    const ListTeamsSchema = z.object({
      includeArchived: z.coerce.boolean().optional(),
      tagType: z.enum(['ORGANIZATIONAL', 'TECHNICAL']).optional(),
      tagValue: z.string().optional(),
      limit: z.coerce.number().min(1).max(100).default(50),
      offset: z.coerce.number().min(0).default(0)
    });

    teamRouter.get('/', async (req, res) => {
      try {
        const params = ListTeamsSchema.parse(req.query);
        const result = await teamService.list(params);
        res.json(result);
      } catch (error) {
        if (error.name === 'ZodError') {
          return res.status(400).json({ error: 'Invalid query parameters' });
        }
        res.status(500).json({ error: 'Failed to list teams' });
      }
    });

    // GET /api/teams/tags - Get available tag values
    teamRouter.get('/tags', (req, res) => {
      res.json({
        organizational: ORGANIZATIONAL_TAGS,
        technical: TECHNICAL_TAGS
      });
    });

    // GET /api/teams/:teamId - Get team details
    teamRouter.get('/:teamId', async (req, res) => {
      try {
        const team = await teamService.get(req.params.teamId);
        if (!team) {
          return res.status(404).json({ error: 'Team not found' });
        }
        res.json(team);
      } catch (error) {
        res.status(500).json({ error: 'Failed to get team' });
      }
    });

    // GET /api/teams/:teamId/health - Get team health metrics
    teamRouter.get('/:teamId/health', async (req, res) => {
      try {
        const health = await teamService.getHealthMetrics(req.params.teamId);
        if (!health) {
          return res.status(404).json({ error: 'Team not found' });
        }
        res.json(health);
      } catch (error) {
        res.status(500).json({ error: 'Failed to get team health' });
      }
    });

    // POST /api/teams - Create team (platform admin only)
    const CreateTeamSchema = z.object({
      name: z.string().min(2).max(100),
      description: z.string().max(500).optional(),
      slackChannel: z.string().max(100).optional(),
      tags: z.array(z.object({
        type: z.enum(['ORGANIZATIONAL', 'TECHNICAL']),
        value: z.string()
      })).optional()
    });

    teamRouter.post('/', requirePlatformAdmin, async (req, res) => {
      try {
        const input = CreateTeamSchema.parse(req.body);
        const team = await teamService.create(input, (req.user as any).id);
        res.status(201).json(team);
      } catch (error) {
        if (error.name === 'ZodError') {
          return res.status(400).json({ error: 'Invalid team data' });
        }
        res.status(500).json({ error: 'Failed to create team' });
      }
    });

    // PATCH /api/teams/:teamId - Update team (team admin or platform admin)
    const UpdateTeamSchema = z.object({
      name: z.string().min(2).max(100).optional(),
      description: z.string().max(500).optional(),
      slackChannel: z.string().max(100).optional(),
      maintenanceMode: z.boolean().optional(),
      notificationDefaults: z.record(z.any()).optional(),
      escalationDefaults: z.record(z.any()).optional()
    });

    teamRouter.patch('/:teamId', requireTeamRole('TEAM_ADMIN'), async (req, res) => {
      try {
        const input = UpdateTeamSchema.parse(req.body);
        const team = await teamService.update(
          req.params.teamId,
          input,
          (req.user as any).id
        );
        if (!team) {
          return res.status(404).json({ error: 'Team not found' });
        }
        res.json(team);
      } catch (error) {
        if (error.name === 'ZodError') {
          return res.status(400).json({ error: 'Invalid team data' });
        }
        res.status(500).json({ error: 'Failed to update team' });
      }
    });

    // PUT /api/teams/:teamId/tags - Update team tags (team admin)
    const UpdateTagsSchema = z.object({
      tags: z.array(z.object({
        type: z.enum(['ORGANIZATIONAL', 'TECHNICAL']),
        value: z.string()
      }))
    });

    teamRouter.put('/:teamId/tags', requireTeamRole('TEAM_ADMIN'), async (req, res) => {
      try {
        const { tags } = UpdateTagsSchema.parse(req.body);
        await teamService.updateTags(
          req.params.teamId,
          tags,
          (req.user as any).id
        );
        res.json({ success: true });
      } catch (error) {
        res.status(500).json({ error: 'Failed to update tags' });
      }
    });

    // DELETE /api/teams/:teamId - Archive team (platform admin only)
    teamRouter.delete('/:teamId', requirePlatformAdmin, async (req, res) => {
      try {
        await teamService.archive(req.params.teamId, (req.user as any).id);
        res.json({ success: true, archived: true });
      } catch (error) {
        res.status(500).json({ error: 'Failed to archive team' });
      }
    });

    // ============ MEMBERSHIP ============

    // POST /api/teams/:teamId/members - Add member (team admin)
    const AddMemberSchema = z.object({
      userId: z.string(),
      role: z.enum(['TEAM_ADMIN', 'RESPONDER', 'OBSERVER'])
    });

    teamRouter.post('/:teamId/members', requireTeamRole('TEAM_ADMIN'), async (req, res) => {
      try {
        const input = AddMemberSchema.parse(req.body);
        const member = await teamService.addMember(
          req.params.teamId,
          input,
          (req.user as any).id
        );
        res.status(201).json(member);
      } catch (error) {
        if (error.message?.includes('already a member')) {
          return res.status(409).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to add member' });
      }
    });

    // PATCH /api/teams/:teamId/members/:userId - Update member role (team admin)
    const UpdateMemberSchema = z.object({
      role: z.enum(['TEAM_ADMIN', 'RESPONDER', 'OBSERVER'])
    });

    teamRouter.patch('/:teamId/members/:userId', requireTeamRole('TEAM_ADMIN'), async (req, res) => {
      try {
        const { role } = UpdateMemberSchema.parse(req.body);
        const member = await teamService.updateMemberRole(
          req.params.teamId,
          req.params.userId,
          role,
          (req.user as any).id
        );
        res.json(member);
      } catch (error) {
        res.status(500).json({ error: 'Failed to update member role' });
      }
    });

    // DELETE /api/teams/:teamId/members/:userId - Remove member (team admin or self)
    teamRouter.delete('/:teamId/members/:userId', async (req, res) => {
      const currentUser = req.user as any;
      const targetUserId = req.params.userId;
      const teamId = req.params.teamId;

      // Self-removal allowed per user decision
      const isSelf = currentUser.id === targetUserId;

      if (!isSelf) {
        // Check if user is team admin for non-self removal
        const membership = currentUser.teamMembers?.find(m => m.teamId === teamId);
        const isTeamAdmin = membership?.role === 'TEAM_ADMIN';
        const isPlatformAdmin = currentUser.platformRole === 'PLATFORM_ADMIN';

        if (!isTeamAdmin && !isPlatformAdmin) {
          return res.status(403).json({ error: 'Cannot remove other members' });
        }
      }

      try {
        await teamService.removeMember(
          teamId,
          targetUserId,
          currentUser.id,
          isSelf
        );
        res.json({ success: true });
      } catch (error) {
        res.status(500).json({ error: 'Failed to remove member' });
      }
    });
    ```
  </action>
  <verify>
    npx tsc --noEmit passes
    Team routes export correctly
  </verify>
  <done>
    Team routes with full CRUD, membership management, tag updates, archiving, and proper authorization
  </done>
</task>

<task type="auto">
  <name>Task 3: Mount team routes and finalize integration</name>
  <files>
    src/index.ts
  </files>
  <action>
    Update src/index.ts to mount team routes:

    ```typescript
    import { teamRouter } from './routes/team.routes';

    // Mount team routes
    app.use('/api/teams', teamRouter);
    ```

    Also ensure all routes are properly ordered:
    1. Health check (no auth)
    2. SCIM routes (SCIM auth)
    3. Okta webhook routes (webhook auth)
    4. Auth routes (mixed - some public, some require auth)
    5. API routes (all require auth):
       - /api/audit
       - /api/users
       - /api/notifications
       - /api/teams

    Add CORS and final middleware if not already present:
    ```typescript
    import cors from 'cors';

    // CORS for frontend
    app.use(cors({
      origin: process.env.FRONTEND_URL || 'http://localhost:3001',
      credentials: true
    }));
    ```

    Add global error handler:
    ```typescript
    // Global error handler (last middleware)
    app.use((err: any, req: Request, res: Response, next: NextFunction) => {
      console.error('Unhandled error:', err);

      // Don't expose internal errors
      res.status(500).json({
        error: 'Internal server error',
        ...(process.env.NODE_ENV === 'development' && { details: err.message })
      });
    });
    ```
  </action>
  <verify>
    npm run dev starts without errors
    GET /api/teams returns list of teams
    POST /api/teams (with admin auth) creates team
    Team membership endpoints work correctly
  </verify>
  <done>
    Team routes mounted, all Phase 1 API routes integrated, error handling in place
  </done>
</task>

</tasks>

<verification>
1. GET /api/teams returns all active teams (full visibility)
2. GET /api/teams/:teamId returns team with members and tags
3. GET /api/teams/:teamId/health returns warnings for <3 responders or no admin
4. POST /api/teams creates team (platform admin only)
5. PATCH /api/teams/:teamId updates team (team admin or platform admin)
6. POST /api/teams/:teamId/members adds member with role
7. DELETE /api/teams/:teamId/members/:userId allows self-removal
8. Team archiving (DELETE) soft-deletes team
</verification>

<success_criteria>
- Full visibility: any authenticated user can view any team
- Flat team structure with organizational and technical tags
- Team admins can manage their team members and settings
- Platform admins can create teams and manage all teams
- Users can self-remove from teams (per user decision)
- Health metrics warn about <3 responders or no admin (per user decision)
- All team actions logged to audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-08-SUMMARY.md`
</output>

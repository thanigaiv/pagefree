---
phase: 01-foundation-&-user-management
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/permission.service.ts
  - src/middleware/auth.ts
  - src/types/auth.ts
autonomous: true

must_haves:
  truths:
    - "Platform admins can access all resources"
    - "Team admins can manage their own team"
    - "Responders can only acknowledge/resolve incidents on their teams"
    - "Observers have read-only access"
  artifacts:
    - path: "src/services/permission.service.ts"
      provides: "RBAC permission checking"
      exports: ["PermissionService", "permissionService"]
    - path: "src/middleware/auth.ts"
      provides: "Authentication and authorization middleware"
      exports: ["requireAuth", "requirePlatformAdmin", "requireTeamRole"]
  key_links:
    - from: "src/middleware/auth.ts"
      to: "src/services/permission.service.ts"
      via: "permission checks"
      pattern: "permissionService\\.can"
---

<objective>
Implement the two-level RBAC system with platform roles and team-specific roles.

Purpose: Per user decision, the platform needs both global platform roles (PLATFORM_ADMIN, USER) AND per-team roles (TEAM_ADMIN, RESPONDER, OBSERVER). This enables fine-grained access control.
Output: PermissionService with role checks, Express middleware for protecting routes.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
@.planning/phases/01-foundation-&-user-management/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth types and PermissionService</name>
  <files>
    src/types/auth.ts
    src/services/permission.service.ts
  </files>
  <action>
    1. Create src/types/auth.ts:
       ```typescript
       import { PlatformRole, TeamRole, User, TeamMember } from '@prisma/client';

       // User with their team memberships loaded
       export interface AuthenticatedUser extends User {
         teamMembers: (TeamMember & { team: { id: string; name: string; isActive: boolean } })[];
       }

       // Extend Express Request
       declare global {
         namespace Express {
           interface User extends AuthenticatedUser {}
         }
       }

       // Permission check result
       export interface PermissionResult {
         allowed: boolean;
         reason?: string;
       }
       ```

    2. Create src/services/permission.service.ts:
       - Class PermissionService with constructor taking PrismaClient

       Role hierarchy (from user decisions):
       - PLATFORM_ADMIN: complete control across all teams
       - TEAM_ADMIN: full team control
       - RESPONDER: can acknowledge and resolve incidents
       - OBSERVER: read-only

       Methods:

       **isPlatformAdmin(user: AuthenticatedUser): boolean**
       - Returns user.platformRole === 'PLATFORM_ADMIN'

       **getTeamRole(user: AuthenticatedUser, teamId: string): TeamRole | null**
       - Finds membership in user.teamMembers for teamId
       - Returns role or null if not a member

       **canManageTeam(user: AuthenticatedUser, teamId: string): PermissionResult**
       - Platform admins: always allowed
       - Team members with TEAM_ADMIN role: allowed
       - Others: not allowed

       **canViewTeam(user: AuthenticatedUser, teamId: string): PermissionResult**
       - Per user decision: "Full visibility - all teams can see other teams' incidents"
       - Any authenticated user can view any team
       - Return allowed: true for all authenticated users

       **canRespondToIncident(user: AuthenticatedUser, teamId: string): PermissionResult**
       - Platform admins: allowed
       - Team members with TEAM_ADMIN or RESPONDER role: allowed
       - OBSERVER: not allowed
       - Non-members: not allowed

       **canViewAuditLogs(user: AuthenticatedUser, teamId?: string): PermissionResult**
       - Platform admins: always allowed (see all)
       - If teamId provided: Team admins can see their team's logs
       - Others: not allowed to query audit logs

       **canInviteUsers(user: AuthenticatedUser): PermissionResult**
       - Only platform admins (per user decision: invite goes through Okta)

       **canManageTeamMembers(user: AuthenticatedUser, teamId: string): PermissionResult**
       - Platform admins: allowed
       - Team admins for that team: allowed
       - Others: not allowed

       **canCreateTeam(user: AuthenticatedUser): PermissionResult**
       - Per user decision: "Request-based (users request new teams, platform admin approves)"
       - Only platform admins can directly create teams
       - Regular users can request (implemented in team routes)

       Helper function:
       ```typescript
       const TEAM_ROLE_HIERARCHY: Record<TeamRole, number> = {
         OBSERVER: 1,
         RESPONDER: 2,
         TEAM_ADMIN: 3
       };

       hasMinimumTeamRole(user: AuthenticatedUser, teamId: string, minRole: TeamRole): boolean {
         if (this.isPlatformAdmin(user)) return true;
         const role = this.getTeamRole(user, teamId);
         if (!role) return false;
         return TEAM_ROLE_HIERARCHY[role] >= TEAM_ROLE_HIERARCHY[minRole];
       }
       ```

       Export singleton: export const permissionService = new PermissionService(prisma);
  </action>
  <verify>
    npx tsc --noEmit passes
    PermissionService exports all required methods
  </verify>
  <done>
    PermissionService implements two-level RBAC with platform and team role checks
  </done>
</task>

<task type="auto">
  <name>Task 2: Create authentication and authorization middleware</name>
  <files>
    src/middleware/auth.ts
  </files>
  <action>
    Create src/middleware/auth.ts with Express middleware functions:

    **requireAuth**
    - Checks if req.user exists (Passport sets this after authentication)
    - If not authenticated, returns 401 { error: 'Authentication required' }
    - If user is inactive (soft deleted), returns 403 { error: 'Account is deactivated' }
    - Calls next() if authenticated and active

    **requirePlatformAdmin**
    - Composes with requireAuth (calls next only if authenticated)
    - Checks permissionService.isPlatformAdmin(req.user)
    - Returns 403 { error: 'Platform admin access required' } if not admin

    **requireTeamRole(minRole: TeamRole)**
    - Returns middleware function
    - Extracts teamId from req.params.teamId
    - If no teamId, returns 400 { error: 'Team ID required' }
    - Checks permissionService.hasMinimumTeamRole(req.user, teamId, minRole)
    - Returns 403 { error: 'Insufficient team permissions' } if not allowed
    - Calls next() if allowed

    **requireTeamMember**
    - Shorthand for requireTeamRole('OBSERVER') - any team role is sufficient

    **requireTeamAdmin**
    - Shorthand for requireTeamRole('TEAM_ADMIN')

    **requireResponder**
    - Shorthand for requireTeamRole('RESPONDER')

    **optionalAuth**
    - Like requireAuth but doesn't fail if not authenticated
    - Sets req.user to null if not authenticated
    - Always calls next()

    Example usage (for documentation in comments):
    ```typescript
    // Protect route - only platform admins
    router.post('/users', requirePlatformAdmin, createUser);

    // Protect route - team admins only
    router.put('/teams/:teamId/settings', requireAuth, requireTeamRole('TEAM_ADMIN'), updateTeamSettings);

    // Protect route - responders can acknowledge
    router.post('/teams/:teamId/incidents/:id/ack', requireAuth, requireTeamRole('RESPONDER'), ackIncident);
    ```

    Important: These middleware assume req.user has teamMembers populated. The Passport deserialize function (Plan 04) must include teamMembers in the query.
  </action>
  <verify>
    npx tsc --noEmit passes
    All middleware exports correctly
  </verify>
  <done>
    Auth middleware provides requireAuth, requirePlatformAdmin, requireTeamRole with proper error responses
  </done>
</task>

<task type="auto">
  <name>Task 3: Add RBAC to audit routes and document patterns</name>
  <files>
    src/routes/audit.routes.ts
    src/utils/permissions.ts
  </files>
  <action>
    1. Update src/routes/audit.routes.ts to add authorization:
       - GET /api/audit: requireAuth middleware
         - If user is platform admin: return all matching events
         - If user is not platform admin and teamId query param provided:
           - Check permissionService.canViewAuditLogs(req.user, teamId)
           - If not allowed, return 403
         - If user is not platform admin and no teamId:
           - Return only events for teams where user is TEAM_ADMIN
           - Filter query to only include those teamIds

       - POST /api/audit/cleanup: requirePlatformAdmin middleware

    2. Create src/utils/permissions.ts with helper functions:
       ```typescript
       import { AuthenticatedUser } from '../types/auth';

       // Get all team IDs where user has admin role
       export function getAdminTeamIds(user: AuthenticatedUser): string[] {
         if (user.platformRole === 'PLATFORM_ADMIN') {
           return []; // Platform admin sees all, no filter needed
         }
         return user.teamMembers
           .filter(m => m.role === 'TEAM_ADMIN')
           .map(m => m.teamId);
       }

       // Check if user can access specific team's audit logs
       export function canAccessTeamAuditLogs(user: AuthenticatedUser, teamId: string): boolean {
         if (user.platformRole === 'PLATFORM_ADMIN') return true;
         const membership = user.teamMembers.find(m => m.teamId === teamId);
         return membership?.role === 'TEAM_ADMIN';
       }
       ```

    3. Add inline documentation explaining the RBAC model for future developers:
       ```typescript
       /**
        * RBAC Model (per user decisions in 01-CONTEXT.md):
        *
        * Platform Roles:
        *   - PLATFORM_ADMIN: Complete control across all teams
        *   - USER: Regular user, permissions determined by team membership
        *
        * Team Roles (per-team):
        *   - TEAM_ADMIN: Full team control (add/remove users, configure schedules, etc.)
        *   - RESPONDER: Can acknowledge and resolve incidents
        *   - OBSERVER: Read-only for stakeholders, managers, support staff
        *
        * Key behaviors:
        *   - Users can be on multiple teams with different roles per team
        *   - Full visibility: all teams can see other teams' incidents/schedules
        *   - Audit logs: team admins see their team, platform admins see all
        */
       ```
  </action>
  <verify>
    npx tsc --noEmit passes
    Audit routes have authorization middleware applied
  </verify>
  <done>
    RBAC applied to audit routes, permission helpers documented, patterns established for other routes
  </done>
</task>

</tasks>

<verification>
1. PermissionService correctly implements two-level RBAC
2. requireAuth blocks unauthenticated requests with 401
3. requirePlatformAdmin blocks non-admin users with 403
4. requireTeamRole checks team membership and role hierarchy
5. Audit routes properly restrict access based on roles
</verification>

<success_criteria>
- Platform admins bypass all team role checks
- Team admins can manage their teams but not other teams
- Responders can respond to incidents on their teams
- Observers have read-only access
- Full visibility implemented (per user decision: all teams can see other teams)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-03-SUMMARY.md`
</output>

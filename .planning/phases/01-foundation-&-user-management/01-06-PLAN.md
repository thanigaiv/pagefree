---
phase: 01-foundation-&-user-management
plan: 06
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - src/auth/scim/routes.ts
  - src/auth/scim/schemas.ts
  - src/auth/scim/users.ts
  - src/auth/scim/groups.ts
  - src/middleware/scimAuth.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: okta
    why: "SCIM provisioning configuration"
    dashboard_config:
      - task: "Configure SCIM provisioning"
        location: "Okta Admin Console -> Applications -> Your App -> Provisioning -> Configure API Integration"
      - task: "Set SCIM base URL"
        location: "Set to https://yourapp.com/scim/v2"
      - task: "Add SCIM bearer token"
        location: "Use value from SCIM_BEARER_TOKEN env var"

must_haves:
  truths:
    - "Okta can provision users via SCIM"
    - "Okta can sync groups to teams via SCIM"
    - "User deactivation in Okta soft-deletes user in platform"
    - "Break-glass accounts are not exposed via SCIM"
  artifacts:
    - path: "src/auth/scim/routes.ts"
      provides: "SCIM 2.0 router"
      exports: ["scimRouter"]
    - path: "src/auth/scim/users.ts"
      provides: "SCIM user operations"
      exports: ["ScimUserService"]
    - path: "src/auth/scim/groups.ts"
      provides: "SCIM group operations (teams)"
      exports: ["ScimGroupService"]
  key_links:
    - from: "src/auth/scim/users.ts"
      to: "prisma.user"
      via: "user provisioning"
      pattern: "prisma\\.user\\.(create|update|findMany)"
    - from: "src/auth/scim/groups.ts"
      to: "prisma.team"
      via: "team provisioning"
      pattern: "prisma\\.team\\.(create|update|findMany)"
---

<objective>
Implement SCIM 2.0 server endpoints for Okta user and group provisioning.

Purpose: Per user decision, use both SAML (authentication) + SCIM (user provisioning). SCIM enables Okta to automatically create/update/deactivate users and sync groups to teams.
Output: Full SCIM 2.0 implementation with /Users and /Groups endpoints following RFC 7644.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
@.planning/phases/01-foundation-&-user-management/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SCIM authentication middleware and schemas</name>
  <files>
    src/middleware/scimAuth.ts
    src/auth/scim/schemas.ts
  </files>
  <action>
    1. Create src/middleware/scimAuth.ts:
       ```typescript
       import { Request, Response, NextFunction } from 'express';
       import crypto from 'crypto';
       import { env } from '../config/env';
       import { auditService } from '../services/audit.service';

       export async function scimAuth(req: Request, res: Response, next: NextFunction) {
         const authHeader = req.headers.authorization;

         if (!authHeader || !authHeader.startsWith('Bearer ')) {
           await auditService.log({
             action: 'scim.auth.missing',
             severity: 'WARN',
             metadata: { path: req.path },
             ipAddress: req.ip
           });

           return res.status(401).json({
             schemas: ['urn:ietf:params:scim:api:messages:2.0:Error'],
             status: '401',
             detail: 'Authentication required'
           });
         }

         const token = authHeader.replace('Bearer ', '');

         // Constant-time comparison to prevent timing attacks
         const expectedToken = env.SCIM_BEARER_TOKEN;
         if (!expectedToken) {
           console.error('SCIM_BEARER_TOKEN not configured');
           return res.status(500).json({
             schemas: ['urn:ietf:params:scim:api:messages:2.0:Error'],
             status: '500',
             detail: 'SCIM not configured'
           });
         }

         try {
           const isValid = crypto.timingSafeEqual(
             Buffer.from(token),
             Buffer.from(expectedToken)
           );

           if (!isValid) {
             throw new Error('Token mismatch');
           }
         } catch {
           await auditService.log({
             action: 'scim.auth.invalid',
             severity: 'HIGH',
             metadata: { path: req.path },
             ipAddress: req.ip
           });

           return res.status(401).json({
             schemas: ['urn:ietf:params:scim:api:messages:2.0:Error'],
             status: '401',
             detail: 'Invalid authentication'
           });
         }

         next();
       }
       ```

    2. Create src/auth/scim/schemas.ts with Zod schemas for SCIM:
       ```typescript
       import { z } from 'zod';

       // SCIM User schema (per RFC 7643)
       export const ScimUserSchema = z.object({
         schemas: z.array(z.string()),
         externalId: z.string().optional(),
         userName: z.string(),
         name: z.object({
           givenName: z.string(),
           familyName: z.string(),
           formatted: z.string().optional()
         }).optional(),
         emails: z.array(z.object({
           value: z.string().email(),
           primary: z.boolean().optional(),
           type: z.string().optional()
         })).optional(),
         phoneNumbers: z.array(z.object({
           value: z.string(),
           type: z.string().optional()
         })).optional(),
         active: z.boolean().optional()
       });

       // SCIM Group schema
       export const ScimGroupSchema = z.object({
         schemas: z.array(z.string()),
         externalId: z.string().optional(),
         displayName: z.string(),
         members: z.array(z.object({
           value: z.string(),
           display: z.string().optional()
         })).optional()
       });

       // SCIM Patch operation
       export const ScimPatchSchema = z.object({
         schemas: z.array(z.string()),
         Operations: z.array(z.object({
           op: z.enum(['add', 'remove', 'replace']),
           path: z.string().optional(),
           value: z.any().optional()
         }))
       });

       // SCIM List response
       export interface ScimListResponse<T> {
         schemas: string[];
         totalResults: number;
         startIndex: number;
         itemsPerPage: number;
         Resources: T[];
       }

       // SCIM error response
       export interface ScimError {
         schemas: string[];
         status: string;
         detail: string;
       }

       export const SCIM_SCHEMAS = {
         USER: 'urn:ietf:params:scim:schemas:core:2.0:User',
         GROUP: 'urn:ietf:params:scim:schemas:core:2.0:Group',
         LIST_RESPONSE: 'urn:ietf:params:scim:api:messages:2.0:ListResponse',
         PATCH: 'urn:ietf:params:scim:api:messages:2.0:PatchOp',
         ERROR: 'urn:ietf:params:scim:api:messages:2.0:Error'
       };
       ```
  </action>
  <verify>
    npx tsc --noEmit passes
    SCIM auth middleware and schemas export correctly
  </verify>
  <done>
    SCIM bearer token authentication and Zod schemas for SCIM resources
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SCIM Users endpoints</name>
  <files>
    src/auth/scim/users.ts
  </files>
  <action>
    Create src/auth/scim/users.ts:

    ```typescript
    import { prisma } from '../../config/database';
    import { auditService } from '../../services/audit.service';
    import { ScimUserSchema, SCIM_SCHEMAS, ScimListResponse } from './schemas';
    import { parse as parseScimFilter } from 'scim2-parse-filter';

    // Convert internal User to SCIM User representation
    function toScimUser(user: any) {
      return {
        schemas: [SCIM_SCHEMAS.USER],
        id: user.id,
        externalId: user.oktaId,
        userName: user.email,
        name: {
          givenName: user.firstName,
          familyName: user.lastName,
          formatted: `${user.firstName} ${user.lastName}`
        },
        emails: [{
          value: user.email,
          primary: true,
          type: 'work'
        }],
        phoneNumbers: user.phone ? [{
          value: user.phone,
          type: 'mobile'
        }] : [],
        active: user.isActive,
        meta: {
          resourceType: 'User',
          created: user.createdAt.toISOString(),
          lastModified: user.updatedAt.toISOString()
        }
      };
    }

    export class ScimUserService {
      // GET /scim/v2/Users - List users with filtering
      async list(params: {
        filter?: string;
        startIndex?: number;
        count?: number;
      }): Promise<ScimListResponse<any>> {
        const startIndex = params.startIndex || 1;
        const count = Math.min(params.count || 100, 200);

        // Base query: exclude break-glass accounts (per user decision)
        let users = await prisma.user.findMany({
          where: {
            isBreakGlassAccount: false,
            syncedFromOkta: true  // Only return Okta-provisioned users
          },
          skip: startIndex - 1,
          take: count,
          orderBy: { createdAt: 'asc' }
        });

        // Apply SCIM filter if provided
        if (params.filter) {
          try {
            const filterAst = parseScimFilter(params.filter);
            users = users.filter(user => this.matchesFilter(user, filterAst));
          } catch (error) {
            // Log but don't fail - return unfiltered results
            console.warn('SCIM filter parse error:', error);
          }
        }

        const totalResults = await prisma.user.count({
          where: {
            isBreakGlassAccount: false,
            syncedFromOkta: true
          }
        });

        return {
          schemas: [SCIM_SCHEMAS.LIST_RESPONSE],
          totalResults,
          startIndex,
          itemsPerPage: users.length,
          Resources: users.map(toScimUser)
        };
      }

      // GET /scim/v2/Users/:id
      async get(id: string) {
        const user = await prisma.user.findUnique({
          where: { id }
        });

        // Don't expose break-glass accounts
        if (!user || user.isBreakGlassAccount) {
          return null;
        }

        return toScimUser(user);
      }

      // POST /scim/v2/Users - Create user
      async create(data: any) {
        const parsed = ScimUserSchema.parse(data);

        const email = parsed.emails?.[0]?.value || parsed.userName;

        // Check if user already exists
        const existing = await prisma.user.findUnique({
          where: { email: email.toLowerCase() }
        });

        if (existing) {
          // Return existing user (idempotent)
          return { user: toScimUser(existing), created: false };
        }

        const user = await prisma.user.create({
          data: {
            oktaId: parsed.externalId,
            email: email.toLowerCase(),
            firstName: parsed.name?.givenName || '',
            lastName: parsed.name?.familyName || '',
            phone: parsed.phoneNumbers?.[0]?.value,
            isActive: parsed.active !== false,
            syncedFromOkta: true,
            isBreakGlassAccount: false
          }
        });

        await auditService.log({
          action: 'user.provisioned',
          userId: user.id,
          metadata: {
            source: 'scim',
            oktaId: parsed.externalId,
            email: user.email
          }
        });

        return { user: toScimUser(user), created: true };
      }

      // PUT /scim/v2/Users/:id - Full update
      async update(id: string, data: any) {
        const user = await prisma.user.findUnique({
          where: { id }
        });

        if (!user || user.isBreakGlassAccount) {
          return null;
        }

        const parsed = ScimUserSchema.parse(data);

        const updated = await prisma.user.update({
          where: { id },
          data: {
            oktaId: parsed.externalId || user.oktaId,
            email: (parsed.emails?.[0]?.value || parsed.userName).toLowerCase(),
            firstName: parsed.name?.givenName || user.firstName,
            lastName: parsed.name?.familyName || user.lastName,
            phone: parsed.phoneNumbers?.[0]?.value || user.phone,
            isActive: parsed.active !== false,
            deactivatedAt: parsed.active === false ? new Date() : null
          }
        });

        await auditService.log({
          action: 'user.updated',
          userId: user.id,
          metadata: { source: 'scim' }
        });

        return toScimUser(updated);
      }

      // PATCH /scim/v2/Users/:id - Partial update (including deactivation)
      async patch(id: string, operations: any[]) {
        const user = await prisma.user.findUnique({
          where: { id }
        });

        if (!user || user.isBreakGlassAccount) {
          return null;
        }

        // Process each operation
        const updateData: any = {};

        for (const op of operations) {
          if (op.op === 'replace') {
            if (op.path === 'active' && op.value === false) {
              // Soft delete (per user decision)
              updateData.isActive = false;
              updateData.deactivatedAt = new Date();

              await auditService.log({
                action: 'user.deprovisioned',
                userId: user.id,
                severity: 'HIGH',
                metadata: {
                  source: 'scim',
                  reason: 'okta_deactivation'
                }
              });

              // Also invalidate sessions and refresh tokens
              await prisma.session.deleteMany({
                where: {
                  sess: {
                    path: ['passport', 'user'],
                    equals: user.id
                  }
                }
              });

              await prisma.refreshToken.deleteMany({
                where: { userId: user.id }
              });

            } else if (op.path === 'active' && op.value === true) {
              updateData.isActive = true;
              updateData.deactivatedAt = null;

              await auditService.log({
                action: 'user.reactivated',
                userId: user.id,
                metadata: { source: 'scim' }
              });
            }

            // Handle other attribute updates
            if (op.path === 'name.givenName') {
              updateData.firstName = op.value;
            }
            if (op.path === 'name.familyName') {
              updateData.lastName = op.value;
            }
            if (op.path === 'emails[type eq "work"].value') {
              updateData.email = op.value.toLowerCase();
            }
          }
        }

        if (Object.keys(updateData).length > 0) {
          const updated = await prisma.user.update({
            where: { id },
            data: updateData
          });
          return toScimUser(updated);
        }

        return toScimUser(user);
      }

      // Helper: Match user against SCIM filter AST
      private matchesFilter(user: any, filterAst: any): boolean {
        // Basic filter support for common Okta queries
        if (filterAst.op === 'eq') {
          if (filterAst.attrPath === 'userName') {
            return user.email.toLowerCase() === filterAst.compValue.toLowerCase();
          }
          if (filterAst.attrPath === 'externalId') {
            return user.oktaId === filterAst.compValue;
          }
        }
        // Add more filter operations as needed
        return true; // Default: include
      }
    }

    export const scimUserService = new ScimUserService();
    ```
  </action>
  <verify>
    npx tsc --noEmit passes
    ScimUserService exports correctly
  </verify>
  <done>
    SCIM Users endpoints: list with filtering, get, create, update, patch (soft delete)
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement SCIM Groups endpoints and mount router</name>
  <files>
    src/auth/scim/groups.ts
    src/auth/scim/routes.ts
    src/index.ts
  </files>
  <action>
    1. Create src/auth/scim/groups.ts:
       ```typescript
       import { prisma } from '../../config/database';
       import { auditService } from '../../services/audit.service';
       import { ScimGroupSchema, SCIM_SCHEMAS, ScimListResponse } from './schemas';

       // Convert internal Team to SCIM Group representation
       function toScimGroup(team: any, includeMembers = false) {
         const group: any = {
           schemas: [SCIM_SCHEMAS.GROUP],
           id: team.id,
           externalId: team.oktaGroupId,
           displayName: team.name,
           meta: {
             resourceType: 'Group',
             created: team.createdAt.toISOString(),
             lastModified: team.updatedAt.toISOString()
           }
         };

         if (includeMembers && team.members) {
           group.members = team.members.map((m: any) => ({
             value: m.user.id,
             display: m.user.email
           }));
         }

         return group;
       }

       export class ScimGroupService {
         // GET /scim/v2/Groups - List groups
         async list(params: {
           filter?: string;
           startIndex?: number;
           count?: number;
         }): Promise<ScimListResponse<any>> {
           const startIndex = params.startIndex || 1;
           const count = Math.min(params.count || 100, 200);

           // Only return Okta-synced teams
           const teams = await prisma.team.findMany({
             where: {
               syncedFromOkta: true,
               isActive: true
             },
             skip: startIndex - 1,
             take: count,
             include: {
               members: {
                 include: {
                   user: { select: { id: true, email: true } }
                 }
               }
             }
           });

           const totalResults = await prisma.team.count({
             where: {
               syncedFromOkta: true,
               isActive: true
             }
           });

           return {
             schemas: [SCIM_SCHEMAS.LIST_RESPONSE],
             totalResults,
             startIndex,
             itemsPerPage: teams.length,
             Resources: teams.map(t => toScimGroup(t, true))
           };
         }

         // GET /scim/v2/Groups/:id
         async get(id: string) {
           const team = await prisma.team.findUnique({
             where: { id },
             include: {
               members: {
                 include: {
                   user: { select: { id: true, email: true } }
                 }
               }
             }
           });

           if (!team) {
             return null;
           }

           return toScimGroup(team, true);
         }

         // POST /scim/v2/Groups - Create group (team)
         async create(data: any) {
           const parsed = ScimGroupSchema.parse(data);

           // Check if group already exists by oktaGroupId
           if (parsed.externalId) {
             const existing = await prisma.team.findUnique({
               where: { oktaGroupId: parsed.externalId }
             });

             if (existing) {
               return { team: toScimGroup(existing), created: false };
             }
           }

           const team = await prisma.team.create({
             data: {
               name: parsed.displayName,
               oktaGroupId: parsed.externalId,
               syncedFromOkta: true,
               isActive: true
             }
           });

           // Add members if provided
           if (parsed.members && parsed.members.length > 0) {
             for (const member of parsed.members) {
               const user = await prisma.user.findUnique({
                 where: { id: member.value }
               });

               if (user) {
                 await prisma.teamMember.create({
                   data: {
                     userId: user.id,
                     teamId: team.id,
                     role: 'RESPONDER' // Default role from SCIM
                   }
                 });
               }
             }
           }

           await auditService.log({
             action: 'team.provisioned',
             teamId: team.id,
             metadata: {
               source: 'scim',
               oktaGroupId: parsed.externalId,
               name: team.name
             }
           });

           const created = await prisma.team.findUnique({
             where: { id: team.id },
             include: {
               members: {
                 include: {
                   user: { select: { id: true, email: true } }
                 }
               }
             }
           });

           return { team: toScimGroup(created, true), created: true };
         }

         // PATCH /scim/v2/Groups/:id - Update group membership
         async patch(id: string, operations: any[]) {
           const team = await prisma.team.findUnique({
             where: { id }
           });

           if (!team) {
             return null;
           }

           for (const op of operations) {
             // Handle member add/remove
             if (op.path === 'members') {
               if (op.op === 'add' && op.value) {
                 for (const member of op.value) {
                   const user = await prisma.user.findUnique({
                     where: { id: member.value }
                   });

                   if (user) {
                     await prisma.teamMember.upsert({
                       where: {
                         userId_teamId: { userId: user.id, teamId: team.id }
                       },
                       create: {
                         userId: user.id,
                         teamId: team.id,
                         role: 'RESPONDER'
                       },
                       update: {} // No-op if exists
                     });

                     await auditService.log({
                       action: 'team.member.added',
                       teamId: team.id,
                       userId: user.id,
                       metadata: { source: 'scim' }
                     });
                   }
                 }
               }

               if (op.op === 'remove' && op.value) {
                 for (const member of op.value) {
                   await prisma.teamMember.deleteMany({
                     where: {
                       teamId: team.id,
                       userId: member.value
                     }
                   });

                   await auditService.log({
                     action: 'team.member.removed',
                     teamId: team.id,
                     metadata: {
                       source: 'scim',
                       removedUserId: member.value
                     }
                   });
                 }
               }
             }

             // Handle displayName update
             if (op.path === 'displayName' && op.op === 'replace') {
               await prisma.team.update({
                 where: { id },
                 data: { name: op.value }
               });
             }
           }

           const updated = await prisma.team.findUnique({
             where: { id },
             include: {
               members: {
                 include: {
                   user: { select: { id: true, email: true } }
                 }
               }
             }
           });

           return toScimGroup(updated, true);
         }

         // DELETE /scim/v2/Groups/:id - Archive group
         async delete(id: string) {
           const team = await prisma.team.findUnique({
             where: { id }
           });

           if (!team) {
             return false;
           }

           // Archive instead of hard delete (per user decision)
           await prisma.team.update({
             where: { id },
             data: {
               isActive: false,
               archivedAt: new Date()
             }
           });

           await auditService.log({
             action: 'team.archived',
             teamId: team.id,
             metadata: { source: 'scim' }
           });

           return true;
         }
       }

       export const scimGroupService = new ScimGroupService();
       ```

    2. Create src/auth/scim/routes.ts:
       ```typescript
       import { Router } from 'express';
       import { scimAuth } from '../../middleware/scimAuth';
       import { scimUserService } from './users';
       import { scimGroupService } from './groups';
       import { SCIM_SCHEMAS } from './schemas';

       export const scimRouter = Router();

       // Apply SCIM authentication to all routes
       scimRouter.use(scimAuth);

       // SCIM error helper
       function scimError(res: any, status: number, detail: string) {
         return res.status(status).json({
           schemas: [SCIM_SCHEMAS.ERROR],
           status: String(status),
           detail
         });
       }

       // ============ USERS ============

       // GET /scim/v2/Users
       scimRouter.get('/Users', async (req, res) => {
         try {
           const result = await scimUserService.list({
             filter: req.query.filter as string,
             startIndex: parseInt(req.query.startIndex as string) || 1,
             count: parseInt(req.query.count as string) || 100
           });
           res.json(result);
         } catch (error) {
           scimError(res, 500, 'Internal server error');
         }
       });

       // GET /scim/v2/Users/:id
       scimRouter.get('/Users/:id', async (req, res) => {
         try {
           const user = await scimUserService.get(req.params.id);
           if (!user) {
             return scimError(res, 404, 'User not found');
           }
           res.json(user);
         } catch (error) {
           scimError(res, 500, 'Internal server error');
         }
       });

       // POST /scim/v2/Users
       scimRouter.post('/Users', async (req, res) => {
         try {
           const { user, created } = await scimUserService.create(req.body);
           res.status(created ? 201 : 200).json(user);
         } catch (error) {
           if (error.name === 'ZodError') {
             return scimError(res, 400, 'Invalid user data');
           }
           scimError(res, 500, 'Internal server error');
         }
       });

       // PUT /scim/v2/Users/:id
       scimRouter.put('/Users/:id', async (req, res) => {
         try {
           const user = await scimUserService.update(req.params.id, req.body);
           if (!user) {
             return scimError(res, 404, 'User not found');
           }
           res.json(user);
         } catch (error) {
           scimError(res, 500, 'Internal server error');
         }
       });

       // PATCH /scim/v2/Users/:id
       scimRouter.patch('/Users/:id', async (req, res) => {
         try {
           const user = await scimUserService.patch(req.params.id, req.body.Operations);
           if (!user) {
             return scimError(res, 404, 'User not found');
           }
           res.json(user);
         } catch (error) {
           scimError(res, 500, 'Internal server error');
         }
       });

       // ============ GROUPS ============

       // GET /scim/v2/Groups
       scimRouter.get('/Groups', async (req, res) => {
         try {
           const result = await scimGroupService.list({
             filter: req.query.filter as string,
             startIndex: parseInt(req.query.startIndex as string) || 1,
             count: parseInt(req.query.count as string) || 100
           });
           res.json(result);
         } catch (error) {
           scimError(res, 500, 'Internal server error');
         }
       });

       // GET /scim/v2/Groups/:id
       scimRouter.get('/Groups/:id', async (req, res) => {
         try {
           const group = await scimGroupService.get(req.params.id);
           if (!group) {
             return scimError(res, 404, 'Group not found');
           }
           res.json(group);
         } catch (error) {
           scimError(res, 500, 'Internal server error');
         }
       });

       // POST /scim/v2/Groups
       scimRouter.post('/Groups', async (req, res) => {
         try {
           const { team, created } = await scimGroupService.create(req.body);
           res.status(created ? 201 : 200).json(team);
         } catch (error) {
           if (error.name === 'ZodError') {
             return scimError(res, 400, 'Invalid group data');
           }
           scimError(res, 500, 'Internal server error');
         }
       });

       // PATCH /scim/v2/Groups/:id
       scimRouter.patch('/Groups/:id', async (req, res) => {
         try {
           const group = await scimGroupService.patch(req.params.id, req.body.Operations);
           if (!group) {
             return scimError(res, 404, 'Group not found');
           }
           res.json(group);
         } catch (error) {
           scimError(res, 500, 'Internal server error');
         }
       });

       // DELETE /scim/v2/Groups/:id
       scimRouter.delete('/Groups/:id', async (req, res) => {
         try {
           const deleted = await scimGroupService.delete(req.params.id);
           if (!deleted) {
             return scimError(res, 404, 'Group not found');
           }
           res.status(204).send();
         } catch (error) {
           scimError(res, 500, 'Internal server error');
         }
       });
       ```

    3. Update src/index.ts to mount SCIM router:
       ```typescript
       import { scimRouter } from './auth/scim/routes';

       // Mount SCIM router (before general API routes)
       app.use('/scim/v2', scimRouter);
       ```
  </action>
  <verify>
    npx tsc --noEmit passes
    GET /scim/v2/Users returns 401 without auth header
    GET /scim/v2/Users with valid Bearer token returns list response
  </verify>
  <done>
    Full SCIM 2.0 implementation: /Users and /Groups endpoints with auth, soft delete, and team sync
  </done>
</task>

</tasks>

<verification>
1. GET /scim/v2/Users with Bearer token returns SCIM list response
2. Break-glass accounts NOT returned in /scim/v2/Users (per user decision)
3. POST /scim/v2/Users creates user with syncedFromOkta: true
4. PATCH /scim/v2/Users/:id with active: false soft-deletes user
5. POST /scim/v2/Groups creates team with syncedFromOkta: true
6. PATCH /scim/v2/Groups/:id handles member add/remove
7. DELETE /scim/v2/Groups/:id archives team (not hard delete)
</verification>

<success_criteria>
- SCIM bearer token authentication protects all endpoints
- Users/Groups endpoints follow RFC 7644
- Break-glass accounts excluded from SCIM (per user decision)
- Soft delete on user deactivation (per user decision)
- Teams sync from Okta groups with syncedFromOkta flag
- All provisioning actions logged to audit trail
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-06-SUMMARY.md`
</output>

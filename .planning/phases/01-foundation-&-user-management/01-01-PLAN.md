---
phase: 01-foundation-&-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - prisma/schema.prisma
  - src/index.ts
  - src/config/database.ts
  - src/config/env.ts
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Project builds without errors"
    - "Database connection established"
    - "Core models exist in schema"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies"
      contains: "prisma"
    - path: "prisma/schema.prisma"
      provides: "Database schema"
      contains: "model User"
    - path: "src/index.ts"
      provides: "Application entry point"
      min_lines: 20
  key_links:
    - from: "src/index.ts"
      to: "prisma"
      via: "PrismaClient initialization"
      pattern: "new PrismaClient"
---

<objective>
Initialize the Node.js/Express/TypeScript project with Prisma ORM and create the complete database schema for Phase 1.

Purpose: Establishes the foundation all other plans depend on - without this, no code can be written.
Output: Working project skeleton with database schema ready for migration.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-&-user-management/01-CONTEXT.md
@.planning/phases/01-foundation-&-user-management/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Node.js project with TypeScript and dependencies</name>
  <files>
    package.json
    tsconfig.json
    .env.example
    src/config/env.ts
  </files>
  <action>
    Initialize npm project and install dependencies:

    1. Create package.json with:
       - name: "oncall-platform"
       - type: "module" (ES modules)
       - scripts: dev, build, start, db:push, db:generate, lint

    2. Install production dependencies:
       - express, @types/express
       - @prisma/client
       - passport, passport-openidconnect, passport-local, @types/passport
       - express-session, connect-pg-simple, @types/express-session
       - zod (validation)
       - helmet (security headers)
       - bcrypt, @types/bcrypt
       - rate-limiter-flexible
       - pino, pino-http (logging)
       - dotenv

    3. Install dev dependencies:
       - typescript, tsx, @types/node
       - prisma
       - eslint, @typescript-eslint/parser, @typescript-eslint/eslint-plugin

    4. Create tsconfig.json:
       - target: ES2022
       - module: NodeNext
       - moduleResolution: NodeNext
       - strict: true
       - outDir: dist
       - rootDir: src

    5. Create .env.example with placeholders:
       - DATABASE_URL
       - OKTA_DOMAIN, OKTA_CLIENT_ID, OKTA_CLIENT_SECRET, OKTA_ISSUER
       - SCIM_BEARER_TOKEN
       - OKTA_WEBHOOK_SECRET
       - SESSION_SECRET
       - JWT_SECRET (for mobile refresh tokens)
       - NODE_ENV

    6. Create src/config/env.ts:
       - Use zod to validate and export typed environment variables
       - Fail fast if required vars missing
  </action>
  <verify>
    npm install completes without errors
    npx tsc --noEmit passes
  </verify>
  <done>
    package.json exists with all dependencies, tsconfig.json configured, env validation ready
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Prisma schema with all Phase 1 models</name>
  <files>
    prisma/schema.prisma
    src/config/database.ts
    src/index.ts
  </files>
  <action>
    Create comprehensive Prisma schema per RESEARCH.md patterns and user decisions:

    1. prisma/schema.prisma:
       - datasource: postgresql
       - generator: prisma-client-js

       Models (ALL timestamps use @db.Timestamptz for UTC storage):

       **User model:**
       - id: String @id @default(cuid())
       - oktaId: String? @unique (null for break-glass accounts)
       - email: String @unique
       - firstName: String
       - lastName: String
       - phone: String?
       - isActive: Boolean @default(true)
       - isBreakGlassAccount: Boolean @default(false)
       - passwordHash: String? (only for break-glass)
       - platformRole: PlatformRole @default(USER)
       - emailVerified: Boolean @default(false)
       - phoneVerified: Boolean @default(false)
       - pushEnabled: Boolean @default(false)
       - syncedFromOkta: Boolean @default(false)
       - deactivatedAt: DateTime? @db.Timestamptz
       - createdAt: DateTime @default(now()) @db.Timestamptz
       - updatedAt: DateTime @updatedAt @db.Timestamptz
       - Relations: teamMembers, auditEvents, notificationPreferences, contactVerifications, refreshTokens, devices

       **enum PlatformRole:** PLATFORM_ADMIN, USER
       **enum TeamRole:** TEAM_ADMIN, RESPONDER, OBSERVER

       **Team model:**
       - id, name, description
       - isActive: Boolean @default(true)
       - syncedFromOkta: Boolean @default(false)
       - oktaGroupId: String? @unique
       - slackChannel: String?
       - notificationDefaults: Json?
       - escalationDefaults: Json?
       - maintenanceMode: Boolean @default(false)
       - archivedAt: DateTime? @db.Timestamptz
       - createdAt, updatedAt (Timestamptz)
       - Relations: members, tags, auditEvents

       **TeamMember model (join table):**
       - id, userId, teamId, role: TeamRole
       - joinedAt: DateTime @default(now()) @db.Timestamptz
       - @@unique([userId, teamId])

       **TeamTag model:**
       - id, teamId, tagType: TagType, tagValue: String
       - @@index([tagType, tagValue])

       **enum TagType:** ORGANIZATIONAL, TECHNICAL

       **NotificationPreference model:**
       - id, userId
       - channel: NotificationChannel (EMAIL, SMS, PUSH, SLACK)
       - enabled: Boolean
       - priority: Int (order of preference)
       - createdAt, updatedAt

       **enum NotificationChannel:** EMAIL, SMS, PUSH, SLACK, VOICE

       **ContactVerification model:**
       - id, userId, method (email/sms/push), value, code
       - verified: Boolean, expiresAt, verifiedAt
       - createdAt (all Timestamptz)
       - @@index([userId, method])

       **RefreshToken model (for mobile):**
       - id, userId, token (hashed), deviceInfo
       - expiresAt, lastUsedAt, createdAt (all Timestamptz)
       - @@index([userId])

       **UserDevice model:**
       - id, userId, platform (ios/android/web)
       - deviceToken: String
       - deviceName: String?
       - lastSeenAt: DateTime @db.Timestamptz
       - createdAt (Timestamptz)
       - @@unique([userId, deviceToken])

       **AuditEvent model:**
       - id: String @id @default(cuid())
       - action: String
       - userId: String?
       - teamId: String?
       - resourceType: String?
       - resourceId: String?
       - metadata: Json
       - ipAddress: String?
       - userAgent: String?
       - severity: String (INFO, WARN, HIGH)
       - timestamp: DateTime @default(now()) @db.Timestamptz
       - @@index([userId, timestamp])
       - @@index([teamId, timestamp])
       - @@index([action, timestamp])
       - @@index([timestamp])

       **Session model (for connect-pg-simple):**
       - sid: String @id
       - sess: Json
       - expire: DateTime @db.Timestamptz
       - @@index([expire])

    2. src/config/database.ts:
       - Export PrismaClient singleton
       - Add disconnect handler for graceful shutdown

    3. src/index.ts:
       - Basic Express app setup
       - Import and initialize Prisma
       - Helmet security headers
       - JSON body parser
       - Health check endpoint GET /health
       - Graceful shutdown handling
  </action>
  <verify>
    npx prisma validate passes
    npx prisma generate succeeds
    npm run build compiles without errors
  </verify>
  <done>
    Complete database schema defined with all models, enums, indexes, and relations per user decisions
  </done>
</task>

<task type="auto">
  <name>Task 3: Set up database and verify connection</name>
  <files>
    .env (local only, not committed)
  </files>
  <action>
    1. Create local .env file from .env.example (use placeholder values for Okta, real DATABASE_URL)

    2. If PostgreSQL not running locally, provide docker-compose.yml for local dev:
       ```yaml
       services:
         postgres:
           image: postgres:16
           environment:
             POSTGRES_USER: oncall
             POSTGRES_PASSWORD: oncall
             POSTGRES_DB: oncall
           ports:
             - "5432:5432"
           volumes:
             - pgdata:/var/lib/postgresql/data
       volumes:
         pgdata:
       ```

    3. Run database setup:
       - npx prisma db push (creates tables)
       - npx prisma generate (generates client)

    4. Start dev server and verify:
       - npm run dev
       - curl localhost:3000/health returns 200
  </action>
  <verify>
    npx prisma db push succeeds
    curl http://localhost:3000/health returns {"status":"ok"}
  </verify>
  <done>
    Database tables created, Prisma client generated, Express server running with health check
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `npx prisma validate` passes
3. `npx prisma db push` creates all tables
4. `curl http://localhost:3000/health` returns 200
5. All models defined in schema match user decisions (soft delete, UTC timestamps, two-level RBAC)
</verification>

<success_criteria>
- Project compiles and runs
- Database schema includes all Phase 1 entities
- Health endpoint responds
- No TypeScript or Prisma errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-&-user-management/01-01-SUMMARY.md`
</output>

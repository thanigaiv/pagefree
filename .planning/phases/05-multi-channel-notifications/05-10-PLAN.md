---
phase: 05-multi-channel-notifications
plan: 10
type: execute
wave: 3
depends_on: [05-06, 05-07, 05-08]
files_modified:
  - src/services/notification/failover.service.ts
autonomous: true
user_setup:
  - service: aws_sns_sms
    why: "AWS SNS SMS as failover for Twilio"
    env_vars:
      - name: AWS_SNS_SMS_SENDER_ID
        source: "AWS Console -> SNS -> Text messaging (SMS) -> Default sender ID"
    dashboard_config:
      - task: "Request SMS spending quota increase if needed"
        location: "AWS Console -> SNS -> Text messaging -> Spending quota"
      - task: "Set default SMS type to Transactional"
        location: "AWS Console -> SNS -> Text messaging -> Account default message type"

must_haves:
  truths:
    - "System fails over from Twilio to AWS SNS for SMS"
    - "System fails over from Twilio to AWS SNS for voice (if implemented)"
    - "Failover is automatic on provider failure"
    - "Provider health is monitored"
  artifacts:
    - path: "src/services/notification/failover.service.ts"
      provides: "Multi-provider failover logic for SMS/voice"
      exports: ["FailoverService", "sendSMSWithFailover", "sendVoiceWithFailover"]
  key_links:
    - from: "failover.service.ts"
      to: "Twilio and AWS SNS"
      via: "provider health check and fallback"
      pattern: "(twilioClient|snsClient)"
---

<objective>
Multi-provider failover for SMS and voice notifications

Purpose: Implement NOTIF-07 (multi-provider failover). Twilio is primary for SMS/voice, AWS SNS is fallback. System automatically switches to SNS when Twilio is unavailable or fails, ensuring notifications always reach users.

Output: FailoverService with automatic provider switching based on health and failure detection
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@.planning/phases/05-multi-channel-notifications/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AWS SNS SMS env configuration</name>
  <files>src/config/env.ts</files>
  <action>
Add AWS SNS SMS configuration to `src/config/env.ts`:
```typescript
// Add to existing env object:
export const env = {
  // ... existing env vars ...

  // AWS SNS SMS failover configuration
  AWS_SNS_SMS_SENDER_ID: process.env.AWS_SNS_SMS_SENDER_ID || 'OnCall',
};
```
  </action>
  <verify>grep -q "AWS_SNS_SMS_SENDER_ID" src/config/env.ts</verify>
  <done>AWS SNS SMS sender ID configured</done>
</task>

<task type="auto">
  <name>Task 2: Create failover service with provider health monitoring</name>
  <files>src/services/notification/failover.service.ts</files>
  <action>
Create `src/services/notification/failover.service.ts`:
```typescript
import twilio from 'twilio';
import { SNSClient, PublishCommand } from '@aws-sdk/client-sns';
import { env } from '../../config/env.js';
import { logger } from '../../config/logger.js';
import type { ChannelDeliveryResult } from './types.js';

// Provider status tracking
interface ProviderStatus {
  healthy: boolean;
  lastCheck: Date;
  consecutiveFailures: number;
  circuitOpen: boolean;
  circuitOpenUntil?: Date;
}

// Circuit breaker configuration
const CIRCUIT_CONFIG = {
  failureThreshold: 3,       // Open circuit after 3 consecutive failures
  resetTimeoutMs: 60000,     // Try primary again after 1 minute
  healthCheckIntervalMs: 30000  // Check health every 30 seconds
};

class FailoverService {
  private twilioClient: ReturnType<typeof twilio>;
  private snsClient: SNSClient;

  // Provider health status
  private providerStatus: {
    twilio: ProviderStatus;
    sns: ProviderStatus;
  };

  constructor() {
    this.twilioClient = twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);

    const snsConfig: any = { region: env.AWS_REGION };
    if (env.AWS_ACCESS_KEY_ID && env.AWS_SECRET_ACCESS_KEY) {
      snsConfig.credentials = {
        accessKeyId: env.AWS_ACCESS_KEY_ID,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY
      };
    }
    this.snsClient = new SNSClient(snsConfig);

    // Initialize provider status
    this.providerStatus = {
      twilio: { healthy: true, lastCheck: new Date(), consecutiveFailures: 0, circuitOpen: false },
      sns: { healthy: true, lastCheck: new Date(), consecutiveFailures: 0, circuitOpen: false }
    };

    // Start background health checks
    this.startHealthChecks();
  }

  // Send SMS with automatic failover (per user decision: Twilio primary, AWS SNS fallback)
  async sendSMSWithFailover(to: string, body: string): Promise<ChannelDeliveryResult> {
    // Try Twilio first (if circuit not open)
    if (!this.isCircuitOpen('twilio')) {
      try {
        const result = await this.sendViaTwilio(to, body);
        if (result.success) {
          this.recordSuccess('twilio');
          return result;
        }
      } catch (error) {
        this.recordFailure('twilio', error);
        logger.warn({ error, provider: 'twilio' }, 'Twilio SMS failed, trying SNS failover');
      }
    } else {
      logger.info('Twilio circuit open, using SNS failover');
    }

    // Failover to AWS SNS
    if (!this.isCircuitOpen('sns')) {
      try {
        const result = await this.sendViaSNS(to, body);
        if (result.success) {
          this.recordSuccess('sns');
          return { ...result, providerId: `sns:${result.providerId}` };
        }
      } catch (error) {
        this.recordFailure('sns', error);
        logger.error({ error, provider: 'sns' }, 'SNS SMS failover also failed');
      }
    }

    // Both providers failed
    return {
      success: false,
      error: 'All SMS providers failed (Twilio and AWS SNS)'
    };
  }

  // Send via Twilio
  private async sendViaTwilio(to: string, body: string): Promise<ChannelDeliveryResult> {
    const message = await this.twilioClient.messages.create({
      from: env.TWILIO_PHONE_NUMBER,
      to,
      body,
      statusCallback: `${env.API_BASE_URL}/webhooks/twilio/sms/status`
    });

    return {
      success: true,
      providerId: message.sid,
      deliveredAt: new Date()
    };
  }

  // Send via AWS SNS
  private async sendViaSNS(to: string, body: string): Promise<ChannelDeliveryResult> {
    // SNS requires E.164 format
    const e164Phone = to.startsWith('+') ? to : `+${to}`;

    const result = await this.snsClient.send(new PublishCommand({
      PhoneNumber: e164Phone,
      Message: body,
      MessageAttributes: {
        'AWS.SNS.SMS.SMSType': {
          DataType: 'String',
          StringValue: 'Transactional'  // High deliverability
        },
        'AWS.SNS.SMS.SenderID': {
          DataType: 'String',
          StringValue: env.AWS_SNS_SMS_SENDER_ID
        }
      }
    }));

    return {
      success: true,
      providerId: result.MessageId,
      deliveredAt: new Date()
    };
  }

  // Check if circuit breaker is open for provider
  private isCircuitOpen(provider: 'twilio' | 'sns'): boolean {
    const status = this.providerStatus[provider];

    if (!status.circuitOpen) {
      return false;
    }

    // Check if reset timeout has passed
    if (status.circuitOpenUntil && new Date() > status.circuitOpenUntil) {
      // Half-open: allow one request to test
      logger.info({ provider }, 'Circuit breaker half-open, testing provider');
      return false;
    }

    return true;
  }

  // Record successful request
  private recordSuccess(provider: 'twilio' | 'sns'): void {
    const status = this.providerStatus[provider];
    status.healthy = true;
    status.consecutiveFailures = 0;
    status.circuitOpen = false;
    status.circuitOpenUntil = undefined;
  }

  // Record failed request
  private recordFailure(provider: 'twilio' | 'sns', error: unknown): void {
    const status = this.providerStatus[provider];
    status.consecutiveFailures++;

    if (status.consecutiveFailures >= CIRCUIT_CONFIG.failureThreshold) {
      status.circuitOpen = true;
      status.circuitOpenUntil = new Date(Date.now() + CIRCUIT_CONFIG.resetTimeoutMs);
      status.healthy = false;

      logger.warn(
        { provider, failures: status.consecutiveFailures, resetAt: status.circuitOpenUntil },
        'Circuit breaker opened due to consecutive failures'
      );
    }
  }

  // Background health checks
  private startHealthChecks(): void {
    setInterval(async () => {
      await this.checkTwilioHealth();
      await this.checkSNSHealth();
    }, CIRCUIT_CONFIG.healthCheckIntervalMs);
  }

  private async checkTwilioHealth(): Promise<void> {
    try {
      // Simple API call to check connectivity
      await this.twilioClient.api.accounts(env.TWILIO_ACCOUNT_SID).fetch();
      this.providerStatus.twilio.healthy = true;
      this.providerStatus.twilio.lastCheck = new Date();
    } catch (error) {
      logger.warn({ error }, 'Twilio health check failed');
      this.providerStatus.twilio.healthy = false;
    }
  }

  private async checkSNSHealth(): Promise<void> {
    try {
      // SNS doesn't have a simple ping endpoint, so we just check client config
      // A failed send will trigger circuit breaker
      this.providerStatus.sns.lastCheck = new Date();
    } catch (error) {
      logger.warn({ error }, 'SNS health check failed');
    }
  }

  // Get current provider status (for monitoring)
  getProviderStatus(): typeof this.providerStatus {
    return this.providerStatus;
  }
}

// Singleton instance
export const failoverService = new FailoverService();

// Convenience functions
export const sendSMSWithFailover = failoverService.sendSMSWithFailover.bind(failoverService);
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/failover.service.ts</verify>
  <done>FailoverService with circuit breaker pattern for Twilio to SNS failover</done>
</task>

<task type="auto">
  <name>Task 3: Update SMS channel to use failover service</name>
  <files>src/services/notification/channels/sms.channel.ts</files>
  <action>
Update `src/services/notification/channels/sms.channel.ts` to use the failover service instead of direct Twilio calls.

Replace the send method implementation to use failover:

```typescript
import { sendSMSWithFailover } from '../failover.service.js';

// In the send method, replace direct Twilio call with:
async send(payload: NotificationPayload): Promise<ChannelDeliveryResult> {
  return this.withErrorHandling(async () => {
    // Get user phone
    const user = await prisma.user.findUnique({
      where: { id: payload.userId },
      select: { phone: true, phoneVerified: true }
    });

    if (!user?.phone) {
      return { success: false, error: 'User phone not found' };
    }

    if (!user.phoneVerified) {
      return { success: false, error: 'User phone not verified' };
    }

    // Build SMS message (160 char limit per user decision)
    const body = this.buildSMSMessage(payload);

    // Use failover service (Twilio primary, SNS fallback)
    const result = await sendSMSWithFailover(user.phone, body);

    if (result.success) {
      logger.info(
        { channel: 'sms', incidentId: payload.incidentId, userId: payload.userId, providerId: result.providerId },
        'SMS notification sent'
      );
    }

    return result;
  }, { incidentId: payload.incidentId, userId: payload.userId });
}
```

Add the import at the top and update the send method to use `sendSMSWithFailover`.
  </action>
  <verify>grep -q "sendSMSWithFailover" src/services/notification/channels/sms.channel.ts</verify>
  <done>SMS channel uses failover service for automatic provider switching</done>
</task>

</tasks>

<verification>
- Failover service compiles without errors
- Circuit breaker opens after 3 consecutive failures
- Circuit breaker resets after 1 minute timeout
- SMS channel uses failover service
- Provider health status is tracked
- TypeScript compiles without errors
</verification>

<success_criteria>
1. Twilio is primary SMS provider
2. AWS SNS is automatic fallback when Twilio fails
3. Circuit breaker prevents hammering failed provider (per user discretion)
4. Provider health monitored with periodic checks
5. Failover is transparent to calling code
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-10-SUMMARY.md`
</output>

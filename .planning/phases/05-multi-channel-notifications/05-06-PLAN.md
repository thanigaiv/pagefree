---
phase: 05-multi-channel-notifications
plan: 06
type: execute
wave: 2
depends_on: [05-01, 05-02, 05-03, 05-04, 05-05]
files_modified:
  - src/services/notification/dispatcher.ts
  - src/services/notification/delivery-tracker.ts
  - src/workers/notification.worker.ts
autonomous: true

must_haves:
  truths:
    - "System implements at-least-once delivery with exponential backoff"
    - "System tracks delivery status asynchronously per channel"
    - "System retries only failed channels (not all channels)"
    - "System uses hybrid parallel/sequential delivery strategy"
  artifacts:
    - path: "src/services/notification/dispatcher.ts"
      provides: "Main notification orchestrator with channel fanout"
      exports: ["NotificationDispatcher", "dispatchNotification"]
    - path: "src/services/notification/delivery-tracker.ts"
      provides: "Async delivery status tracking"
      exports: ["DeliveryTracker", "updateDeliveryStatus"]
    - path: "src/workers/notification.worker.ts"
      provides: "BullMQ worker processing notification jobs"
      exports: ["startNotificationWorker"]
  key_links:
    - from: "dispatcher.ts"
      to: "notification.queue.ts"
      via: "notificationQueue.add"
      pattern: "notificationQueue.*add"
    - from: "notification.worker.ts"
      to: "channel implementations"
      via: "channel.send"
      pattern: "channel\\.send"
---

<objective>
Notification dispatcher and delivery tracking with at-least-once guarantee

Purpose: Implement NOTIF-09 (at-least-once delivery) and NOTIF-08 (delivery tracking). The dispatcher enqueues per-channel jobs with BullMQ's exponential backoff. Per user decision: 5 attempts over 10 minutes, retry only failed channels, hybrid parallel/sequential delivery.

Output: NotificationDispatcher service, DeliveryTracker service, BullMQ notification worker
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@.planning/phases/05-multi-channel-notifications/05-RESEARCH.md
@src/queues/notification.queue.ts
@src/workers/escalation.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create delivery tracker service</name>
  <files>src/services/notification/delivery-tracker.ts</files>
  <action>
Create `src/services/notification/delivery-tracker.ts`:
```typescript
import { prisma } from '../../config/database.js';
import { auditService } from '../audit.service.js';
import { logger } from '../../config/logger.js';
import type { DeliveryStatus } from './types.js';

interface DeliveryUpdate {
  incidentId: string;
  userId: string;
  channel: string;
  status: DeliveryStatus;
  providerId?: string;
  error?: string;
}

class DeliveryTracker {
  // Create initial notification log entry when job is queued
  async trackQueued(
    incidentId: string,
    userId: string,
    channel: string,
    escalationLevel?: number
  ): Promise<string> {
    const log = await prisma.notificationLog.create({
      data: {
        incidentId,
        userId,
        channel: channel.toUpperCase() as any,
        status: 'QUEUED',
        escalationLevel,
        queuedAt: new Date()
      }
    });

    return log.id;
  }

  // Update status to SENDING when worker picks up job
  async trackSending(logId: string): Promise<void> {
    await prisma.notificationLog.update({
      where: { id: logId },
      data: {
        status: 'SENDING',
        lastAttemptAt: new Date(),
        attemptCount: { increment: 1 }
      }
    });
  }

  // Update status to SENT when provider accepts message
  async trackSent(logId: string, providerId: string): Promise<void> {
    await prisma.notificationLog.update({
      where: { id: logId },
      data: {
        status: 'SENT',
        providerId,
        sentAt: new Date()
      }
    });
  }

  // Update status to DELIVERED when we confirm end-user receipt
  // (typically via provider webhook callback)
  async trackDelivered(logId: string): Promise<void> {
    await prisma.notificationLog.update({
      where: { id: logId },
      data: {
        status: 'DELIVERED',
        deliveredAt: new Date()
      }
    });
  }

  // Update status to FAILED after all retries exhausted
  async trackFailed(logId: string, error: string): Promise<void> {
    const log = await prisma.notificationLog.update({
      where: { id: logId },
      data: {
        status: 'FAILED',
        error,
        lastAttemptAt: new Date()
      },
      include: {
        incident: { select: { teamId: true } }
      }
    });

    // Audit log for tracking delivery failures (important for reliability)
    await auditService.log({
      action: 'notification.failed',
      teamId: log.incident.teamId,
      resourceType: 'notification',
      resourceId: logId,
      severity: 'WARN',
      metadata: {
        channel: log.channel,
        incidentId: log.incidentId,
        userId: log.userId,
        error,
        attemptCount: log.attemptCount
      }
    });

    logger.warn(
      { logId, channel: log.channel, incidentId: log.incidentId, error, attempts: log.attemptCount },
      'Notification delivery failed after all retries'
    );
  }

  // Get delivery status for an incident across all channels
  async getDeliveryStatus(incidentId: string): Promise<any[]> {
    return prisma.notificationLog.findMany({
      where: { incidentId },
      orderBy: { queuedAt: 'asc' },
      include: {
        user: { select: { id: true, firstName: true, lastName: true, email: true } }
      }
    });
  }

  // Check if critical channels succeeded (for permanent failure determination)
  // Per user decision: permanent failure = email + SMS both fail
  async checkCriticalChannelsFailed(incidentId: string, userId: string): Promise<boolean> {
    const logs = await prisma.notificationLog.findMany({
      where: {
        incidentId,
        userId,
        channel: { in: ['EMAIL', 'SMS'] },
        status: 'FAILED'
      }
    });

    // Both email AND SMS must have failed
    const channels = new Set(logs.map(l => l.channel));
    return channels.has('EMAIL') && channels.has('SMS');
  }

  // Get channels that failed for retry escalation
  async getFailedChannels(incidentId: string, userId: string): Promise<string[]> {
    const logs = await prisma.notificationLog.findMany({
      where: {
        incidentId,
        userId,
        status: 'FAILED'
      },
      select: { channel: true }
    });

    return logs.map(l => l.channel.toLowerCase());
  }

  // Update delivery status from provider webhook
  async updateFromProviderWebhook(
    providerId: string,
    channel: string,
    delivered: boolean,
    error?: string
  ): Promise<void> {
    const log = await prisma.notificationLog.findFirst({
      where: {
        providerId,
        channel: channel.toUpperCase() as any
      }
    });

    if (!log) {
      logger.warn({ providerId, channel }, 'No notification log found for provider webhook');
      return;
    }

    if (delivered) {
      await this.trackDelivered(log.id);
    } else if (error) {
      await prisma.notificationLog.update({
        where: { id: log.id },
        data: {
          status: 'FAILED',
          error,
          lastAttemptAt: new Date()
        }
      });
    }
  }
}

export const deliveryTracker = new DeliveryTracker();
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/delivery-tracker.ts</verify>
  <done>DeliveryTracker tracks notification status through QUEUED -> SENDING -> SENT -> DELIVERED/FAILED</done>
</task>

<task type="auto">
  <name>Task 2: Create notification dispatcher with channel fanout</name>
  <files>src/services/notification/dispatcher.ts</files>
  <action>
Create `src/services/notification/dispatcher.ts`:
```typescript
import { prisma } from '../../config/database.js';
import { notificationQueue, type NotificationJobData } from '../../queues/notification.queue.js';
import { deliveryTracker } from './delivery-tracker.js';
import { auditService } from '../audit.service.js';
import { logger } from '../../config/logger.js';
import type { NotificationPayload, ChannelEscalationConfig, DEFAULT_CHANNEL_ESCALATION } from './types.js';

// Per user decision: Hybrid parallel/sequential delivery
// Primary (push, email, slack) = parallel
// Secondary (sms) = if primary fails
// Fallback (voice) = if secondary fails
const CHANNEL_TIERS: ChannelEscalationConfig = {
  primary: ['email', 'slack', 'push'],
  secondary: ['sms'],
  fallback: ['voice']
};

// Per user decision: 5 attempts over 10 minutes with exponential backoff
// 30s, 1m, 2m, 4m, ~3m = total ~10 minutes
const RETRY_CONFIG = {
  attempts: 5,
  backoff: {
    type: 'exponential' as const,
    delay: 30000  // 30 seconds base
  }
};

interface DispatchOptions {
  escalationLevel?: number;
  channelsOverride?: string[];  // Force specific channels
  skipTiers?: boolean;          // Send all enabled channels at once
}

class NotificationDispatcher {
  // Dispatch notification for incident to user
  async dispatch(
    incidentId: string,
    userId: string,
    type: 'new_incident' | 'escalation' | 'acknowledgment' | 'resolution',
    options: DispatchOptions = {}
  ): Promise<{ queued: number; channels: string[] }> {
    // Get incident and user data
    const [incident, user] = await Promise.all([
      prisma.incident.findUnique({
        where: { id: incidentId },
        include: {
          team: { select: { id: true, name: true, slackChannel: true } },
          alerts: { take: 1, orderBy: { triggeredAt: 'desc' } }
        }
      }),
      prisma.user.findUnique({
        where: { id: userId },
        include: {
          notificationPreferences: { where: { enabled: true }, orderBy: { priority: 'asc' } },
          slackConnection: { select: { isActive: true } },
          teamsConnection: { select: { isActive: true } }
        }
      })
    ]);

    if (!incident || !user) {
      throw new Error(`Incident or user not found: ${incidentId}, ${userId}`);
    }

    // Determine which channels to use
    let channels: string[];

    if (options.channelsOverride) {
      channels = options.channelsOverride;
    } else {
      // Get user's enabled channels from preferences
      channels = user.notificationPreferences.map(p => p.channel.toLowerCase());

      // Filter out channels user doesn't have configured
      channels = channels.filter(c => {
        if (c === 'slack' && !user.slackConnection?.isActive) return false;
        if (c === 'teams' && !user.teamsConnection?.isActive) return false;
        if (c === 'sms' && !user.phone) return false;
        if (c === 'voice' && !user.phone) return false;
        return true;
      });
    }

    if (channels.length === 0) {
      logger.warn({ incidentId, userId }, 'No notification channels available for user');
      return { queued: 0, channels: [] };
    }

    // Build payload
    const dashboardUrl = process.env.DASHBOARD_URL || 'http://localhost:3000';
    const payload: NotificationPayload = {
      incidentId: incident.id,
      userId: user.id,
      title: incident.alerts[0]?.title || `Incident #${incident.id.slice(-8)}`,
      body: incident.alerts[0]?.description || 'No description available',
      priority: incident.priority as any,
      service: incident.alerts[0]?.source || 'unknown',
      teamName: incident.team.name,
      alertCount: incident.alertCount,
      escalationLevel: options.escalationLevel,
      dashboardUrl,
      triggeredAt: incident.createdAt
    };

    // Determine tier for each channel
    const tierChannels = options.skipTiers ? { all: channels } : this.groupByTier(channels);

    // Queue jobs for primary tier (or all if skipTiers)
    const primaryChannels = tierChannels.all || tierChannels.primary || [];
    const queuedChannels: string[] = [];

    for (const channel of primaryChannels) {
      // Create tracking entry
      const logId = await deliveryTracker.trackQueued(
        incidentId,
        userId,
        channel,
        options.escalationLevel
      );

      // Queue job
      const jobData: NotificationJobData & { payload: NotificationPayload; logId: string; tier: string } = {
        userId,
        incidentId,
        type,
        channels: [channel],
        // Extended data for worker
        payload,
        logId,
        tier: this.getChannelTier(channel)
      };

      await notificationQueue.add(`notify-${channel}`, jobData, {
        ...RETRY_CONFIG,
        priority: incident.priority === 'CRITICAL' ? 1 : 10
      });

      queuedChannels.push(channel);
    }

    // Audit log
    await auditService.log({
      action: 'notification.dispatched',
      userId,
      teamId: incident.team.id,
      resourceType: 'incident',
      resourceId: incidentId,
      severity: 'INFO',
      metadata: {
        type,
        channels: queuedChannels,
        escalationLevel: options.escalationLevel
      }
    });

    logger.info(
      { incidentId, userId, type, channels: queuedChannels, escalationLevel: options.escalationLevel },
      'Notifications dispatched'
    );

    return { queued: queuedChannels.length, channels: queuedChannels };
  }

  // Group channels by tier for escalation
  private groupByTier(channels: string[]): { primary?: string[]; secondary?: string[]; fallback?: string[] } {
    return {
      primary: channels.filter(c => CHANNEL_TIERS.primary.includes(c)),
      secondary: channels.filter(c => CHANNEL_TIERS.secondary.includes(c)),
      fallback: channels.filter(c => CHANNEL_TIERS.fallback.includes(c))
    };
  }

  // Get tier for a channel
  private getChannelTier(channel: string): 'primary' | 'secondary' | 'fallback' {
    if (CHANNEL_TIERS.primary.includes(channel)) return 'primary';
    if (CHANNEL_TIERS.secondary.includes(channel)) return 'secondary';
    return 'fallback';
  }

  // Escalate to next tier of channels (called when primary fails)
  async escalateToNextTier(
    incidentId: string,
    userId: string,
    failedTier: 'primary' | 'secondary',
    payload: NotificationPayload
  ): Promise<void> {
    const nextTier = failedTier === 'primary' ? 'secondary' : 'fallback';
    const nextChannels = nextTier === 'secondary' ? CHANNEL_TIERS.secondary : CHANNEL_TIERS.fallback;

    // Get user's enabled channels in next tier
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        notificationPreferences: { where: { enabled: true } }
      }
    });

    if (!user) return;

    const userChannels = user.notificationPreferences.map(p => p.channel.toLowerCase());
    const channelsToTry = nextChannels.filter(c => userChannels.includes(c));

    if (channelsToTry.length === 0) {
      logger.warn({ incidentId, userId, failedTier }, 'No channels available in next tier');
      return;
    }

    logger.info(
      { incidentId, userId, failedTier, nextTier, channels: channelsToTry },
      'Escalating to next notification tier'
    );

    // Queue jobs for next tier
    for (const channel of channelsToTry) {
      const logId = await deliveryTracker.trackQueued(
        incidentId,
        userId,
        channel,
        payload.escalationLevel
      );

      await notificationQueue.add(`notify-${channel}`, {
        userId,
        incidentId,
        type: 'escalation',
        channels: [channel],
        payload,
        logId,
        tier: nextTier
      }, RETRY_CONFIG);
    }
  }
}

export const notificationDispatcher = new NotificationDispatcher();
export const dispatchNotification = notificationDispatcher.dispatch.bind(notificationDispatcher);
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/dispatcher.ts</verify>
  <done>NotificationDispatcher fans out to channels with tier-based escalation</done>
</task>

<task type="auto">
  <name>Task 3: Create notification worker with channel routing</name>
  <files>src/workers/notification.worker.ts</files>
  <action>
Create `src/workers/notification.worker.ts`:
```typescript
import { Worker, Job } from 'bullmq';
import { getRedisConnectionOptions } from '../config/redis.js';
import { deliveryTracker } from '../services/notification/delivery-tracker.js';
import { notificationDispatcher } from '../services/notification/dispatcher.js';
import { logger } from '../config/logger.js';
import type { NotificationPayload } from '../services/notification/types.js';

// Import channel implementations
import { emailChannel } from '../services/notification/channels/email.channel.js';
import { smsChannel } from '../services/notification/channels/sms.channel.js';
import { slackChannel } from '../services/notification/channels/slack.channel.js';
import { teamsChannel } from '../services/notification/channels/teams.channel.js';
import { pushChannel } from '../services/notification/channels/push.channel.js';
import { voiceChannel } from '../services/notification/channels/voice.channel.js';

// Channel registry
const channels: Record<string, any> = {
  email: emailChannel,
  sms: smsChannel,
  slack: slackChannel,
  teams: teamsChannel,
  push: pushChannel,
  voice: voiceChannel
};

interface NotificationJobExtended {
  userId: string;
  incidentId: string;
  type: string;
  channels: string[];
  payload: NotificationPayload;
  logId: string;
  tier: 'primary' | 'secondary' | 'fallback';
}

let worker: Worker | null = null;

export async function startNotificationWorker(): Promise<void> {
  worker = new Worker<NotificationJobExtended>(
    'notification',
    async (job: Job<NotificationJobExtended>) => {
      const { payload, logId, tier } = job.data;
      const channel = job.data.channels[0];  // Each job handles one channel

      logger.info(
        { jobId: job.id, channel, incidentId: payload.incidentId, attempt: job.attemptsMade + 1 },
        'Processing notification job'
      );

      // Update status to SENDING
      await deliveryTracker.trackSending(logId);

      // Get channel implementation
      const channelImpl = channels[channel];
      if (!channelImpl) {
        throw new Error(`Unknown channel: ${channel}`);
      }

      // Send notification
      const result = await channelImpl.send(payload);

      if (result.success) {
        // Track successful send
        await deliveryTracker.trackSent(logId, result.providerId || 'unknown');

        logger.info(
          { jobId: job.id, channel, incidentId: payload.incidentId, providerId: result.providerId },
          'Notification sent successfully'
        );

        return result;
      } else {
        // Throw to trigger retry
        throw new Error(result.error || 'Send failed');
      }
    },
    {
      connection: getRedisConnectionOptions(),
      concurrency: 10,  // Process up to 10 notifications concurrently
      limiter: {
        max: 100,       // Max 100 notifications per minute (prevent rate limiting)
        duration: 60000
      }
    }
  );

  // Handle job completion
  worker.on('completed', async (job: Job<NotificationJobExtended>) => {
    logger.debug({ jobId: job.id, channel: job.data.channels[0] }, 'Notification job completed');
  });

  // Handle job failure (after all retries)
  worker.on('failed', async (job: Job<NotificationJobExtended> | undefined, err: Error) => {
    if (!job) return;

    const { payload, logId, tier, channels } = job.data;
    const channel = channels[0];

    logger.error(
      { jobId: job.id, channel, incidentId: payload.incidentId, error: err.message, attempts: job.attemptsMade },
      'Notification job failed after all retries'
    );

    // Track permanent failure
    await deliveryTracker.trackFailed(logId, err.message);

    // Check if we should escalate to next tier
    // Per user decision: channel escalation on delivery failure
    if (tier === 'primary') {
      // Check if ALL primary channels failed for this user/incident
      const failedChannels = await deliveryTracker.getFailedChannels(payload.incidentId, payload.userId);
      const primaryChannels = ['email', 'slack', 'push'];
      const allPrimaryFailed = primaryChannels.every(c => failedChannels.includes(c) || !failedChannels.includes(c));

      // If this was the last primary channel to fail, escalate to secondary (SMS)
      if (failedChannels.filter(c => primaryChannels.includes(c)).length >= 2) {
        logger.info({ incidentId: payload.incidentId, userId: payload.userId }, 'Primary channels failed, escalating to SMS');
        await notificationDispatcher.escalateToNextTier(payload.incidentId, payload.userId, 'primary', payload);
      }
    } else if (tier === 'secondary') {
      // SMS failed, escalate to voice
      logger.info({ incidentId: payload.incidentId, userId: payload.userId }, 'SMS failed, escalating to voice');
      await notificationDispatcher.escalateToNextTier(payload.incidentId, payload.userId, 'secondary', payload);
    }

    // Check for total failure (all critical channels failed)
    // Per user decision: permanent failure when email + SMS both fail
    const criticalFailed = await deliveryTracker.checkCriticalChannelsFailed(payload.incidentId, payload.userId);
    if (criticalFailed) {
      logger.error(
        { incidentId: payload.incidentId, userId: payload.userId },
        'CRITICAL: All notification channels failed for user'
      );
      // TODO: Alert ops team (create incident for oncall-platform service)
    }
  });

  // Handle errors
  worker.on('error', (err: Error) => {
    logger.error({ error: err.message }, 'Notification worker error');
  });

  logger.info('Notification worker started');
}

export async function stopNotificationWorker(): Promise<void> {
  if (worker) {
    await worker.close();
    worker = null;
    logger.info('Notification worker stopped');
  }
}
```
  </action>
  <verify>npx tsc --noEmit src/workers/notification.worker.ts</verify>
  <done>Notification worker processes jobs with channel routing and tier escalation</done>
</task>

</tasks>

<verification>
- DeliveryTracker tracks QUEUED -> SENDING -> SENT -> DELIVERED/FAILED lifecycle
- Dispatcher fans out to primary channels in parallel
- Retry config: 5 attempts with exponential backoff (30s base)
- Channel escalation: primary fails -> secondary (SMS) -> fallback (voice)
- Critical failure detection: email + SMS both fail
- Worker processes jobs with concurrency 10 and rate limit 100/min
- TypeScript compiles without errors
</verification>

<success_criteria>
1. At-least-once delivery guarantee via BullMQ retry (NOTIF-09)
2. 5 attempts over ~10 minutes with exponential backoff (per user decision)
3. Per-channel tracking in NotificationLog (NOTIF-08)
4. Hybrid parallel/sequential: primary parallel, secondary/fallback sequential on failure
5. Channel escalation: push fails -> SMS, SMS fails -> voice (per user decision)
6. Permanent failure when email + SMS both fail (per user decision)
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-06-SUMMARY.md`
</output>

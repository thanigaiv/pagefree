---
phase: 05-multi-channel-notifications
plan: 09
type: execute
wave: 3
depends_on: [05-06, 05-07, 05-08]
files_modified:
  - src/services/notification/index.ts
  - src/services/escalation.service.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Escalation engine triggers notifications on incident creation"
    - "Escalation engine triggers notifications on escalation level change"
    - "Notification worker starts with application"
    - "All notification channels can be imported from single module"
  artifacts:
    - path: "src/services/notification/index.ts"
      provides: "Notification module exports"
      exports: ["dispatchNotification", "NotificationDispatcher"]
    - path: "src/services/escalation.service.ts"
      provides: "Updated escalation service with notification dispatch"
      contains: "dispatchNotification"
  key_links:
    - from: "escalation.service.ts"
      to: "notification/dispatcher.ts"
      via: "dispatchNotification"
      pattern: "dispatchNotification"
    - from: "src/index.ts"
      to: "notification.worker.ts"
      via: "startNotificationWorker"
      pattern: "startNotificationWorker"
---

<objective>
Integrate notification system with escalation engine and application startup

Purpose: Wire up the notification system to the existing escalation engine from Phase 4. When incidents are created or escalated, the system dispatches notifications to the assigned on-call engineer through their enabled channels.

Output: Updated escalation service, notification module exports, worker startup integration
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@src/services/escalation.service.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification module exports</name>
  <files>src/services/notification/index.ts</files>
  <action>
Create `src/services/notification/index.ts`:
```typescript
// Notification module exports
// All notification functionality can be imported from this single module

// Core types
export type {
  NotificationChannel,
  NotificationPayload,
  ChannelDeliveryResult,
  DeliveryStatus,
  ChannelEscalationConfig
} from './types.js';
export { DEFAULT_CHANNEL_ESCALATION } from './types.js';

// Dispatcher (main entry point for sending notifications)
export { notificationDispatcher, dispatchNotification } from './dispatcher.js';

// Delivery tracking
export { deliveryTracker } from './delivery-tracker.js';

// Channel implementations (for testing/direct access if needed)
export { emailChannel } from './channels/email.channel.js';
export { smsChannel } from './channels/sms.channel.js';
export { slackChannel } from './channels/slack.channel.js';
export { teamsChannel } from './channels/teams.channel.js';
export { pushChannel } from './channels/push.channel.js';
export { voiceChannel } from './channels/voice.channel.js';

// Interaction services
export { slackInteractionService } from './slack-interaction.service.js';
export { smsReplyService } from './sms-reply.service.js';

// Templates (for customization if needed)
export {
  buildIncidentEmailSubject,
  buildIncidentEmailHtml,
  buildIncidentEmailText
} from './templates/email.templates.js';
export {
  buildSlackIncidentBlocks,
  buildSlackAcknowledgedBlocks,
  buildSlackResolvedBlocks
} from './templates/slack.templates.js';
export {
  buildTeamsIncidentCard,
  buildTeamsAcknowledgedCard,
  buildTeamsResolvedCard
} from './templates/teams.templates.js';
export {
  buildIncidentCallTwiml,
  buildKeypadResponseTwiml
} from './templates/twiml.templates.js';
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/index.ts</verify>
  <done>Notification module exports all components from single entry point</done>
</task>

<task type="auto">
  <name>Task 2: Integrate notifications with escalation service</name>
  <files>src/services/escalation.service.ts</files>
  <action>
Update `src/services/escalation.service.ts` to dispatch notifications when:
1. A new incident is created (initial notification)
2. Escalation progresses to next level

Find the method that creates incidents or handles escalation and add notification dispatch.

Add import at top:
```typescript
import { dispatchNotification } from './notification/index.js';
```

In the method that handles escalation (e.g., `escalateToNextLevel` or similar):

After assigning user to incident, add:
```typescript
// Dispatch notification to assigned user
if (assignedUserId) {
  try {
    await dispatchNotification(
      incidentId,
      assignedUserId,
      escalationLevel === 1 ? 'new_incident' : 'escalation',
      { escalationLevel }
    );
  } catch (notificationError) {
    // Log but don't fail escalation - notification is best-effort
    logger.error(
      { error: notificationError, incidentId, userId: assignedUserId, escalationLevel },
      'Failed to dispatch notification'
    );
  }
}
```

Key integration points:
1. **Initial incident creation**: When incident is created and first user assigned, dispatch 'new_incident' notification
2. **Escalation timeout**: When escalation worker escalates to next level, dispatch 'escalation' notification with new level

The notification system will:
- Look up user's enabled channels
- Queue jobs for each channel
- Handle delivery with retries
- Track delivery status

Note: Be careful not to duplicate notifications. Only notify on:
- Initial assignment (level 1)
- Level change (when escalating to level 2, 3, etc.)
- Reassignment (if incident is manually reassigned)
  </action>
  <verify>grep -q "dispatchNotification" src/services/escalation.service.ts</verify>
  <done>Escalation service dispatches notifications on incident creation and escalation</done>
</task>

<task type="auto">
  <name>Task 3: Start notification worker in application</name>
  <files>src/index.ts</files>
  <action>
Update `src/index.ts` to start the notification worker alongside the escalation worker.

Add import:
```typescript
import { startNotificationWorker, stopNotificationWorker } from './workers/notification.worker.js';
```

In the worker startup section (where escalation worker is started), add:
```typescript
// Start notification worker
try {
  await startNotificationWorker();
  logger.info('Notification worker started');
} catch (error) {
  logger.error({ error }, 'Failed to start notification worker, continuing in degraded mode');
}
```

In the graceful shutdown section, add:
```typescript
// Stop notification worker
await stopNotificationWorker();
```

The startup should be after Redis is initialized but can run in parallel with escalation worker startup.

Example pattern (from escalation worker):
```typescript
// Start workers
if (process.env.NODE_ENV !== 'test') {
  try {
    await startEscalationWorker();
    await startNotificationWorker();
    logger.info('All workers started');
  } catch (workerError) {
    logger.error({ error: workerError }, 'Worker startup failed, running in degraded mode');
  }
}
```
  </action>
  <verify>grep -q "startNotificationWorker" src/index.ts</verify>
  <done>Notification worker starts with application and shuts down gracefully</done>
</task>

</tasks>

<verification>
- Notification module exports compile without errors
- Escalation service imports and calls dispatchNotification
- Application starts notification worker alongside escalation worker
- Graceful shutdown stops notification worker
- Integration doesn't break existing escalation tests
</verification>

<success_criteria>
1. All notification exports available from `src/services/notification/index.ts`
2. New incidents trigger notifications to assigned user
3. Escalation level changes trigger notifications to new assignee
4. Notification worker runs with application
5. Graceful shutdown handles notification worker
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-09-SUMMARY.md`
</output>

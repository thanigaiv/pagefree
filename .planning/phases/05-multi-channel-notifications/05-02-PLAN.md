---
phase: 05-multi-channel-notifications
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/services/notification/channels/email.channel.ts
  - src/services/notification/channels/sms.channel.ts
  - src/services/notification/templates/email.templates.ts
autonomous: true

must_haves:
  truths:
    - "System sends PagerDuty-style emails with magic links"
    - "System sends SMS notifications within 160 character limit"
    - "Email includes acknowledge and resolve action links"
    - "SMS includes incident ID and ACK reply instruction"
  artifacts:
    - path: "src/services/notification/channels/email.channel.ts"
      provides: "Email channel implementation via AWS SES"
      exports: ["EmailChannel"]
    - path: "src/services/notification/channels/sms.channel.ts"
      provides: "SMS channel implementation via Twilio"
      exports: ["SMSChannel"]
    - path: "src/services/notification/templates/email.templates.ts"
      provides: "PagerDuty-style email HTML templates"
      exports: ["buildIncidentEmailHtml", "buildIncidentEmailText"]
  key_links:
    - from: "EmailChannel.send"
      to: "AWS SES SendEmailCommand"
      via: "sesClient.send"
      pattern: "SendEmailCommand"
    - from: "SMSChannel.send"
      to: "Twilio messages.create"
      via: "twilioClient.messages.create"
      pattern: "messages\\.create"
---

<objective>
Email and SMS channel implementations with PagerDuty-style formatting

Purpose: Implement NOTIF-01 (email notifications) and NOTIF-05 (SMS notifications) with user-specified format. Email includes magic links for quick acknowledge/resolve without login. SMS is optimized for 160 character limit with ACK reply support.

Output: EmailChannel and SMSChannel classes implementing NotificationChannel interface; email templates matching PagerDuty format
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@.planning/phases/05-multi-channel-notifications/05-RESEARCH.md
@src/services/notification.service.ts
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email channel with PagerDuty-style templates</name>
  <files>src/services/notification/templates/email.templates.ts, src/services/notification/channels/email.channel.ts</files>
  <action>
1. Create `src/services/notification/templates/email.templates.ts`:
```typescript
import type { NotificationPayload } from '../types.js';

// Colors by priority (per user decision - PagerDuty style)
const PRIORITY_COLORS: Record<string, string> = {
  CRITICAL: '#ff0000',
  HIGH: '#ff6600',
  MEDIUM: '#ffcc00',
  LOW: '#00cc00',
  INFO: '#0066cc'
};

interface EmailData extends NotificationPayload {
  ackUrl: string;
  resolveUrl: string;
}

export function buildIncidentEmailSubject(data: NotificationPayload): string {
  const prefix = data.escalationLevel
    ? `[ESCALATION - Level ${data.escalationLevel}] `
    : '';
  return `${prefix}[${data.priority}] ${data.service}: ${data.title}`;
}

export function buildIncidentEmailHtml(data: EmailData): string {
  const color = PRIORITY_COLORS[data.priority] || PRIORITY_COLORS.MEDIUM;
  const icon = data.priority === 'CRITICAL' ? '&#128680;' : '&#9888;';  // Siren or warning
  const escalationBadge = data.escalationLevel
    ? `<p style="margin: 8px 0; font-size: 14px;">Escalation Level ${data.escalationLevel}</p>`
    : '';

  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #333;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
    }
    .container { max-width: 600px; margin: 0 auto; background: white; }
    .header {
      background: ${color};
      color: white;
      padding: 20px;
      text-align: center;
    }
    .header h2 { margin: 0; font-size: 20px; }
    .content { padding: 24px; }
    .details {
      background: #f9f9f9;
      padding: 16px;
      border-left: 4px solid #007bff;
      margin: 16px 0;
    }
    .detail-row { margin: 8px 0; }
    .label { font-weight: bold; color: #666; display: inline-block; width: 100px; }
    .alert-message {
      background: #f5f5f5;
      padding: 16px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      white-space: pre-wrap;
      word-wrap: break-word;
      margin: 16px 0;
      font-size: 13px;
    }
    .actions { text-align: center; margin: 24px 0; }
    .button {
      display: inline-block;
      padding: 14px 32px;
      margin: 8px;
      text-decoration: none;
      border-radius: 4px;
      font-weight: bold;
      font-size: 14px;
    }
    .btn-primary { background: #007bff; color: white !important; }
    .btn-danger { background: #dc3545; color: white !important; }
    .footer {
      text-align: center;
      padding: 16px;
      color: #666;
      font-size: 12px;
      background: #f9f9f9;
      border-top: 1px solid #eee;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>${icon} ${data.priority} Incident</h2>
      ${escalationBadge}
    </div>

    <div class="content">
      <h3 style="margin-top: 0; color: #333;">${data.title}</h3>

      <div class="details">
        <div class="detail-row">
          <span class="label">Service:</span> ${data.service}
        </div>
        <div class="detail-row">
          <span class="label">Priority:</span> ${data.priority}
        </div>
        <div class="detail-row">
          <span class="label">Triggered:</span> ${formatTimestamp(data.triggeredAt)}
        </div>
        <div class="detail-row">
          <span class="label">Alert Count:</span> ${data.alertCount} alert${data.alertCount > 1 ? 's' : ''}
        </div>
        <div class="detail-row">
          <span class="label">Incident:</span> #${data.incidentId.slice(-8)}
        </div>
        <div class="detail-row">
          <span class="label">Team:</span> ${data.teamName}
        </div>
      </div>

      <div class="alert-message">${escapeHtml(data.body)}</div>

      <div class="actions">
        <a href="${data.ackUrl}" class="button btn-primary">Acknowledge Incident</a>
        <a href="${data.resolveUrl}" class="button btn-danger">Resolve Incident</a>
      </div>

      <p style="text-align: center; margin: 24px 0;">
        <a href="${data.dashboardUrl}/incidents/${data.incidentId}" style="color: #007bff;">
          View Full Details in Dashboard &rarr;
        </a>
      </p>
    </div>

    <div class="footer">
      <p>Action links expire in 15 minutes.</p>
      <p>You're receiving this because you're on-call for ${data.teamName}.</p>
    </div>
  </div>
</body>
</html>
  `.trim();
}

export function buildIncidentEmailText(data: EmailData): string {
  const icon = data.priority === 'CRITICAL' ? '[!!!]' : '[!]';
  const escalationLine = data.escalationLevel
    ? `Escalation Level: ${data.escalationLevel}\n`
    : '';

  return `
${icon} ${data.priority} INCIDENT${data.escalationLevel ? ` - ESCALATION LEVEL ${data.escalationLevel}` : ''}

${data.title}

Service: ${data.service}
Priority: ${data.priority}
Triggered: ${formatTimestamp(data.triggeredAt)}
Alert Count: ${data.alertCount}
Incident: #${data.incidentId.slice(-8)}
Team: ${data.teamName}
${escalationLine}
Alert Message:
${data.body}

Actions:
Acknowledge: ${data.ackUrl}
Resolve: ${data.resolveUrl}
View Dashboard: ${data.dashboardUrl}/incidents/${data.incidentId}

Links expire in 15 minutes.
  `.trim();
}

function formatTimestamp(date: Date): string {
  return date.toLocaleString('en-US', {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    timeZoneName: 'short'
  });
}

function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}
```

2. Create `src/services/notification/channels/email.channel.ts`:
```typescript
import crypto from 'crypto';
import { SESClient, SendEmailCommand } from '@aws-sdk/client-ses';
import { BaseChannel } from './base.channel.js';
import type { NotificationPayload, ChannelDeliveryResult } from '../types.js';
import {
  buildIncidentEmailSubject,
  buildIncidentEmailHtml,
  buildIncidentEmailText
} from '../templates/email.templates.js';
import { prisma } from '../../../config/database.js';
import { env } from '../../../config/env.js';
import { logger } from '../../../config/logger.js';

export class EmailChannel extends BaseChannel {
  name = 'email';
  private sesClient: SESClient;

  constructor() {
    super();
    const config: any = { region: env.AWS_REGION };
    if (env.AWS_ACCESS_KEY_ID && env.AWS_SECRET_ACCESS_KEY) {
      config.credentials = {
        accessKeyId: env.AWS_ACCESS_KEY_ID,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY
      };
    }
    this.sesClient = new SESClient(config);
  }

  supportsInteractivity(): boolean {
    return true;  // Magic links
  }

  async send(payload: NotificationPayload): Promise<ChannelDeliveryResult> {
    return this.withErrorHandling(async () => {
      // Get user email
      const user = await prisma.user.findUnique({
        where: { id: payload.userId },
        select: { email: true }
      });

      if (!user?.email) {
        return { success: false, error: 'User email not found' };
      }

      // Generate magic link tokens (15 minute expiry per user decision)
      const ackToken = await this.generateMagicLinkToken(payload.incidentId, 'acknowledge');
      const resolveToken = await this.generateMagicLinkToken(payload.incidentId, 'resolve');

      const baseUrl = env.API_BASE_URL || 'http://localhost:3000';
      const ackUrl = `${baseUrl}/magic/ack/${payload.incidentId}/${ackToken}`;
      const resolveUrl = `${baseUrl}/magic/resolve/${payload.incidentId}/${resolveToken}`;

      const emailData = {
        ...payload,
        ackUrl,
        resolveUrl
      };

      const subject = buildIncidentEmailSubject(payload);
      const htmlBody = buildIncidentEmailHtml(emailData);
      const textBody = buildIncidentEmailText(emailData);

      const command = new SendEmailCommand({
        Source: env.AWS_SES_FROM_EMAIL,
        Destination: { ToAddresses: [user.email] },
        Message: {
          Subject: { Data: subject },
          Body: {
            Html: { Data: htmlBody },
            Text: { Data: textBody }
          }
        }
      });

      const result = await this.sesClient.send(command);

      logger.info(
        { channel: 'email', incidentId: payload.incidentId, userId: payload.userId, messageId: result.MessageId },
        'Email notification sent'
      );

      return {
        success: true,
        providerId: result.MessageId,
        deliveredAt: new Date()
      };
    }, { incidentId: payload.incidentId, userId: payload.userId });
  }

  // Generate secure magic link token (OWASP pattern)
  private async generateMagicLinkToken(incidentId: string, action: 'acknowledge' | 'resolve'): Promise<string> {
    // Cryptographically secure random token (32 bytes = 256 bits)
    const token = crypto.randomBytes(32).toString('hex');

    // Store hash in database (never store plaintext)
    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

    await prisma.magicLinkToken.create({
      data: {
        tokenHash,
        incidentId,
        action,
        expiresAt: new Date(Date.now() + 15 * 60 * 1000)  // 15 minutes per user decision
      }
    });

    // Return unhashed token for URL
    return token;
  }
}

export const emailChannel = new EmailChannel();
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/templates/email.templates.ts src/services/notification/channels/email.channel.ts</verify>
  <done>Email channel sends PagerDuty-style emails with magic links for acknowledge/resolve</done>
</task>

<task type="auto">
  <name>Task 2: Create SMS channel with 160-character optimization</name>
  <files>src/services/notification/channels/sms.channel.ts</files>
  <action>
Create `src/services/notification/channels/sms.channel.ts`:
```typescript
import twilio from 'twilio';
import { BaseChannel } from './base.channel.js';
import type { NotificationPayload, ChannelDeliveryResult } from '../types.js';
import { prisma } from '../../../config/database.js';
import { env } from '../../../config/env.js';
import { logger } from '../../../config/logger.js';

export class SMSChannel extends BaseChannel {
  name = 'sms';
  private twilioClient: ReturnType<typeof twilio>;

  constructor() {
    super();
    this.twilioClient = twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);
  }

  supportsInteractivity(): boolean {
    return true;  // Reply ACK
  }

  async send(payload: NotificationPayload): Promise<ChannelDeliveryResult> {
    return this.withErrorHandling(async () => {
      // Get user phone
      const user = await prisma.user.findUnique({
        where: { id: payload.userId },
        select: { phone: true, phoneVerified: true }
      });

      if (!user?.phone) {
        return { success: false, error: 'User phone not found' };
      }

      if (!user.phoneVerified) {
        return { success: false, error: 'User phone not verified' };
      }

      // Build SMS message (160 char limit per user decision)
      const body = this.buildSMSMessage(payload);

      const message = await this.twilioClient.messages.create({
        from: env.TWILIO_PHONE_NUMBER,
        to: user.phone,
        body,
        statusCallback: `${env.API_BASE_URL}/webhooks/twilio/sms/status`
      });

      logger.info(
        { channel: 'sms', incidentId: payload.incidentId, userId: payload.userId, messageSid: message.sid },
        'SMS notification sent'
      );

      return {
        success: true,
        providerId: message.sid,
        deliveredAt: new Date()
      };
    }, { incidentId: payload.incidentId, userId: payload.userId });
  }

  // Build SMS message optimized for 160 character limit
  // Format per user decision: [PRIORITY] service: message. Incident #ID - Reply ACK
  private buildSMSMessage(payload: NotificationPayload): string {
    const shortId = payload.incidentId.slice(-6);  // Last 6 chars for brevity

    // Build prefix (escalation or regular)
    let prefix: string;
    if (payload.escalationLevel) {
      prefix = `[ESC-L${payload.escalationLevel}][${payload.priority}]`;
    } else {
      prefix = `[${payload.priority}]`;
    }

    // Calculate available space for message
    // Format: "{prefix} {service}: {message}. Incident #{id} - Reply ACK"
    const suffix = `. Incident #${shortId} - Reply ACK`;
    const overhead = prefix.length + 1 + payload.service.length + 2 + suffix.length;
    // prefix + " " + service + ": " + suffix
    const availableChars = 160 - overhead;

    // Truncate title if needed
    let title = payload.title;
    if (title.length > availableChars) {
      title = title.substring(0, availableChars - 3) + '...';
    }

    const message = `${prefix} ${payload.service}: ${title}${suffix}`;

    // Final safety check
    if (message.length > 160) {
      logger.warn(
        { length: message.length, incidentId: payload.incidentId },
        'SMS message exceeds 160 chars, truncating'
      );
      return message.substring(0, 157) + '...';
    }

    return message;
  }
}

export const smsChannel = new SMSChannel();
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/channels/sms.channel.ts</verify>
  <done>SMS channel sends 160-character messages with incident ID and ACK instruction</done>
</task>

</tasks>

<verification>
- Email templates produce valid HTML/text with all required fields
- Magic link tokens are generated with SHA-256 hash and 15-minute expiry
- SMS messages stay within 160 character limit
- SMS includes incident ID and "Reply ACK" instruction
- TypeScript compiles without errors
</verification>

<success_criteria>
1. EmailChannel sends PagerDuty-style emails with color-coded header, full incident details
2. Email includes magic link URLs for acknowledge and resolve actions
3. SMSChannel formats messages to fit 160 character limit
4. SMS format matches user specification: `[PRIORITY] service: message. Incident #ID - Reply ACK`
5. Escalation level prefix included when applicable
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-02-SUMMARY.md`
</output>

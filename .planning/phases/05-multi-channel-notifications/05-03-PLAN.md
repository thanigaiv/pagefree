---
phase: 05-multi-channel-notifications
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/services/notification/channels/slack.channel.ts
  - src/services/notification/templates/slack.templates.ts
autonomous: true
user_setup:
  - service: slack
    why: "Slack bot for sending notifications and receiving button clicks"
    env_vars:
      - name: SLACK_BOT_TOKEN
        source: "Slack App -> OAuth & Permissions -> Bot User OAuth Token (xoxb-...)"
      - name: SLACK_SIGNING_SECRET
        source: "Slack App -> Basic Information -> App Credentials -> Signing Secret"
    dashboard_config:
      - task: "Create Slack App"
        location: "https://api.slack.com/apps -> Create New App"
      - task: "Add bot scopes: chat:write, users:read, users:read.email"
        location: "App -> OAuth & Permissions -> Bot Token Scopes"
      - task: "Install app to workspace"
        location: "App -> OAuth & Permissions -> Install to Workspace"
      - task: "Enable Interactivity"
        location: "App -> Interactivity & Shortcuts -> toggle ON, set Request URL to {API_BASE_URL}/webhooks/slack/interactions"

must_haves:
  truths:
    - "System sends Slack messages with color-coded blocks by priority"
    - "Slack messages include Acknowledge and Resolve buttons"
    - "System posts to both user DM and team channel"
  artifacts:
    - path: "src/services/notification/channels/slack.channel.ts"
      provides: "Slack channel implementation via @slack/web-api"
      exports: ["SlackChannel"]
    - path: "src/services/notification/templates/slack.templates.ts"
      provides: "Slack Block Kit message builders"
      exports: ["buildSlackIncidentBlocks"]
  key_links:
    - from: "SlackChannel.send"
      to: "@slack/web-api chat.postMessage"
      via: "slackClient.chat.postMessage"
      pattern: "chat\\.postMessage"
---

<objective>
Slack channel implementation with Block Kit action buttons

Purpose: Implement NOTIF-02 (Slack notifications) with rich Block Kit messages that include inline Acknowledge and Resolve buttons. Messages are color-coded by priority and sent to both user DM and team channel per user decision.

Output: SlackChannel class implementing NotificationChannel interface; Block Kit template builders
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@.planning/phases/05-multi-channel-notifications/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Slack SDK and add env config</name>
  <files>package.json, src/config/env.ts</files>
  <action>
1. Install @slack/web-api:
```bash
npm install @slack/web-api@^7.0.0
```

2. Add Slack configuration to `src/config/env.ts`:
```typescript
// Add to existing env object exports:
export const env = {
  // ... existing env vars ...

  // Slack configuration
  SLACK_BOT_TOKEN: process.env.SLACK_BOT_TOKEN || '',
  SLACK_SIGNING_SECRET: process.env.SLACK_SIGNING_SECRET || '',
};
```

Verify env.ts includes SLACK_BOT_TOKEN and SLACK_SIGNING_SECRET.
  </action>
  <verify>npm ls @slack/web-api && grep -q "SLACK_BOT_TOKEN" src/config/env.ts</verify>
  <done>@slack/web-api installed and env config includes Slack variables</done>
</task>

<task type="auto">
  <name>Task 2: Create Slack Block Kit templates</name>
  <files>src/services/notification/templates/slack.templates.ts</files>
  <action>
Create `src/services/notification/templates/slack.templates.ts`:
```typescript
import type { NotificationPayload } from '../types.js';

// Priority color mapping for Slack attachments
const PRIORITY_COLORS: Record<string, string> = {
  CRITICAL: '#ff0000',  // Red
  HIGH: '#ff6600',      // Orange
  MEDIUM: '#ffcc00',    // Yellow
  LOW: '#00cc00',       // Green
  INFO: '#0066cc'       // Blue
};

// Build Slack Block Kit message for incident notification
export function buildSlackIncidentBlocks(payload: NotificationPayload): {
  text: string;
  attachments: any[];
} {
  const color = PRIORITY_COLORS[payload.priority] || PRIORITY_COLORS.MEDIUM;
  const icon = payload.priority === 'CRITICAL' ? ':rotating_light: ' : '';
  const escalationText = payload.escalationLevel
    ? `*ESCALATION - Level ${payload.escalationLevel}*\n`
    : '';

  return {
    // Fallback text for notifications
    text: `${icon}[${payload.priority}] ${payload.service}: ${payload.title}`,
    attachments: [{
      color: color,
      blocks: [
        // Header
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: `${icon}${payload.title}`.substring(0, 150),
            emoji: true
          }
        },
        // Escalation badge if applicable
        ...(payload.escalationLevel ? [{
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `:warning: *Escalation Level ${payload.escalationLevel}*`
          }
        }] : []),
        // Incident details
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*Service:*\n${payload.service}`
            },
            {
              type: 'mrkdwn',
              text: `*Priority:*\n${payload.priority}`
            },
            {
              type: 'mrkdwn',
              text: `*Incident:*\n#${payload.incidentId.slice(-8)}`
            },
            {
              type: 'mrkdwn',
              text: `*Triggered:*\n<!date^${Math.floor(payload.triggeredAt.getTime() / 1000)}^{date_short_pretty} {time}|${payload.triggeredAt.toISOString()}>`
            }
          ]
        },
        // Alert count and team
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: `*Alerts:* ${payload.alertCount} | *Team:* ${payload.teamName}`
            }
          ]
        },
        // Alert message (truncated if long)
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `\`\`\`${truncateForSlack(payload.body, 2900)}\`\`\``
          }
        },
        // Action buttons
        {
          type: 'actions',
          block_id: `incident_actions_${payload.incidentId}`,
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'Acknowledge',
                emoji: true
              },
              style: 'primary',
              value: payload.incidentId,
              action_id: 'acknowledge_incident'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'Resolve',
                emoji: true
              },
              style: 'danger',
              value: payload.incidentId,
              action_id: 'resolve_incident'
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'View Dashboard',
                emoji: true
              },
              url: `${payload.dashboardUrl}/incidents/${payload.incidentId}`,
              action_id: 'view_incident'
            }
          ]
        }
      ]
    }]
  };
}

// Build updated message after acknowledgment
export function buildSlackAcknowledgedBlocks(
  originalBlocks: any[],
  acknowledgedBy: string,
  acknowledgedAt: Date
): any[] {
  return originalBlocks.map(block => {
    // Update action buttons block
    if (block.type === 'actions' && block.block_id?.startsWith('incident_actions_')) {
      return {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `:white_check_mark: *Acknowledged by <@${acknowledgedBy}>* at <!date^${Math.floor(acknowledgedAt.getTime() / 1000)}^{date_short_pretty} {time}|${acknowledgedAt.toISOString()}>`
        }
      };
    }
    return block;
  });
}

// Build updated message after resolution
export function buildSlackResolvedBlocks(
  originalBlocks: any[],
  resolvedBy: string,
  resolvedAt: Date
): any[] {
  return originalBlocks.map(block => {
    // Update action buttons block
    if (block.type === 'actions' && block.block_id?.startsWith('incident_actions_')) {
      return {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `:white_check_mark: *Resolved by <@${resolvedBy}>* at <!date^${Math.floor(resolvedAt.getTime() / 1000)}^{date_short_pretty} {time}|${resolvedAt.toISOString()}>`
        }
      };
    }
    return block;
  });
}

function truncateForSlack(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 20) + '\n... (truncated)';
}
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/templates/slack.templates.ts</verify>
  <done>Slack Block Kit templates build color-coded messages with action buttons</done>
</task>

<task type="auto">
  <name>Task 3: Create Slack channel implementation</name>
  <files>src/services/notification/channels/slack.channel.ts</files>
  <action>
Create `src/services/notification/channels/slack.channel.ts`:
```typescript
import { WebClient } from '@slack/web-api';
import { BaseChannel } from './base.channel.js';
import type { NotificationPayload, ChannelDeliveryResult } from '../types.js';
import { buildSlackIncidentBlocks } from '../templates/slack.templates.js';
import { prisma } from '../../../config/database.js';
import { env } from '../../../config/env.js';
import { logger } from '../../../config/logger.js';

export class SlackChannel extends BaseChannel {
  name = 'slack';
  private slackClient: WebClient;

  constructor() {
    super();
    this.slackClient = new WebClient(env.SLACK_BOT_TOKEN);
  }

  supportsInteractivity(): boolean {
    return true;  // Action buttons
  }

  async send(payload: NotificationPayload): Promise<ChannelDeliveryResult> {
    return this.withErrorHandling(async () => {
      // Get user's Slack connection
      const user = await prisma.user.findUnique({
        where: { id: payload.userId },
        include: { slackConnection: true }
      });

      if (!user?.slackConnection) {
        return { success: false, error: 'User has no Slack connection' };
      }

      if (!user.slackConnection.isActive) {
        return { success: false, error: 'Slack connection is not active' };
      }

      // Build Block Kit message
      const message = buildSlackIncidentBlocks(payload);
      const results: string[] = [];

      // Send to user DM (per user decision: send to both personal AND team channel)
      try {
        const dmResult = await this.slackClient.chat.postMessage({
          channel: user.slackConnection.slackUserId,  // DM by user ID
          text: message.text,
          attachments: message.attachments
        });

        if (dmResult.ts) {
          results.push(`dm:${dmResult.ts}`);
        }

        logger.info(
          { channel: 'slack', type: 'dm', incidentId: payload.incidentId, userId: payload.userId, ts: dmResult.ts },
          'Slack DM sent'
        );
      } catch (dmError) {
        logger.warn(
          { channel: 'slack', type: 'dm', incidentId: payload.incidentId, error: (dmError as Error).message },
          'Failed to send Slack DM'
        );
      }

      // Send to team channel if configured
      const team = await prisma.team.findFirst({
        where: { id: payload.teamName },  // teamName is actually team ID in payload
        select: { slackChannel: true }
      });

      // Fallback: try to find team by name
      const teamByName = team || await prisma.team.findFirst({
        where: { name: payload.teamName },
        select: { slackChannel: true }
      });

      if (teamByName?.slackChannel) {
        try {
          const channelResult = await this.slackClient.chat.postMessage({
            channel: teamByName.slackChannel,
            text: message.text,
            attachments: message.attachments
          });

          if (channelResult.ts) {
            results.push(`channel:${channelResult.ts}`);
          }

          logger.info(
            { channel: 'slack', type: 'team_channel', incidentId: payload.incidentId, slackChannel: teamByName.slackChannel, ts: channelResult.ts },
            'Slack team channel message sent'
          );
        } catch (channelError) {
          logger.warn(
            { channel: 'slack', type: 'team_channel', incidentId: payload.incidentId, error: (channelError as Error).message },
            'Failed to send Slack team channel message'
          );
        }
      }

      // Update last used timestamp
      await prisma.slackConnection.update({
        where: { id: user.slackConnection.id },
        data: { lastUsedAt: new Date() }
      });

      // Consider success if at least one message sent
      if (results.length === 0) {
        return { success: false, error: 'Failed to send to both DM and channel' };
      }

      return {
        success: true,
        providerId: results.join(','),
        deliveredAt: new Date()
      };
    }, { incidentId: payload.incidentId, userId: payload.userId });
  }

  // Get provider health status
  async getProviderStatus(): Promise<{ healthy: boolean; latencyMs?: number }> {
    const start = Date.now();
    try {
      await this.slackClient.auth.test();
      return {
        healthy: true,
        latencyMs: Date.now() - start
      };
    } catch {
      return { healthy: false };
    }
  }
}

export const slackChannel = new SlackChannel();
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/channels/slack.channel.ts</verify>
  <done>Slack channel sends Block Kit messages to user DM and team channel with action buttons</done>
</task>

</tasks>

<verification>
- @slack/web-api installed and listed in package.json
- Block Kit templates produce valid Slack message structures
- Messages include color-coded attachments based on priority
- Action buttons have correct action_id values
- Channel sends to both user DM and team channel
- TypeScript compiles without errors
</verification>

<success_criteria>
1. Slack messages use Block Kit with color-coded attachments by priority
2. Messages include Acknowledge (primary) and Resolve (danger) buttons
3. Messages include View Dashboard link button
4. System sends to both user DM and team channel (per user decision)
5. Escalation level shown when applicable
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-03-SUMMARY.md`
</output>

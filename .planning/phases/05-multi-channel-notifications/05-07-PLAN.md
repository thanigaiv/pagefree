---
phase: 05-multi-channel-notifications
plan: 07
type: execute
wave: 2
depends_on: [05-03]
files_modified:
  - src/routes/webhooks/slack-interactions.ts
  - src/routes/webhooks/slack-commands.ts
  - src/services/notification/slack-interaction.service.ts
autonomous: true

must_haves:
  truths:
    - "User can acknowledge incident from Slack button"
    - "User can resolve incident from Slack button"
    - "User can use slash commands: /oncall ack, /oncall resolve"
    - "System verifies Slack request signatures"
    - "System updates Slack message after action"
  artifacts:
    - path: "src/routes/webhooks/slack-interactions.ts"
      provides: "Slack button click handler with signature verification"
      exports: ["slackInteractionsRouter"]
    - path: "src/routes/webhooks/slack-commands.ts"
      provides: "Slack slash command handler"
      exports: ["slackCommandsRouter"]
    - path: "src/services/notification/slack-interaction.service.ts"
      provides: "Slack interaction processing with optimistic UI"
      exports: ["SlackInteractionService"]
  key_links:
    - from: "slack-interactions.ts"
      to: "incidentService.acknowledge"
      via: "slackInteractionService.processAction"
      pattern: "incidentService\\.(acknowledge|resolve)"
---

<objective>
Slack bidirectional sync with button interactions and slash commands

Purpose: Implement NOTIF-10 (acknowledge from Slack) and NOTIF-11 (resolve from Slack). Handle button clicks with signature verification, update Slack messages with optimistic UI pattern per user decision. Support slash commands for power users.

Output: Slack interaction webhook handlers, slash command router, SlackInteractionService for processing
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@.planning/phases/05-multi-channel-notifications/05-RESEARCH.md
@src/services/incident.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Slack interaction service with optimistic UI</name>
  <files>src/services/notification/slack-interaction.service.ts</files>
  <action>
Create `src/services/notification/slack-interaction.service.ts`:
```typescript
import crypto from 'crypto';
import { WebClient } from '@slack/web-api';
import { incidentService } from '../incident.service.js';
import { prisma } from '../../config/database.js';
import { env } from '../../config/env.js';
import { logger } from '../../config/logger.js';
import {
  buildSlackAcknowledgedBlocks,
  buildSlackResolvedBlocks
} from './templates/slack.templates.js';

interface SlackActionPayload {
  type: string;
  user: { id: string; username: string };
  channel: { id: string };
  message: { ts: string; blocks: any[] };
  actions: Array<{ action_id: string; value: string }>;
  response_url: string;
}

class SlackInteractionService {
  private slackClient: WebClient;

  constructor() {
    this.slackClient = new WebClient(env.SLACK_BOT_TOKEN);
  }

  // Verify Slack request signature (required for security)
  verifySignature(signature: string, timestamp: string, body: string): boolean {
    // Prevent replay attacks (must be within 5 minutes)
    const now = Math.floor(Date.now() / 1000);
    if (Math.abs(now - parseInt(timestamp)) > 300) {
      logger.warn({ timestamp, now }, 'Slack request timestamp too old');
      return false;
    }

    // Compute expected signature
    const sigBaseString = `v0:${timestamp}:${body}`;
    const expectedSignature = 'v0=' + crypto
      .createHmac('sha256', env.SLACK_SIGNING_SECRET)
      .update(sigBaseString)
      .digest('hex');

    // Timing-safe comparison
    try {
      return crypto.timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(expectedSignature)
      );
    } catch {
      return false;
    }
  }

  // Process button click action
  async processAction(payload: SlackActionPayload): Promise<void> {
    const action = payload.actions[0];
    const incidentId = action.value;
    const slackUserId = payload.user.id;

    logger.info(
      { action: action.action_id, incidentId, slackUserId },
      'Processing Slack action'
    );

    // Look up platform user from Slack ID
    const slackConnection = await prisma.slackConnection.findUnique({
      where: { slackUserId }
    });

    if (!slackConnection) {
      await this.sendErrorResponse(payload.response_url, 'Your Slack account is not connected to OnCall Platform');
      return;
    }

    // Optimistic UI: Update message immediately with loading state
    await this.updateMessageWithLoading(payload.channel.id, payload.message.ts, action.action_id);

    try {
      switch (action.action_id) {
        case 'acknowledge_incident':
          await this.handleAcknowledge(incidentId, slackConnection.userId, payload, slackUserId);
          break;

        case 'resolve_incident':
          await this.handleResolve(incidentId, slackConnection.userId, payload, slackUserId);
          break;

        default:
          logger.warn({ actionId: action.action_id }, 'Unknown Slack action');
      }
    } catch (error) {
      // Rollback on failure (restore original message)
      await this.rollbackMessage(payload.channel.id, payload.message.ts, payload.message.blocks, error);
    }
  }

  private async handleAcknowledge(
    incidentId: string,
    userId: string,
    payload: SlackActionPayload,
    slackUserId: string
  ): Promise<void> {
    // Acknowledge incident in platform
    await incidentService.acknowledge(incidentId, userId, { note: 'Acknowledged via Slack' });

    // Update Slack message with final state
    const updatedBlocks = buildSlackAcknowledgedBlocks(
      payload.message.blocks,
      slackUserId,
      new Date()
    );

    await this.slackClient.chat.update({
      channel: payload.channel.id,
      ts: payload.message.ts,
      blocks: updatedBlocks,
      attachments: [{
        color: '#00cc00',  // Green for acknowledged
        blocks: updatedBlocks
      }]
    });

    logger.info({ incidentId, userId, slackUserId }, 'Incident acknowledged via Slack');
  }

  private async handleResolve(
    incidentId: string,
    userId: string,
    payload: SlackActionPayload,
    slackUserId: string
  ): Promise<void> {
    // Resolve incident in platform
    await incidentService.resolve(incidentId, userId, { resolutionNote: 'Resolved via Slack' });

    // Update Slack message with final state
    const updatedBlocks = buildSlackResolvedBlocks(
      payload.message.blocks,
      slackUserId,
      new Date()
    );

    await this.slackClient.chat.update({
      channel: payload.channel.id,
      ts: payload.message.ts,
      blocks: updatedBlocks,
      attachments: [{
        color: '#0066cc',  // Blue for resolved
        blocks: updatedBlocks
      }]
    });

    logger.info({ incidentId, userId, slackUserId }, 'Incident resolved via Slack');
  }

  // Update message with loading state (optimistic UI)
  private async updateMessageWithLoading(channelId: string, ts: string, actionId: string): Promise<void> {
    try {
      const actionText = actionId === 'acknowledge_incident' ? 'Acknowledging...' : 'Resolving...';
      await this.slackClient.chat.update({
        channel: channelId,
        ts: ts,
        text: actionText,
        blocks: [{
          type: 'section',
          text: { type: 'mrkdwn', text: `:hourglass_flowing_sand: ${actionText}` }
        }]
      });
    } catch (error) {
      // Non-fatal: continue even if loading state fails
      logger.warn({ error }, 'Failed to update Slack message with loading state');
    }
  }

  // Rollback message on failure (per user decision: optimistic UI + rollback)
  private async rollbackMessage(channelId: string, ts: string, originalBlocks: any[], error: unknown): Promise<void> {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';

    try {
      await this.slackClient.chat.update({
        channel: channelId,
        ts: ts,
        blocks: originalBlocks,
        text: `Action failed: ${errorMessage}`
      });

      // Also post error as thread reply
      await this.slackClient.chat.postMessage({
        channel: channelId,
        thread_ts: ts,
        text: `:x: Action failed: ${errorMessage}`
      });
    } catch (rollbackError) {
      logger.error({ error: rollbackError }, 'Failed to rollback Slack message');
    }

    logger.warn({ channelId, ts, error: errorMessage }, 'Rolled back Slack message after action failure');
  }

  // Send error response to response_url
  private async sendErrorResponse(responseUrl: string, message: string): Promise<void> {
    try {
      await fetch(responseUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          response_type: 'ephemeral',
          text: `:x: ${message}`
        })
      });
    } catch (error) {
      logger.error({ error, responseUrl }, 'Failed to send error response to Slack');
    }
  }

  // Process slash command
  async processCommand(
    command: string,
    text: string,
    slackUserId: string,
    responseUrl: string
  ): Promise<void> {
    logger.info({ command, text, slackUserId }, 'Processing Slack slash command');

    // Look up platform user
    const slackConnection = await prisma.slackConnection.findUnique({
      where: { slackUserId }
    });

    if (!slackConnection) {
      await this.sendErrorResponse(responseUrl, 'Your Slack account is not connected to OnCall Platform. Visit /settings to connect.');
      return;
    }

    if (command !== '/oncall') {
      return;
    }

    const [action, incidentRef] = text.trim().split(/\s+/);

    try {
      switch (action?.toLowerCase()) {
        case 'ack':
        case 'acknowledge':
          if (!incidentRef) {
            await this.sendSlashResponse(responseUrl, 'ephemeral', 'Usage: `/oncall ack <incident-id>`');
            return;
          }
          await this.handleSlashAcknowledge(incidentRef, slackConnection.userId, slackUserId, responseUrl);
          break;

        case 'resolve':
          if (!incidentRef) {
            await this.sendSlashResponse(responseUrl, 'ephemeral', 'Usage: `/oncall resolve <incident-id>`');
            return;
          }
          await this.handleSlashResolve(incidentRef, slackConnection.userId, slackUserId, responseUrl);
          break;

        case 'list':
          await this.handleSlashList(slackConnection.userId, responseUrl);
          break;

        default:
          await this.sendSlashResponse(responseUrl, 'ephemeral',
            'Usage:\n' +
            '`/oncall ack <id>` - Acknowledge incident\n' +
            '`/oncall resolve <id>` - Resolve incident\n' +
            '`/oncall list` - List your open incidents'
          );
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : 'Unknown error';
      await this.sendSlashResponse(responseUrl, 'ephemeral', `:x: Error: ${msg}`);
    }
  }

  private async handleSlashAcknowledge(
    incidentRef: string,
    userId: string,
    slackUserId: string,
    responseUrl: string
  ): Promise<void> {
    // Find incident by ID or short ID
    const incident = await this.findIncident(incidentRef);
    if (!incident) {
      await this.sendSlashResponse(responseUrl, 'ephemeral', `Incident not found: ${incidentRef}`);
      return;
    }

    await incidentService.acknowledge(incident.id, userId, { note: 'Acknowledged via Slack slash command' });
    await this.sendSlashResponse(responseUrl, 'in_channel',
      `:white_check_mark: Incident #${incident.id.slice(-8)} acknowledged by <@${slackUserId}>`
    );
  }

  private async handleSlashResolve(
    incidentRef: string,
    userId: string,
    slackUserId: string,
    responseUrl: string
  ): Promise<void> {
    const incident = await this.findIncident(incidentRef);
    if (!incident) {
      await this.sendSlashResponse(responseUrl, 'ephemeral', `Incident not found: ${incidentRef}`);
      return;
    }

    await incidentService.resolve(incident.id, userId, { resolutionNote: 'Resolved via Slack slash command' });
    await this.sendSlashResponse(responseUrl, 'in_channel',
      `:white_check_mark: Incident #${incident.id.slice(-8)} resolved by <@${slackUserId}>`
    );
  }

  private async handleSlashList(userId: string, responseUrl: string): Promise<void> {
    const { incidents } = await incidentService.list(
      { assignedUserId: userId, status: ['OPEN', 'ACKNOWLEDGED'] },
      { limit: 10 }
    );

    if (incidents.length === 0) {
      await this.sendSlashResponse(responseUrl, 'ephemeral', 'You have no open incidents assigned to you.');
      return;
    }

    const lines = incidents.map(inc =>
      `- *#${inc.id.slice(-8)}* [${inc.priority}] ${inc.team.name}: ${inc.status}`
    );

    await this.sendSlashResponse(responseUrl, 'ephemeral',
      `*Your open incidents:*\n${lines.join('\n')}`
    );
  }

  private async findIncident(ref: string): Promise<any> {
    // Try full ID first
    let incident = await prisma.incident.findUnique({ where: { id: ref } });
    if (incident) return incident;

    // Try short ID suffix match
    incident = await prisma.incident.findFirst({
      where: { id: { endsWith: ref } },
      orderBy: { createdAt: 'desc' }
    });

    return incident;
  }

  private async sendSlashResponse(responseUrl: string, type: 'ephemeral' | 'in_channel', text: string): Promise<void> {
    await fetch(responseUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        response_type: type,
        text
      })
    });
  }
}

export const slackInteractionService = new SlackInteractionService();
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/slack-interaction.service.ts</verify>
  <done>SlackInteractionService handles actions with signature verification and optimistic UI</done>
</task>

<task type="auto">
  <name>Task 2: Create Slack interaction and command webhooks</name>
  <files>src/routes/webhooks/slack-interactions.ts, src/routes/webhooks/slack-commands.ts</files>
  <action>
1. Create `src/routes/webhooks/slack-interactions.ts`:
```typescript
import { Router, Request, Response } from 'express';
import { slackInteractionService } from '../../services/notification/slack-interaction.service.js';
import { logger } from '../../config/logger.js';

const router = Router();

// Slack sends interactions as application/x-www-form-urlencoded with payload JSON
router.post('/', async (req: Request, res: Response) => {
  const signature = req.headers['x-slack-signature'] as string;
  const timestamp = req.headers['x-slack-request-timestamp'] as string;

  if (!signature || !timestamp) {
    logger.warn('Missing Slack signature headers');
    return res.status(401).json({ error: 'Missing signature headers' });
  }

  // Get raw body for signature verification
  // Note: Need to ensure raw body is available (configure express middleware)
  const rawBody = (req as any).rawBody || JSON.stringify(req.body);

  // Verify signature
  if (!slackInteractionService.verifySignature(signature, timestamp, rawBody)) {
    logger.warn('Invalid Slack signature');
    return res.status(401).json({ error: 'Invalid signature' });
  }

  // Parse payload (Slack sends as form-urlencoded with payload JSON)
  let payload: any;
  try {
    payload = JSON.parse(req.body.payload || req.body);
  } catch {
    logger.warn('Invalid payload format');
    return res.status(400).json({ error: 'Invalid payload' });
  }

  // Acknowledge receipt immediately (Slack requires response within 3 seconds)
  res.status(200).send();

  // Process action asynchronously
  try {
    await slackInteractionService.processAction(payload);
  } catch (error) {
    logger.error({ error, payload: payload?.actions?.[0] }, 'Error processing Slack interaction');
  }
});

export const slackInteractionsRouter = router;
```

2. Create `src/routes/webhooks/slack-commands.ts`:
```typescript
import { Router, Request, Response } from 'express';
import { slackInteractionService } from '../../services/notification/slack-interaction.service.js';
import { logger } from '../../config/logger.js';

const router = Router();

// Slack sends slash commands as application/x-www-form-urlencoded
router.post('/', async (req: Request, res: Response) => {
  const signature = req.headers['x-slack-signature'] as string;
  const timestamp = req.headers['x-slack-request-timestamp'] as string;

  if (!signature || !timestamp) {
    logger.warn('Missing Slack signature headers');
    return res.status(401).json({ error: 'Missing signature headers' });
  }

  // Get raw body for signature verification
  const rawBody = (req as any).rawBody || new URLSearchParams(req.body).toString();

  // Verify signature
  if (!slackInteractionService.verifySignature(signature, timestamp, rawBody)) {
    logger.warn('Invalid Slack signature');
    return res.status(401).json({ error: 'Invalid signature' });
  }

  const { command, text, user_id, response_url } = req.body;

  // Acknowledge immediately
  res.status(200).json({
    response_type: 'ephemeral',
    text: 'Processing command...'
  });

  // Process command asynchronously
  try {
    await slackInteractionService.processCommand(command, text, user_id, response_url);
  } catch (error) {
    logger.error({ error, command, text }, 'Error processing Slack command');
  }
});

export const slackCommandsRouter = router;
```
  </action>
  <verify>npx tsc --noEmit src/routes/webhooks/slack-interactions.ts src/routes/webhooks/slack-commands.ts</verify>
  <done>Slack webhook routes handle button clicks and slash commands with signature verification</done>
</task>

<task type="auto">
  <name>Task 3: Mount Slack webhooks in Express app</name>
  <files>src/index.ts</files>
  <action>
Add Slack webhook routes to the Express app in `src/index.ts`.

Find the section where routes are mounted and add:

```typescript
// Import at top of file
import { slackInteractionsRouter } from './routes/webhooks/slack-interactions.js';
import { slackCommandsRouter } from './routes/webhooks/slack-commands.js';

// Add middleware to capture raw body for Slack signature verification
// This should be before the main body parsers, similar to webhook raw body capture
app.use('/webhooks/slack', express.urlencoded({
  extended: true,
  verify: (req: any, res, buf) => {
    req.rawBody = buf.toString();
  }
}));

// Mount Slack webhooks (before auth middleware)
app.use('/webhooks/slack/interactions', slackInteractionsRouter);
app.use('/webhooks/slack/commands', slackCommandsRouter);
```

The Slack routes should be mounted BEFORE any authentication middleware since they use signature-based auth.
  </action>
  <verify>grep -q "slackInteractionsRouter" src/index.ts</verify>
  <done>Slack webhook routes mounted in Express app</done>
</task>

</tasks>

<verification>
- Slack signature verification using HMAC-SHA256
- Timestamp validation (within 5 minutes) for replay attack prevention
- Button clicks trigger acknowledge/resolve in platform
- Optimistic UI: message updates immediately, rolls back on failure
- Slash commands: /oncall ack, /oncall resolve, /oncall list
- User lookup via SlackConnection links Slack user to platform user
- TypeScript compiles without errors
</verification>

<success_criteria>
1. User can click Acknowledge button in Slack -> incident acknowledged (NOTIF-10)
2. User can click Resolve button in Slack -> incident resolved (NOTIF-11)
3. User can use /oncall ack <id> and /oncall resolve <id> (per user decision)
4. Slack request signatures verified before processing
5. Optimistic UI: immediate visual feedback with rollback on failure (per user decision)
6. Race condition handled: first click wins, others see rollback (per user decision)
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-07-SUMMARY.md`
</output>

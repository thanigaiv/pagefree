---
phase: 05-multi-channel-notifications
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/services/notification/channels/push.channel.ts
  - src/services/notification/channels/voice.channel.ts
  - src/services/notification/templates/twiml.templates.ts
autonomous: true
user_setup:
  - service: aws_sns
    why: "AWS SNS for push notifications to iOS/Android via FCM and APNs"
    env_vars:
      - name: SNS_PLATFORM_APP_ARN_IOS
        source: "AWS Console -> SNS -> Mobile -> Platform applications -> ARN for iOS app"
      - name: SNS_PLATFORM_APP_ARN_ANDROID
        source: "AWS Console -> SNS -> Mobile -> Platform applications -> ARN for Android app"
    dashboard_config:
      - task: "Create SNS Platform Application for iOS (APNs)"
        location: "AWS Console -> SNS -> Mobile -> Push notifications -> Create platform application"
      - task: "Create SNS Platform Application for Android (FCM)"
        location: "AWS Console -> SNS -> Mobile -> Push notifications -> Create platform application"
      - task: "Upload APNs credentials (p8 key or certificate)"
        location: "AWS Console -> SNS -> Platform application -> Edit"
      - task: "Configure FCM server key"
        location: "AWS Console -> SNS -> Platform application -> Edit"

must_haves:
  truths:
    - "System sends push notifications that override DND for critical incidents"
    - "System makes phone calls with IVR for acknowledge/escalate"
    - "Voice calls use TTS with keypress menu"
  artifacts:
    - path: "src/services/notification/channels/push.channel.ts"
      provides: "Push channel implementation via AWS SNS"
      exports: ["PushChannel"]
    - path: "src/services/notification/channels/voice.channel.ts"
      provides: "Voice channel implementation via Twilio"
      exports: ["VoiceChannel"]
    - path: "src/services/notification/templates/twiml.templates.ts"
      provides: "TwiML XML templates for IVR"
      exports: ["buildIncidentCallTwiml", "buildKeypadResponseTwiml"]
  key_links:
    - from: "PushChannel.send"
      to: "AWS SNS PublishCommand"
      via: "snsClient.send"
      pattern: "PublishCommand"
    - from: "VoiceChannel.send"
      to: "Twilio calls.create"
      via: "twilioClient.calls.create"
      pattern: "calls\\.create"
---

<objective>
Push notification and voice call channel implementations

Purpose: Implement NOTIF-04 (push notifications) and NOTIF-06 (phone calls). Push notifications use platform-specific critical alerts to override DND for critical incidents per user decision. Voice calls use TwiML for interactive IVR with acknowledge/escalate options.

Output: PushChannel and VoiceChannel classes; TwiML templates for IVR flows
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@.planning/phases/05-multi-channel-notifications/05-RESEARCH.md
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install AWS SNS SDK and add env config</name>
  <files>package.json, src/config/env.ts</files>
  <action>
1. Install @aws-sdk/client-sns:
```bash
npm install @aws-sdk/client-sns@^3.0.0
```

2. Add SNS configuration to `src/config/env.ts`:
```typescript
// Add to existing env object:
export const env = {
  // ... existing env vars ...

  // AWS SNS Push configuration
  SNS_PLATFORM_APP_ARN_IOS: process.env.SNS_PLATFORM_APP_ARN_IOS || '',
  SNS_PLATFORM_APP_ARN_ANDROID: process.env.SNS_PLATFORM_APP_ARN_ANDROID || '',
};
```
  </action>
  <verify>npm ls @aws-sdk/client-sns && grep -q "SNS_PLATFORM_APP_ARN" src/config/env.ts</verify>
  <done>AWS SNS SDK installed and env config includes SNS platform ARNs</done>
</task>

<task type="auto">
  <name>Task 2: Create push notification channel with critical alerts</name>
  <files>src/services/notification/channels/push.channel.ts</files>
  <action>
Create `src/services/notification/channels/push.channel.ts`:
```typescript
import {
  SNSClient,
  PublishCommand,
  CreatePlatformEndpointCommand
} from '@aws-sdk/client-sns';
import { BaseChannel } from './base.channel.js';
import type { NotificationPayload, ChannelDeliveryResult } from '../types.js';
import { prisma } from '../../../config/database.js';
import { env } from '../../../config/env.js';
import { logger } from '../../../config/logger.js';

export class PushChannel extends BaseChannel {
  name = 'push';
  private snsClient: SNSClient;

  constructor() {
    super();
    const config: any = { region: env.AWS_REGION };
    if (env.AWS_ACCESS_KEY_ID && env.AWS_SECRET_ACCESS_KEY) {
      config.credentials = {
        accessKeyId: env.AWS_ACCESS_KEY_ID,
        secretAccessKey: env.AWS_SECRET_ACCESS_KEY
      };
    }
    this.snsClient = new SNSClient(config);
  }

  supportsInteractivity(): boolean {
    return false;  // Push notifications trigger app open
  }

  async send(payload: NotificationPayload): Promise<ChannelDeliveryResult> {
    return this.withErrorHandling(async () => {
      // Get user's registered devices
      const devices = await prisma.userDevice.findMany({
        where: { userId: payload.userId }
      });

      if (devices.length === 0) {
        return { success: false, error: 'No registered devices for user' };
      }

      const isCritical = payload.priority === 'CRITICAL' || payload.priority === 'HIGH';
      const results: string[] = [];
      const errors: string[] = [];

      for (const device of devices) {
        try {
          // Get or create platform endpoint
          const endpointArn = await this.getOrCreateEndpoint(device);

          // Build platform-specific message
          const message = this.buildPushMessage(payload, device.platform, isCritical);

          // Publish to endpoint
          const result = await this.snsClient.send(new PublishCommand({
            TargetArn: endpointArn,
            Message: JSON.stringify(message),
            MessageStructure: 'json'
          }));

          if (result.MessageId) {
            results.push(`${device.platform}:${result.MessageId}`);
          }

          // Update last seen
          await prisma.userDevice.update({
            where: { id: device.id },
            data: { lastSeenAt: new Date() }
          });

          logger.info(
            { channel: 'push', platform: device.platform, incidentId: payload.incidentId, messageId: result.MessageId },
            'Push notification sent'
          );
        } catch (error) {
          const msg = error instanceof Error ? error.message : 'Unknown error';
          errors.push(`${device.platform}: ${msg}`);
          logger.warn(
            { channel: 'push', platform: device.platform, incidentId: payload.incidentId, error: msg },
            'Push notification failed for device'
          );
        }
      }

      if (results.length === 0) {
        return { success: false, error: errors.join('; ') };
      }

      return {
        success: true,
        providerId: results.join(','),
        deliveredAt: new Date()
      };
    }, { incidentId: payload.incidentId, userId: payload.userId });
  }

  // Get existing endpoint or create new one
  private async getOrCreateEndpoint(device: { platform: string; deviceToken: string }): Promise<string> {
    const platformAppArn = device.platform === 'ios'
      ? env.SNS_PLATFORM_APP_ARN_IOS
      : env.SNS_PLATFORM_APP_ARN_ANDROID;

    if (!platformAppArn) {
      throw new Error(`Platform app ARN not configured for ${device.platform}`);
    }

    const result = await this.snsClient.send(new CreatePlatformEndpointCommand({
      PlatformApplicationArn: platformAppArn,
      Token: device.deviceToken
    }));

    if (!result.EndpointArn) {
      throw new Error('Failed to create SNS endpoint');
    }

    return result.EndpointArn;
  }

  // Build platform-specific push payload
  // Per user decision: critical incidents override DND
  private buildPushMessage(payload: NotificationPayload, platform: string, isCritical: boolean): any {
    const title = `[${payload.priority}] ${payload.service}`;
    const body = payload.title;

    const message: any = {
      default: body
    };

    if (platform === 'ios') {
      // iOS-specific payload with critical alert (per user decision)
      message.APNS = JSON.stringify({
        aps: {
          alert: {
            title: title,
            body: body,
            subtitle: `Incident #${payload.incidentId.slice(-8)}`
          },
          sound: isCritical ? {
            critical: 1,                    // iOS critical alert
            name: 'critical-alert.wav',
            volume: 1.0
          } : 'default',
          badge: 1,
          'interruption-level': isCritical ? 'critical' : 'active',
          'relevance-score': isCritical ? 1.0 : 0.5
        },
        incidentId: payload.incidentId,
        priority: payload.priority,
        action: 'view_incident'
      });
    } else if (platform === 'android') {
      // Android-specific payload with high-priority channel (per user decision)
      message.GCM = JSON.stringify({
        notification: {
          title: title,
          body: body,
          channel_id: isCritical ? 'critical_alerts' : 'default',
          priority: isCritical ? 'high' : 'default',
          sound: 'default',
          click_action: 'VIEW_INCIDENT'
        },
        data: {
          incidentId: payload.incidentId,
          priority: payload.priority,
          service: payload.service
        },
        android: {
          priority: isCritical ? 'high' : 'normal',
          notification: {
            channel_id: isCritical ? 'critical_alerts' : 'default',
            notification_priority: isCritical ? 'PRIORITY_MAX' : 'PRIORITY_DEFAULT'
          }
        }
      });
    }

    return message;
  }
}

export const pushChannel = new PushChannel();
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/channels/push.channel.ts</verify>
  <done>Push channel sends iOS/Android notifications with critical alert support</done>
</task>

<task type="auto">
  <name>Task 3: Create TwiML templates and voice channel</name>
  <files>src/services/notification/templates/twiml.templates.ts, src/services/notification/channels/voice.channel.ts</files>
  <action>
1. Create `src/services/notification/templates/twiml.templates.ts`:
```typescript
import type { NotificationPayload } from '../types.js';

// Build initial call TwiML (per user decision: TTS with keypress menu)
// Press 1 to acknowledge, press 2 for details, press 9 to escalate
export function buildIncidentCallTwiml(payload: NotificationPayload, baseUrl: string): string {
  const shortId = payload.incidentId.slice(-6);
  const escalationText = payload.escalationLevel
    ? `This is escalation level ${payload.escalationLevel}. `
    : '';

  return `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Gather numDigits="1" action="${baseUrl}/webhooks/twilio/voice/incident/${payload.incidentId}/input" timeout="10">
    <Say voice="alice">
      ${escalationText}${payload.priority} incident for ${sanitizeForTts(payload.service)}.
      ${sanitizeForTts(payload.title)}.
      Press 1 to acknowledge.
      Press 2 to hear details.
      Press 9 to escalate.
    </Say>
  </Gather>
  <Say voice="alice">We did not receive any input. Goodbye.</Say>
</Response>`;
}

// Build TwiML for keypress response
export function buildKeypadResponseTwiml(
  action: 'acknowledge' | 'details' | 'escalate' | 'invalid',
  payload: NotificationPayload,
  baseUrl: string
): string {
  switch (action) {
    case 'acknowledge':
      return `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Incident ${payload.incidentId.slice(-6)} has been acknowledged. Thank you.</Say>
</Response>`;

    case 'details':
      return `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Gather numDigits="1" action="${baseUrl}/webhooks/twilio/voice/incident/${payload.incidentId}/input" timeout="10">
    <Say voice="alice">
      ${sanitizeForTts(payload.body)}.
      Alert count: ${payload.alertCount}.
      Press 1 to acknowledge, or hang up.
    </Say>
  </Gather>
  <Say voice="alice">Goodbye.</Say>
</Response>`;

    case 'escalate':
      return `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Escalating to next level. Goodbye.</Say>
</Response>`;

    case 'invalid':
    default:
      return `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Invalid input. Goodbye.</Say>
</Response>`;
  }
}

// Sanitize text for TTS (remove special chars that confuse TTS)
function sanitizeForTts(text: string): string {
  return text
    .replace(/[<>&'"]/g, '')           // Remove XML special chars
    .replace(/[_\-\.]+/g, ' ')          // Replace common separators with spaces
    .replace(/\s+/g, ' ')               // Collapse whitespace
    .trim()
    .substring(0, 500);                 // Limit length for TTS
}
```

2. Create `src/services/notification/channels/voice.channel.ts`:
```typescript
import twilio from 'twilio';
import { BaseChannel } from './base.channel.js';
import type { NotificationPayload, ChannelDeliveryResult } from '../types.js';
import { buildIncidentCallTwiml } from '../templates/twiml.templates.js';
import { prisma } from '../../../config/database.js';
import { env } from '../../../config/env.js';
import { logger } from '../../../config/logger.js';

export class VoiceChannel extends BaseChannel {
  name = 'voice';
  private twilioClient: ReturnType<typeof twilio>;

  constructor() {
    super();
    this.twilioClient = twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);
  }

  supportsInteractivity(): boolean {
    return true;  // IVR keypress
  }

  async send(payload: NotificationPayload): Promise<ChannelDeliveryResult> {
    return this.withErrorHandling(async () => {
      // Get user phone
      const user = await prisma.user.findUnique({
        where: { id: payload.userId },
        select: { phone: true, phoneVerified: true }
      });

      if (!user?.phone) {
        return { success: false, error: 'User phone not found' };
      }

      if (!user.phoneVerified) {
        return { success: false, error: 'User phone not verified' };
      }

      // Store payload temporarily for webhook handler (expires in 10 min)
      // In production, use Redis. For now, we'll use in-memory cache
      // and the webhook will re-fetch from database.

      const baseUrl = env.API_BASE_URL || 'http://localhost:3000';

      // Initiate call with TwiML URL
      const call = await this.twilioClient.calls.create({
        to: user.phone,
        from: env.TWILIO_PHONE_NUMBER,
        url: `${baseUrl}/webhooks/twilio/voice/incident/${payload.incidentId}`,
        statusCallback: `${baseUrl}/webhooks/twilio/voice/status`,
        statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'],
        timeout: 30,  // Ring for 30 seconds
        machineDetection: 'Enable'  // Detect voicemail
      });

      logger.info(
        { channel: 'voice', incidentId: payload.incidentId, userId: payload.userId, callSid: call.sid },
        'Voice call initiated'
      );

      return {
        success: true,
        providerId: call.sid,
        deliveredAt: new Date()  // Call initiated, actual delivery depends on answer
      };
    }, { incidentId: payload.incidentId, userId: payload.userId });
  }

  // Get provider health status
  async getProviderStatus(): Promise<{ healthy: boolean; latencyMs?: number }> {
    const start = Date.now();
    try {
      await this.twilioClient.api.accounts(env.TWILIO_ACCOUNT_SID).fetch();
      return {
        healthy: true,
        latencyMs: Date.now() - start
      };
    } catch {
      return { healthy: false };
    }
  }
}

export const voiceChannel = new VoiceChannel();
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/templates/twiml.templates.ts src/services/notification/channels/voice.channel.ts</verify>
  <done>Voice channel initiates calls with TwiML IVR for keypress acknowledgment</done>
</task>

</tasks>

<verification>
- AWS SNS SDK installed
- Push notifications include platform-specific payloads
- iOS critical alerts use interruption-level: critical (per user decision)
- Android high-priority channel used for critical incidents
- TwiML templates produce valid XML with Gather/Say elements
- Voice calls use IVR menu: 1=acknowledge, 2=details, 9=escalate (per user decision)
- TypeScript compiles without errors
</verification>

<success_criteria>
1. Push notifications override DND for CRITICAL/HIGH priority (per user decision)
2. iOS uses critical alerts with interruption-level: critical
3. Android uses high-priority notification channel
4. Voice calls use TTS with keypress menu (per user decision)
5. IVR: Press 1 to acknowledge, Press 2 for details, Press 9 to escalate
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-05-SUMMARY.md`
</output>

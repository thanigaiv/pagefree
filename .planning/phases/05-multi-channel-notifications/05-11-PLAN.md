---
phase: 05-multi-channel-notifications
plan: 11
type: execute
wave: 4
depends_on: [05-09, 05-10]
files_modified:
  - src/tests/notification.test.ts
  - src/tests/notification-integration.test.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests verify channel implementations"
    - "Unit tests verify delivery tracking"
    - "Integration tests verify end-to-end notification flow"
    - "Tests mock external providers (Twilio, Slack, Teams, SES, SNS)"
  artifacts:
    - path: "src/tests/notification.test.ts"
      provides: "Unit tests for notification channels and dispatcher"
      contains: "describe"
    - path: "src/tests/notification-integration.test.ts"
      provides: "Integration tests for notification flow"
      contains: "describe"
  key_links:
    - from: "notification.test.ts"
      to: "channel implementations"
      via: "mocked providers"
      pattern: "vi\\.mock"
---

<objective>
Test coverage for notification system

Purpose: Comprehensive test coverage for the notification system including channel implementations, dispatcher logic, delivery tracking, and end-to-end flow. Tests mock external providers to run without real credentials.

Output: Unit tests and integration tests achieving coverage of critical notification paths
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@src/tests/setup.ts
@src/tests/incident.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for notification components</name>
  <files>src/tests/notification.test.ts</files>
  <action>
Create `src/tests/notification.test.ts`:
```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { prisma } from '../config/database.js';

// Mock external dependencies before imports
vi.mock('@aws-sdk/client-ses', () => ({
  SESClient: vi.fn().mockImplementation(() => ({
    send: vi.fn().mockResolvedValue({ MessageId: 'ses-123' })
  })),
  SendEmailCommand: vi.fn()
}));

vi.mock('twilio', () => ({
  default: vi.fn().mockReturnValue({
    messages: {
      create: vi.fn().mockResolvedValue({ sid: 'twilio-msg-123' })
    },
    calls: {
      create: vi.fn().mockResolvedValue({ sid: 'twilio-call-123' })
    },
    api: {
      accounts: vi.fn().mockReturnValue({
        fetch: vi.fn().mockResolvedValue({})
      })
    }
  })
}));

vi.mock('@slack/web-api', () => ({
  WebClient: vi.fn().mockImplementation(() => ({
    chat: {
      postMessage: vi.fn().mockResolvedValue({ ts: '1234567890.123456' }),
      update: vi.fn().mockResolvedValue({ ok: true })
    },
    auth: {
      test: vi.fn().mockResolvedValue({ ok: true })
    }
  }))
}));

vi.mock('@aws-sdk/client-sns', () => ({
  SNSClient: vi.fn().mockImplementation(() => ({
    send: vi.fn().mockResolvedValue({ MessageId: 'sns-123' })
  })),
  PublishCommand: vi.fn(),
  CreatePlatformEndpointCommand: vi.fn()
}));

import { deliveryTracker } from '../services/notification/delivery-tracker.js';
import {
  buildIncidentEmailSubject,
  buildIncidentEmailHtml
} from '../services/notification/templates/email.templates.js';
import { buildSlackIncidentBlocks } from '../services/notification/templates/slack.templates.js';
import type { NotificationPayload } from '../services/notification/types.js';

// Test fixtures
const testUser = {
  id: 'user-test-1',
  email: 'test@example.com',
  firstName: 'Test',
  lastName: 'User',
  phone: '+15551234567',
  isActive: true,
  phoneVerified: true,
  emailVerified: true
};

const testIncident = {
  id: 'incident-test-1',
  priority: 'CRITICAL',
  status: 'OPEN',
  alertCount: 1,
  fingerprint: 'test-fp',
  teamId: 'team-test-1',
  escalationPolicyId: 'policy-test-1'
};

const testPayload: NotificationPayload = {
  incidentId: 'incident-test-1',
  userId: 'user-test-1',
  title: 'High CPU Usage on web-server-01',
  body: 'CPU usage exceeded 95% threshold for 5 minutes',
  priority: 'CRITICAL',
  service: 'payments-api',
  teamName: 'Platform Team',
  alertCount: 3,
  dashboardUrl: 'http://localhost:3000',
  triggeredAt: new Date('2026-02-08T10:00:00Z')
};

describe('Notification System', () => {
  beforeEach(async () => {
    // Clean up test data
    await prisma.notificationLog.deleteMany({ where: { incidentId: { contains: 'test' } } });
    await prisma.magicLinkToken.deleteMany({ where: { incidentId: { contains: 'test' } } });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('Email Templates', () => {
    it('should build email subject with priority', () => {
      const subject = buildIncidentEmailSubject(testPayload);
      expect(subject).toContain('[CRITICAL]');
      expect(subject).toContain('payments-api');
      expect(subject).toContain('High CPU Usage');
    });

    it('should include escalation level in subject when present', () => {
      const payloadWithEscalation = { ...testPayload, escalationLevel: 2 };
      const subject = buildIncidentEmailSubject(payloadWithEscalation);
      expect(subject).toContain('[ESCALATION - Level 2]');
    });

    it('should build HTML email with all required fields', () => {
      const html = buildIncidentEmailHtml({
        ...testPayload,
        ackUrl: 'http://localhost:3000/magic/ack/123/token',
        resolveUrl: 'http://localhost:3000/magic/resolve/123/token'
      });

      expect(html).toContain('CRITICAL');
      expect(html).toContain('payments-api');
      expect(html).toContain('High CPU Usage');
      expect(html).toContain('Platform Team');
      expect(html).toContain('3 alerts');
      expect(html).toContain('Acknowledge Incident');
      expect(html).toContain('Resolve Incident');
    });
  });

  describe('Slack Templates', () => {
    it('should build Block Kit message with action buttons', () => {
      const message = buildSlackIncidentBlocks(testPayload);

      expect(message.text).toContain('[CRITICAL]');
      expect(message.attachments).toHaveLength(1);

      const blocks = message.attachments[0].blocks;
      const actionsBlock = blocks.find((b: any) => b.type === 'actions');

      expect(actionsBlock).toBeDefined();
      expect(actionsBlock.elements).toHaveLength(3);  // Acknowledge, Resolve, View Dashboard
    });

    it('should use correct color for priority', () => {
      const message = buildSlackIncidentBlocks(testPayload);
      expect(message.attachments[0].color).toBe('#ff0000');  // Red for CRITICAL
    });
  });

  describe('SMS Format', () => {
    it('should stay within 160 character limit', () => {
      const longTitle = 'A'.repeat(200);
      const payload = { ...testPayload, title: longTitle };

      // The SMS builder should truncate
      const smsBuilder = (p: NotificationPayload) => {
        const shortId = p.incidentId.slice(-6);
        const prefix = `[${p.priority}]`;
        const suffix = `. Incident #${shortId} - Reply ACK`;
        const overhead = prefix.length + 1 + p.service.length + 2 + suffix.length;
        const availableChars = 160 - overhead;

        let title = p.title;
        if (title.length > availableChars) {
          title = title.substring(0, availableChars - 3) + '...';
        }

        return `${prefix} ${p.service}: ${title}${suffix}`;
      };

      const sms = smsBuilder(payload);
      expect(sms.length).toBeLessThanOrEqual(160);
    });

    it('should format as [PRIORITY] service: message. Incident #ID - Reply ACK', () => {
      const smsBuilder = (p: NotificationPayload) => {
        const shortId = p.incidentId.slice(-6);
        return `[${p.priority}] ${p.service}: ${p.title}. Incident #${shortId} - Reply ACK`;
      };

      const sms = smsBuilder(testPayload);
      expect(sms).toMatch(/^\[CRITICAL\] payments-api:/);
      expect(sms).toContain('Reply ACK');
    });
  });

  describe('Delivery Tracker', () => {
    it('should create QUEUED status entry', async () => {
      // Create test incident first
      const team = await prisma.team.upsert({
        where: { name: 'Test Team Notif' },
        create: { id: 'team-notif-test', name: 'Test Team Notif' },
        update: {}
      });

      const policy = await prisma.escalationPolicy.upsert({
        where: { id: 'policy-notif-test' },
        create: {
          id: 'policy-notif-test',
          name: 'Test Policy',
          teamId: team.id
        },
        update: {}
      });

      const incident = await prisma.incident.create({
        data: {
          id: 'incident-notif-test-1',
          fingerprint: 'test-notif-fp',
          teamId: team.id,
          escalationPolicyId: policy.id,
          status: 'OPEN',
          priority: 'HIGH'
        }
      });

      const user = await prisma.user.upsert({
        where: { email: 'notif-test@example.com' },
        create: {
          id: 'user-notif-test-1',
          email: 'notif-test@example.com',
          firstName: 'Notif',
          lastName: 'Test'
        },
        update: {}
      });

      const logId = await deliveryTracker.trackQueued(
        incident.id,
        user.id,
        'email',
        1
      );

      expect(logId).toBeDefined();

      const log = await prisma.notificationLog.findUnique({
        where: { id: logId }
      });

      expect(log).toBeDefined();
      expect(log?.status).toBe('QUEUED');
      expect(log?.channel).toBe('EMAIL');
      expect(log?.escalationLevel).toBe(1);

      // Cleanup
      await prisma.notificationLog.delete({ where: { id: logId } });
      await prisma.incident.delete({ where: { id: incident.id } });
    });

    it('should track status transitions', async () => {
      // Create test data
      const team = await prisma.team.upsert({
        where: { name: 'Test Team Notif 2' },
        create: { id: 'team-notif-test-2', name: 'Test Team Notif 2' },
        update: {}
      });

      const policy = await prisma.escalationPolicy.upsert({
        where: { id: 'policy-notif-test-2' },
        create: {
          id: 'policy-notif-test-2',
          name: 'Test Policy 2',
          teamId: team.id
        },
        update: {}
      });

      const incident = await prisma.incident.create({
        data: {
          id: 'incident-notif-test-2',
          fingerprint: 'test-notif-fp-2',
          teamId: team.id,
          escalationPolicyId: policy.id,
          status: 'OPEN',
          priority: 'HIGH'
        }
      });

      const user = await prisma.user.upsert({
        where: { email: 'notif-test-2@example.com' },
        create: {
          id: 'user-notif-test-2',
          email: 'notif-test-2@example.com',
          firstName: 'Notif',
          lastName: 'Test2'
        },
        update: {}
      });

      // Track through lifecycle
      const logId = await deliveryTracker.trackQueued(incident.id, user.id, 'sms');
      await deliveryTracker.trackSending(logId);
      await deliveryTracker.trackSent(logId, 'provider-123');
      await deliveryTracker.trackDelivered(logId);

      const finalLog = await prisma.notificationLog.findUnique({
        where: { id: logId }
      });

      expect(finalLog?.status).toBe('DELIVERED');
      expect(finalLog?.providerId).toBe('provider-123');
      expect(finalLog?.deliveredAt).toBeDefined();

      // Cleanup
      await prisma.notificationLog.delete({ where: { id: logId } });
      await prisma.incident.delete({ where: { id: incident.id } });
    });
  });

  describe('Magic Link Tokens', () => {
    it('should hash tokens for storage', async () => {
      const crypto = await import('crypto');
      const token = crypto.randomBytes(32).toString('hex');
      const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

      expect(tokenHash).not.toBe(token);
      expect(tokenHash).toHaveLength(64);  // SHA-256 produces 64 hex chars
    });

    it('should verify token expiration', () => {
      const now = new Date();
      const fifteenMinAgo = new Date(now.getTime() - 16 * 60 * 1000);
      const inFiveMin = new Date(now.getTime() + 5 * 60 * 1000);

      expect(fifteenMinAgo < now).toBe(true);  // Expired
      expect(inFiveMin > now).toBe(true);      // Valid
    });
  });
});
```
  </action>
  <verify>npm test -- --run notification.test</verify>
  <done>Unit tests verify templates, delivery tracking, and SMS format</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for notification flow</name>
  <files>src/tests/notification-integration.test.ts</files>
  <action>
Create `src/tests/notification-integration.test.ts`:
```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { prisma } from '../config/database.js';

// Mock all external services
vi.mock('@aws-sdk/client-ses', () => ({
  SESClient: vi.fn().mockImplementation(() => ({
    send: vi.fn().mockResolvedValue({ MessageId: 'ses-int-123' })
  })),
  SendEmailCommand: vi.fn()
}));

vi.mock('twilio', () => ({
  default: vi.fn().mockReturnValue({
    messages: {
      create: vi.fn().mockResolvedValue({ sid: 'twilio-int-123' })
    },
    calls: {
      create: vi.fn().mockResolvedValue({ sid: 'twilio-call-int-123' })
    },
    api: {
      accounts: vi.fn().mockReturnValue({
        fetch: vi.fn().mockResolvedValue({})
      })
    },
    validateRequest: vi.fn().mockReturnValue(true)
  })
}));

vi.mock('@slack/web-api', () => ({
  WebClient: vi.fn().mockImplementation(() => ({
    chat: {
      postMessage: vi.fn().mockResolvedValue({ ts: '1234567890.123456', ok: true }),
      update: vi.fn().mockResolvedValue({ ok: true })
    },
    auth: {
      test: vi.fn().mockResolvedValue({ ok: true })
    }
  }))
}));

vi.mock('@aws-sdk/client-sns', () => ({
  SNSClient: vi.fn().mockImplementation(() => ({
    send: vi.fn().mockResolvedValue({ MessageId: 'sns-int-123', EndpointArn: 'arn:aws:sns:us-east-1:123:endpoint' })
  })),
  PublishCommand: vi.fn(),
  CreatePlatformEndpointCommand: vi.fn()
}));

// Mock Redis for queue tests
vi.mock('ioredis', () => ({
  default: vi.fn().mockImplementation(() => ({
    on: vi.fn(),
    connect: vi.fn(),
    disconnect: vi.fn(),
    quit: vi.fn()
  }))
}));

describe('Notification Integration', () => {
  let testTeam: any;
  let testUser: any;
  let testPolicy: any;
  let testIncident: any;

  beforeEach(async () => {
    // Create test fixtures
    testTeam = await prisma.team.upsert({
      where: { name: 'Integration Test Team' },
      create: {
        id: 'team-int-test',
        name: 'Integration Test Team',
        slackChannel: '#test-alerts'
      },
      update: {}
    });

    testUser = await prisma.user.upsert({
      where: { email: 'int-test@example.com' },
      create: {
        id: 'user-int-test',
        email: 'int-test@example.com',
        firstName: 'Integration',
        lastName: 'Test',
        phone: '+15551234567',
        phoneVerified: true,
        emailVerified: true
      },
      update: {}
    });

    // Create notification preferences
    await prisma.notificationPreference.upsert({
      where: { userId_channel: { userId: testUser.id, channel: 'EMAIL' } },
      create: { userId: testUser.id, channel: 'EMAIL', enabled: true, priority: 1 },
      update: {}
    });

    await prisma.notificationPreference.upsert({
      where: { userId_channel: { userId: testUser.id, channel: 'SMS' } },
      create: { userId: testUser.id, channel: 'SMS', enabled: true, priority: 2 },
      update: {}
    });

    testPolicy = await prisma.escalationPolicy.upsert({
      where: { id: 'policy-int-test' },
      create: {
        id: 'policy-int-test',
        name: 'Integration Test Policy',
        teamId: testTeam.id
      },
      update: {}
    });

    testIncident = await prisma.incident.create({
      data: {
        id: 'incident-int-' + Date.now(),
        fingerprint: 'int-test-fp-' + Date.now(),
        teamId: testTeam.id,
        escalationPolicyId: testPolicy.id,
        status: 'OPEN',
        priority: 'HIGH',
        alertCount: 1,
        assignedUserId: testUser.id
      }
    });
  });

  afterEach(async () => {
    vi.clearAllMocks();

    // Cleanup in correct order (respecting foreign keys)
    if (testIncident) {
      await prisma.notificationLog.deleteMany({ where: { incidentId: testIncident.id } });
      await prisma.magicLinkToken.deleteMany({ where: { incidentId: testIncident.id } });
      await prisma.incident.delete({ where: { id: testIncident.id } }).catch(() => {});
    }
  });

  describe('Notification Dispatch', () => {
    it('should create notification logs for enabled channels', async () => {
      // Import after mocks are set up
      const { deliveryTracker } = await import('../services/notification/delivery-tracker.js');

      // Track notifications for user's enabled channels
      const emailLogId = await deliveryTracker.trackQueued(testIncident.id, testUser.id, 'email');
      const smsLogId = await deliveryTracker.trackQueued(testIncident.id, testUser.id, 'sms');

      // Verify logs created
      const logs = await prisma.notificationLog.findMany({
        where: { incidentId: testIncident.id }
      });

      expect(logs).toHaveLength(2);
      expect(logs.map(l => l.channel)).toContain('EMAIL');
      expect(logs.map(l => l.channel)).toContain('SMS');
    });

    it('should track delivery status through lifecycle', async () => {
      const { deliveryTracker } = await import('../services/notification/delivery-tracker.js');

      const logId = await deliveryTracker.trackQueued(testIncident.id, testUser.id, 'email');

      // Simulate delivery lifecycle
      await deliveryTracker.trackSending(logId);
      let log = await prisma.notificationLog.findUnique({ where: { id: logId } });
      expect(log?.status).toBe('SENDING');
      expect(log?.attemptCount).toBe(1);

      await deliveryTracker.trackSent(logId, 'ses-123');
      log = await prisma.notificationLog.findUnique({ where: { id: logId } });
      expect(log?.status).toBe('SENT');
      expect(log?.providerId).toBe('ses-123');

      await deliveryTracker.trackDelivered(logId);
      log = await prisma.notificationLog.findUnique({ where: { id: logId } });
      expect(log?.status).toBe('DELIVERED');
      expect(log?.deliveredAt).toBeDefined();
    });
  });

  describe('Magic Links', () => {
    it('should create and validate magic link tokens', async () => {
      const crypto = await import('crypto');

      const token = crypto.randomBytes(32).toString('hex');
      const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

      // Create token
      await prisma.magicLinkToken.create({
        data: {
          tokenHash,
          incidentId: testIncident.id,
          action: 'acknowledge',
          expiresAt: new Date(Date.now() + 15 * 60 * 1000)
        }
      });

      // Verify token exists and is valid
      const foundToken = await prisma.magicLinkToken.findUnique({
        where: { tokenHash }
      });

      expect(foundToken).toBeDefined();
      expect(foundToken?.used).toBe(false);
      expect(foundToken?.expiresAt.getTime()).toBeGreaterThan(Date.now());
    });

    it('should mark token as used after consumption', async () => {
      const crypto = await import('crypto');

      const token = crypto.randomBytes(32).toString('hex');
      const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

      const magicToken = await prisma.magicLinkToken.create({
        data: {
          tokenHash,
          incidentId: testIncident.id,
          action: 'acknowledge',
          expiresAt: new Date(Date.now() + 15 * 60 * 1000)
        }
      });

      // Mark as used
      await prisma.magicLinkToken.update({
        where: { id: magicToken.id },
        data: { used: true, usedAt: new Date() }
      });

      const updatedToken = await prisma.magicLinkToken.findUnique({
        where: { id: magicToken.id }
      });

      expect(updatedToken?.used).toBe(true);
      expect(updatedToken?.usedAt).toBeDefined();
    });
  });

  describe('Channel Escalation', () => {
    it('should detect when critical channels fail', async () => {
      const { deliveryTracker } = await import('../services/notification/delivery-tracker.js');

      // Track both email and SMS as failed
      const emailLogId = await deliveryTracker.trackQueued(testIncident.id, testUser.id, 'email');
      const smsLogId = await deliveryTracker.trackQueued(testIncident.id, testUser.id, 'sms');

      await deliveryTracker.trackFailed(emailLogId, 'Email delivery failed');
      await deliveryTracker.trackFailed(smsLogId, 'SMS delivery failed');

      // Check if critical channels failed
      const criticalFailed = await deliveryTracker.checkCriticalChannelsFailed(
        testIncident.id,
        testUser.id
      );

      expect(criticalFailed).toBe(true);
    });

    it('should not flag critical failure if only one channel fails', async () => {
      const { deliveryTracker } = await import('../services/notification/delivery-tracker.js');

      // Only email fails
      const emailLogId = await deliveryTracker.trackQueued(testIncident.id, testUser.id, 'email');
      const smsLogId = await deliveryTracker.trackQueued(testIncident.id, testUser.id, 'sms');

      await deliveryTracker.trackFailed(emailLogId, 'Email delivery failed');
      await deliveryTracker.trackSent(smsLogId, 'sms-123');

      const criticalFailed = await deliveryTracker.checkCriticalChannelsFailed(
        testIncident.id,
        testUser.id
      );

      expect(criticalFailed).toBe(false);
    });
  });
});
```
  </action>
  <verify>npm test -- --run notification-integration.test</verify>
  <done>Integration tests verify end-to-end notification flow with mocked providers</done>
</task>

</tasks>

<verification>
- Unit tests pass with mocked providers
- Integration tests verify database operations
- Tests cover email templates, SMS formatting, delivery tracking
- Tests verify magic link token lifecycle
- Tests verify channel escalation logic
- All tests run without real external service calls
</verification>

<success_criteria>
1. Unit tests verify template generation for all channels
2. Unit tests verify SMS 160-character limit handling
3. Integration tests verify notification log creation and status transitions
4. Integration tests verify magic link token creation and validation
5. Integration tests verify channel escalation detection
6. All tests pass with `npm test`
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-11-SUMMARY.md`
</output>

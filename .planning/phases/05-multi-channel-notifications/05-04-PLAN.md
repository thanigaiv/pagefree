---
phase: 05-multi-channel-notifications
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/notification/channels/teams.channel.ts
  - src/services/notification/templates/teams.templates.ts
autonomous: true
user_setup:
  - service: microsoft_teams
    why: "Teams bot for sending notifications and receiving card actions"
    env_vars:
      - name: TEAMS_APP_ID
        source: "Azure Portal -> App registrations -> Application (client) ID"
      - name: TEAMS_APP_SECRET
        source: "Azure Portal -> App registrations -> Certificates & secrets -> New client secret"
      - name: TEAMS_TENANT_ID
        source: "Azure Portal -> App registrations -> Directory (tenant) ID"
    dashboard_config:
      - task: "Register Azure AD app"
        location: "Azure Portal -> Azure Active Directory -> App registrations -> New registration"
      - task: "Add API permissions: Microsoft Graph -> Application -> ChannelMessage.Send, Chat.Create"
        location: "App -> API permissions -> Add a permission"
      - task: "Create client secret"
        location: "App -> Certificates & secrets -> New client secret"
      - task: "Create Teams bot via Bot Framework"
        location: "Azure Portal -> Create Bot Channels Registration"

must_haves:
  truths:
    - "System sends Teams Adaptive Cards with priority styling"
    - "Teams messages include Acknowledge and Resolve action buttons"
    - "System mirrors Slack interaction model for consistency"
  artifacts:
    - path: "src/services/notification/channels/teams.channel.ts"
      provides: "Teams channel implementation via Microsoft Graph"
      exports: ["TeamsChannel"]
    - path: "src/services/notification/templates/teams.templates.ts"
      provides: "Adaptive Card message builders"
      exports: ["buildTeamsIncidentCard"]
  key_links:
    - from: "TeamsChannel.send"
      to: "Microsoft Graph chat.sendMessage"
      via: "graphClient.api"
      pattern: "graphClient.*api"
---

<objective>
Microsoft Teams channel implementation with Adaptive Cards

Purpose: Implement NOTIF-03 (Teams notifications) with Adaptive Cards that mirror Slack's interaction model. Cards include inline action buttons and priority-based styling for consistency across platforms per user decision.

Output: TeamsChannel class implementing NotificationChannel interface; Adaptive Card template builders
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@.planning/phases/05-multi-channel-notifications/05-RESEARCH.md
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Teams env configuration</name>
  <files>src/config/env.ts</files>
  <action>
Add Teams configuration to `src/config/env.ts`:
```typescript
// Add to existing env object exports:
export const env = {
  // ... existing env vars ...

  // Microsoft Teams configuration
  TEAMS_APP_ID: process.env.TEAMS_APP_ID || '',
  TEAMS_APP_SECRET: process.env.TEAMS_APP_SECRET || '',
  TEAMS_TENANT_ID: process.env.TEAMS_TENANT_ID || '',
};
```

Verify env.ts includes TEAMS_APP_ID, TEAMS_APP_SECRET, TEAMS_TENANT_ID.
  </action>
  <verify>grep -q "TEAMS_APP_ID" src/config/env.ts && grep -q "TEAMS_TENANT_ID" src/config/env.ts</verify>
  <done>Teams env configuration added</done>
</task>

<task type="auto">
  <name>Task 2: Create Teams Adaptive Card templates</name>
  <files>src/services/notification/templates/teams.templates.ts</files>
  <action>
Create `src/services/notification/templates/teams.templates.ts`:
```typescript
import type { NotificationPayload } from '../types.js';

// Priority style mapping for Adaptive Cards
const PRIORITY_STYLES: Record<string, { color: string; style: string }> = {
  CRITICAL: { color: 'attention', style: 'emphasis' },
  HIGH: { color: 'warning', style: 'emphasis' },
  MEDIUM: { color: 'default', style: 'default' },
  LOW: { color: 'good', style: 'default' },
  INFO: { color: 'accent', style: 'default' }
};

// Build Adaptive Card for incident notification
export function buildTeamsIncidentCard(payload: NotificationPayload): any {
  const styling = PRIORITY_STYLES[payload.priority] || PRIORITY_STYLES.MEDIUM;
  const icon = payload.priority === 'CRITICAL' ? 'ðŸš¨ ' : '';
  const escalationText = payload.escalationLevel
    ? `**ESCALATION - Level ${payload.escalationLevel}**`
    : '';

  return {
    type: 'message',
    attachments: [{
      contentType: 'application/vnd.microsoft.card.adaptive',
      content: {
        $schema: 'http://adaptivecards.io/schemas/adaptive-card.json',
        type: 'AdaptiveCard',
        version: '1.5',
        body: [
          // Header container with priority styling
          {
            type: 'Container',
            style: styling.style,
            bleed: true,
            items: [
              {
                type: 'TextBlock',
                text: `${icon}${payload.title}`,
                size: 'Large',
                weight: 'Bolder',
                wrap: true,
                color: styling.color
              },
              // Escalation badge if applicable
              ...(payload.escalationLevel ? [{
                type: 'TextBlock',
                text: `âš ï¸ Escalation Level ${payload.escalationLevel}`,
                weight: 'Bolder',
                color: 'warning'
              }] : [])
            ]
          },
          // Incident details
          {
            type: 'FactSet',
            facts: [
              { title: 'Service', value: payload.service },
              { title: 'Priority', value: payload.priority },
              { title: 'Incident', value: `#${payload.incidentId.slice(-8)}` },
              { title: 'Triggered', value: formatTimestamp(payload.triggeredAt) },
              { title: 'Alerts', value: `${payload.alertCount} alert${payload.alertCount > 1 ? 's' : ''}` },
              { title: 'Team', value: payload.teamName }
            ]
          },
          // Alert message
          {
            type: 'Container',
            style: 'default',
            items: [
              {
                type: 'TextBlock',
                text: 'Alert Details',
                weight: 'Bolder',
                spacing: 'Medium'
              },
              {
                type: 'TextBlock',
                text: truncateForTeams(payload.body, 2000),
                wrap: true,
                fontType: 'Monospace',
                size: 'Small'
              }
            ]
          }
        ],
        actions: [
          {
            type: 'Action.Submit',
            title: 'Acknowledge',
            style: 'positive',
            data: {
              action: 'acknowledge',
              incidentId: payload.incidentId
            }
          },
          {
            type: 'Action.Submit',
            title: 'Resolve',
            style: 'destructive',
            data: {
              action: 'resolve',
              incidentId: payload.incidentId
            }
          },
          {
            type: 'Action.OpenUrl',
            title: 'View Dashboard',
            url: `${payload.dashboardUrl}/incidents/${payload.incidentId}`
          }
        ]
      }
    }]
  };
}

// Build card showing acknowledged state
export function buildTeamsAcknowledgedCard(
  incidentId: string,
  acknowledgedBy: string,
  acknowledgedAt: Date
): any {
  return {
    type: 'message',
    attachments: [{
      contentType: 'application/vnd.microsoft.card.adaptive',
      content: {
        $schema: 'http://adaptivecards.io/schemas/adaptive-card.json',
        type: 'AdaptiveCard',
        version: '1.5',
        body: [
          {
            type: 'TextBlock',
            text: `âœ… Incident #${incidentId.slice(-8)} acknowledged`,
            weight: 'Bolder',
            color: 'good'
          },
          {
            type: 'TextBlock',
            text: `Acknowledged by ${acknowledgedBy} at ${formatTimestamp(acknowledgedAt)}`,
            wrap: true
          }
        ]
      }
    }]
  };
}

// Build card showing resolved state
export function buildTeamsResolvedCard(
  incidentId: string,
  resolvedBy: string,
  resolvedAt: Date
): any {
  return {
    type: 'message',
    attachments: [{
      contentType: 'application/vnd.microsoft.card.adaptive',
      content: {
        $schema: 'http://adaptivecards.io/schemas/adaptive-card.json',
        type: 'AdaptiveCard',
        version: '1.5',
        body: [
          {
            type: 'TextBlock',
            text: `âœ… Incident #${incidentId.slice(-8)} resolved`,
            weight: 'Bolder',
            color: 'good'
          },
          {
            type: 'TextBlock',
            text: `Resolved by ${resolvedBy} at ${formatTimestamp(resolvedAt)}`,
            wrap: true
          }
        ]
      }
    }]
  };
}

function formatTimestamp(date: Date): string {
  return date.toLocaleString('en-US', {
    weekday: 'short',
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    timeZoneName: 'short'
  });
}

function truncateForTeams(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 20) + '\n... (truncated)';
}
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/templates/teams.templates.ts</verify>
  <done>Teams Adaptive Card templates build priority-styled cards with action buttons</done>
</task>

<task type="auto">
  <name>Task 3: Create Teams channel implementation</name>
  <files>src/services/notification/channels/teams.channel.ts</files>
  <action>
Create `src/services/notification/channels/teams.channel.ts`:
```typescript
import { Client } from '@microsoft/microsoft-graph-client';
import { ClientSecretCredential } from '@azure/identity';
import { BaseChannel } from './base.channel.js';
import type { NotificationPayload, ChannelDeliveryResult } from '../types.js';
import { buildTeamsIncidentCard } from '../templates/teams.templates.js';
import { prisma } from '../../../config/database.js';
import { env } from '../../../config/env.js';
import { logger } from '../../../config/logger.js';

export class TeamsChannel extends BaseChannel {
  name = 'teams';
  private graphClient: Client | null = null;

  constructor() {
    super();
    this.initializeClient();
  }

  private initializeClient(): void {
    if (!env.TEAMS_APP_ID || !env.TEAMS_APP_SECRET || !env.TEAMS_TENANT_ID) {
      logger.warn('Teams credentials not configured, Teams channel disabled');
      return;
    }

    try {
      const credential = new ClientSecretCredential(
        env.TEAMS_TENANT_ID,
        env.TEAMS_APP_ID,
        env.TEAMS_APP_SECRET
      );

      this.graphClient = Client.initWithMiddleware({
        authProvider: {
          getAccessToken: async () => {
            const token = await credential.getToken('https://graph.microsoft.com/.default');
            return token?.token || '';
          }
        }
      });
    } catch (error) {
      logger.error({ error }, 'Failed to initialize Teams Graph client');
    }
  }

  supportsInteractivity(): boolean {
    return true;  // Action.Submit buttons
  }

  async send(payload: NotificationPayload): Promise<ChannelDeliveryResult> {
    if (!this.graphClient) {
      return { success: false, error: 'Teams client not initialized' };
    }

    return this.withErrorHandling(async () => {
      // Get user's Teams connection
      const user = await prisma.user.findUnique({
        where: { id: payload.userId },
        include: { teamsConnection: true }
      });

      if (!user?.teamsConnection) {
        return { success: false, error: 'User has no Teams connection' };
      }

      if (!user.teamsConnection.isActive) {
        return { success: false, error: 'Teams connection is not active' };
      }

      // Build Adaptive Card
      const card = buildTeamsIncidentCard(payload);
      const results: string[] = [];

      // Send to user chat (1:1 with bot)
      // Note: Teams requires a chat to exist first. For proactive messaging,
      // we need the conversation ID from when user installed the app.
      try {
        // Create or get conversation with user
        const chat = await this.graphClient!.api('/chats')
          .post({
            chatType: 'oneOnOne',
            members: [
              {
                '@odata.type': '#microsoft.graph.aadUserConversationMember',
                roles: ['owner'],
                'user@odata.bind': `https://graph.microsoft.com/v1.0/users/${user.teamsConnection.teamsUserId}`
              }
            ]
          });

        // Send message to chat
        const message = await this.graphClient!.api(`/chats/${chat.id}/messages`)
          .post({
            body: {
              contentType: 'html',
              content: `<attachment id="card"></attachment>`
            },
            attachments: [{
              id: 'card',
              contentType: 'application/vnd.microsoft.card.adaptive',
              content: JSON.stringify(card.attachments[0].content)
            }]
          });

        if (message.id) {
          results.push(`chat:${message.id}`);
        }

        logger.info(
          { channel: 'teams', type: 'chat', incidentId: payload.incidentId, userId: payload.userId, messageId: message.id },
          'Teams chat message sent'
        );
      } catch (chatError) {
        logger.warn(
          { channel: 'teams', type: 'chat', incidentId: payload.incidentId, error: (chatError as Error).message },
          'Failed to send Teams chat message'
        );
      }

      // Update last used timestamp
      await prisma.teamsConnection.update({
        where: { id: user.teamsConnection.id },
        data: { lastUsedAt: new Date() }
      });

      // Consider success if at least one message sent
      if (results.length === 0) {
        return { success: false, error: 'Failed to send Teams message' };
      }

      return {
        success: true,
        providerId: results.join(','),
        deliveredAt: new Date()
      };
    }, { incidentId: payload.incidentId, userId: payload.userId });
  }

  // Get provider health status
  async getProviderStatus(): Promise<{ healthy: boolean; latencyMs?: number }> {
    if (!this.graphClient) {
      return { healthy: false };
    }

    const start = Date.now();
    try {
      await this.graphClient.api('/me').get();
      return {
        healthy: true,
        latencyMs: Date.now() - start
      };
    } catch {
      return { healthy: false };
    }
  }
}

export const teamsChannel = new TeamsChannel();
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/channels/teams.channel.ts</verify>
  <done>Teams channel sends Adaptive Cards with action buttons via Microsoft Graph</done>
</task>

</tasks>

<verification>
- Teams env vars added to config
- Adaptive Card templates produce valid card structures
- Cards include priority styling (color, emphasis)
- Action.Submit buttons for acknowledge and resolve
- Action.OpenUrl for dashboard link
- TypeScript compiles without errors
</verification>

<success_criteria>
1. Teams Adaptive Cards mirror Slack message structure for consistency (per user decision)
2. Cards include Acknowledge (positive) and Resolve (destructive) action buttons
3. Cards include View Dashboard link
4. Priority-based container styling applied
5. Escalation level shown when applicable
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-04-SUMMARY.md`
</output>

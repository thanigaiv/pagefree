---
phase: 05-multi-channel-notifications
plan: 08
type: execute
wave: 2
depends_on: [05-02, 05-05]
files_modified:
  - src/routes/webhooks/twilio-webhooks.ts
  - src/routes/magic-links.ts
  - src/services/notification/sms-reply.service.ts
autonomous: true

must_haves:
  truths:
    - "User can click magic link in email to acknowledge incident"
    - "User can click magic link in email to resolve incident"
    - "User can reply ACK to SMS to acknowledge incident"
    - "User can press 1 during voice call to acknowledge incident"
    - "Magic links expire after 15 minutes"
  artifacts:
    - path: "src/routes/magic-links.ts"
      provides: "Magic link token verification and action execution"
      exports: ["magicLinksRouter"]
    - path: "src/routes/webhooks/twilio-webhooks.ts"
      provides: "Twilio SMS reply and voice IVR handlers"
      exports: ["twilioWebhooksRouter"]
    - path: "src/services/notification/sms-reply.service.ts"
      provides: "SMS reply parsing and acknowledgment"
      exports: ["SMSReplyService"]
  key_links:
    - from: "magic-links.ts"
      to: "incidentService.acknowledge"
      via: "magicLinkToken validation"
      pattern: "incidentService\\.(acknowledge|resolve)"
    - from: "twilio-webhooks.ts"
      to: "incidentService.acknowledge"
      via: "SMS reply or IVR keypress"
      pattern: "incidentService\\.acknowledge"
---

<objective>
Magic link handlers and Twilio webhook handlers for interactive notifications

Purpose: Complete the interactive notification loop by handling magic link clicks (email), SMS reply parsing (text message), and voice IVR keypress responses. These enable bidirectional interaction across all intrusive channels.

Output: Magic link verification routes, Twilio SMS/voice webhook handlers
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-channel-notifications/05-CONTEXT.md
@.planning/phases/05-multi-channel-notifications/05-RESEARCH.md
@src/services/incident.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create magic link verification routes</name>
  <files>src/routes/magic-links.ts</files>
  <action>
Create `src/routes/magic-links.ts`:
```typescript
import crypto from 'crypto';
import { Router, Request, Response } from 'express';
import { prisma } from '../config/database.js';
import { incidentService } from '../services/incident.service.js';
import { auditService } from '../services/audit.service.js';
import { env } from '../config/env.js';
import { logger } from '../config/logger.js';

const router = Router();

// Handle acknowledge magic link
router.get('/ack/:incidentId/:token', async (req: Request, res: Response) => {
  await handleMagicLink(req, res, 'acknowledge');
});

// Handle resolve magic link
router.get('/resolve/:incidentId/:token', async (req: Request, res: Response) => {
  await handleMagicLink(req, res, 'resolve');
});

async function handleMagicLink(req: Request, res: Response, action: 'acknowledge' | 'resolve'): Promise<void> {
  const { incidentId, token } = req.params;
  const dashboardUrl = env.DASHBOARD_URL || 'http://localhost:3000';

  try {
    // Hash token for database lookup
    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

    // Find token
    const magicToken = await prisma.magicLinkToken.findUnique({
      where: { tokenHash },
      include: { incident: true }
    });

    // Validate token
    if (!magicToken) {
      logger.warn({ incidentId, tokenHash: tokenHash.slice(0, 8) }, 'Magic link token not found');
      return res.redirect(`${dashboardUrl}/magic-link-error?reason=invalid`);
    }

    if (magicToken.used) {
      logger.warn({ incidentId, tokenId: magicToken.id }, 'Magic link already used');
      return res.redirect(`${dashboardUrl}/magic-link-error?reason=used`);
    }

    if (magicToken.expiresAt < new Date()) {
      logger.warn({ incidentId, tokenId: magicToken.id, expiresAt: magicToken.expiresAt }, 'Magic link expired');
      return res.redirect(`${dashboardUrl}/magic-link-error?reason=expired`);
    }

    if (magicToken.incidentId !== incidentId) {
      logger.warn({ incidentId, tokenIncidentId: magicToken.incidentId }, 'Magic link incident mismatch');
      return res.redirect(`${dashboardUrl}/magic-link-error?reason=invalid`);
    }

    if (magicToken.action !== action) {
      logger.warn({ action, tokenAction: magicToken.action }, 'Magic link action mismatch');
      return res.redirect(`${dashboardUrl}/magic-link-error?reason=invalid`);
    }

    // Mark token as used (one-time use per OWASP)
    await prisma.magicLinkToken.update({
      where: { id: magicToken.id },
      data: { used: true, usedAt: new Date() }
    });

    // Perform action
    // Note: We use a system user ID since the user is not authenticated
    // The magic link itself is proof of authorization
    const systemUserId = 'magic-link';

    try {
      if (action === 'acknowledge') {
        await incidentService.acknowledge(incidentId, systemUserId, { note: 'Acknowledged via email magic link' });
        logger.info({ incidentId }, 'Incident acknowledged via magic link');
        res.redirect(`${dashboardUrl}/incidents/${incidentId}?action=acknowledged`);
      } else {
        await incidentService.resolve(incidentId, systemUserId, { resolutionNote: 'Resolved via email magic link' });
        logger.info({ incidentId }, 'Incident resolved via magic link');
        res.redirect(`${dashboardUrl}/incidents/${incidentId}?action=resolved`);
      }
    } catch (actionError) {
      const msg = actionError instanceof Error ? actionError.message : 'Unknown error';
      logger.warn({ incidentId, action, error: msg }, 'Magic link action failed');
      res.redirect(`${dashboardUrl}/incidents/${incidentId}?error=${encodeURIComponent(msg)}`);
    }

  } catch (error) {
    logger.error({ error, incidentId, action }, 'Magic link handler error');
    res.redirect(`${dashboardUrl}/magic-link-error?reason=error`);
  }
}

export const magicLinksRouter = router;
```
  </action>
  <verify>npx tsc --noEmit src/routes/magic-links.ts</verify>
  <done>Magic link routes validate tokens and execute acknowledge/resolve actions</done>
</task>

<task type="auto">
  <name>Task 2: Create SMS reply service and Twilio webhooks</name>
  <files>src/services/notification/sms-reply.service.ts, src/routes/webhooks/twilio-webhooks.ts</files>
  <action>
1. Create `src/services/notification/sms-reply.service.ts`:
```typescript
import twilio from 'twilio';
import { prisma } from '../../config/database.js';
import { incidentService } from '../incident.service.js';
import { env } from '../../config/env.js';
import { logger } from '../../config/logger.js';

class SMSReplyService {
  private twilioClient: ReturnType<typeof twilio>;

  constructor() {
    this.twilioClient = twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);
  }

  // Process incoming SMS reply
  async processReply(from: string, body: string): Promise<string | null> {
    logger.info({ from, body }, 'Processing SMS reply');

    // Normalize phone number (remove formatting)
    const normalizedPhone = from.replace(/\D/g, '');

    // Look up user by phone
    const user = await prisma.user.findFirst({
      where: {
        OR: [
          { phone: from },
          { phone: normalizedPhone },
          { phone: `+${normalizedPhone}` }
        ],
        isActive: true
      }
    });

    if (!user) {
      logger.warn({ from }, 'SMS reply from unknown phone number');
      return 'Your phone number is not registered with OnCall Platform.';
    }

    // Parse incident ID from reply
    // Per user decision: Format is "Reply ACK" or "ACK 123456"
    const match = body.match(/\b(\d{4,})\b/);  // Find 4+ digit number (incident short ID)

    if (!match) {
      // Try to find most recent open incident for this user
      const recentIncident = await prisma.incident.findFirst({
        where: {
          assignedUserId: user.id,
          status: 'OPEN'
        },
        orderBy: { createdAt: 'desc' }
      });

      if (recentIncident && /\b(ack|acknowledge)\b/i.test(body)) {
        // Acknowledge most recent incident
        await incidentService.acknowledge(recentIncident.id, user.id, { note: 'Acknowledged via SMS reply' });
        logger.info({ incidentId: recentIncident.id, userId: user.id }, 'Incident acknowledged via SMS');
        return `Incident #${recentIncident.id.slice(-6)} acknowledged.`;
      }

      return 'Reply with incident number to acknowledge (e.g., "ACK 123456")';
    }

    const shortId = match[1];

    // Find incident by short ID suffix
    const incident = await prisma.incident.findFirst({
      where: {
        id: { endsWith: shortId },
        status: { in: ['OPEN', 'ACKNOWLEDGED'] }
      },
      orderBy: { createdAt: 'desc' }
    });

    if (!incident) {
      return `Incident #${shortId} not found or already resolved.`;
    }

    // Check for ACK or RESOLVE keywords
    if (/\b(ack|acknowledge)\b/i.test(body)) {
      try {
        await incidentService.acknowledge(incident.id, user.id, { note: 'Acknowledged via SMS reply' });
        logger.info({ incidentId: incident.id, userId: user.id }, 'Incident acknowledged via SMS');
        return `Incident #${shortId} acknowledged.`;
      } catch (error) {
        const msg = error instanceof Error ? error.message : 'Unknown error';
        return `Failed to acknowledge: ${msg}`;
      }
    }

    if (/\b(resolve|resolved)\b/i.test(body)) {
      try {
        await incidentService.resolve(incident.id, user.id, { resolutionNote: 'Resolved via SMS reply' });
        logger.info({ incidentId: incident.id, userId: user.id }, 'Incident resolved via SMS');
        return `Incident #${shortId} resolved.`;
      } catch (error) {
        const msg = error instanceof Error ? error.message : 'Unknown error';
        return `Failed to resolve: ${msg}`;
      }
    }

    return `Incident #${shortId} found. Reply ACK to acknowledge or RESOLVE to resolve.`;
  }

  // Send reply SMS
  async sendReply(to: string, body: string): Promise<void> {
    try {
      await this.twilioClient.messages.create({
        from: env.TWILIO_PHONE_NUMBER,
        to,
        body
      });
    } catch (error) {
      logger.error({ error, to }, 'Failed to send SMS reply');
    }
  }
}

export const smsReplyService = new SMSReplyService();
```

2. Create `src/routes/webhooks/twilio-webhooks.ts`:
```typescript
import crypto from 'crypto';
import { Router, Request, Response } from 'express';
import twilio from 'twilio';
import { prisma } from '../../config/database.js';
import { incidentService } from '../../services/incident.service.js';
import { smsReplyService } from '../../services/notification/sms-reply.service.js';
import { deliveryTracker } from '../../services/notification/delivery-tracker.js';
import { buildKeypadResponseTwiml } from '../../services/notification/templates/twiml.templates.js';
import { env } from '../../config/env.js';
import { logger } from '../../config/logger.js';

const router = Router();

// Twilio signature validation
function validateTwilioSignature(req: Request): boolean {
  const signature = req.headers['x-twilio-signature'] as string;
  if (!signature) return false;

  const url = `${env.API_BASE_URL}${req.originalUrl}`;
  return twilio.validateRequest(
    env.TWILIO_AUTH_TOKEN,
    signature,
    url,
    req.body
  );
}

// SMS inbound webhook (user replies)
router.post('/sms/inbound', async (req: Request, res: Response) => {
  if (!validateTwilioSignature(req)) {
    logger.warn('Invalid Twilio signature on SMS inbound');
    return res.status(403).send('Invalid signature');
  }

  const { From, Body } = req.body;

  logger.info({ from: From, body: Body }, 'Received SMS inbound');

  // Process reply
  const reply = await smsReplyService.processReply(From, Body);

  // Send reply SMS
  if (reply) {
    await smsReplyService.sendReply(From, reply);
  }

  // Respond with TwiML (empty is fine, we're sending reply separately)
  res.type('text/xml').send('<?xml version="1.0" encoding="UTF-8"?><Response></Response>');
});

// SMS delivery status webhook
router.post('/sms/status', async (req: Request, res: Response) => {
  if (!validateTwilioSignature(req)) {
    logger.warn('Invalid Twilio signature on SMS status');
    return res.status(403).send('Invalid signature');
  }

  const { MessageSid, MessageStatus, ErrorCode, ErrorMessage } = req.body;

  logger.info({ messageSid: MessageSid, status: MessageStatus, errorCode: ErrorCode }, 'SMS delivery status');

  // Update delivery tracker
  const delivered = MessageStatus === 'delivered';
  const failed = ['failed', 'undelivered'].includes(MessageStatus);

  if (delivered || failed) {
    await deliveryTracker.updateFromProviderWebhook(
      MessageSid,
      'sms',
      delivered,
      failed ? (ErrorMessage || `Error ${ErrorCode}`) : undefined
    );
  }

  res.status(200).send('OK');
});

// Voice call TwiML (initial prompt)
router.post('/voice/incident/:incidentId', async (req: Request, res: Response) => {
  if (!validateTwilioSignature(req)) {
    logger.warn('Invalid Twilio signature on voice webhook');
    return res.status(403).send('Invalid signature');
  }

  const { incidentId } = req.params;
  const { AnsweredBy } = req.body;

  // Check if voicemail
  if (AnsweredBy === 'machine_start' || AnsweredBy === 'fax') {
    logger.info({ incidentId, answeredBy: AnsweredBy }, 'Voice call answered by machine');
    res.type('text/xml').send(`<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">This is an urgent incident notification. Please check your OnCall platform for details.</Say>
</Response>`);
    return;
  }

  // Get incident for TwiML
  const incident = await prisma.incident.findUnique({
    where: { id: incidentId },
    include: { alerts: { take: 1 } }
  });

  if (!incident) {
    res.type('text/xml').send(`<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Incident not found. Goodbye.</Say>
</Response>`);
    return;
  }

  const baseUrl = env.API_BASE_URL || 'http://localhost:3000';

  // Build TwiML for IVR (per user decision: Press 1 ack, Press 2 details, Press 9 escalate)
  const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Gather numDigits="1" action="${baseUrl}/webhooks/twilio/voice/incident/${incidentId}/input" timeout="10">
    <Say voice="alice">
      ${incident.priority} incident for ${incident.alerts[0]?.source || 'unknown service'}.
      ${incident.alerts[0]?.title || 'Alert triggered'}.
      Press 1 to acknowledge.
      Press 2 to hear details.
      Press 9 to escalate.
    </Say>
  </Gather>
  <Say voice="alice">We did not receive any input. Goodbye.</Say>
</Response>`;

  res.type('text/xml').send(twiml);
});

// Voice call keypress input handler
router.post('/voice/incident/:incidentId/input', async (req: Request, res: Response) => {
  if (!validateTwilioSignature(req)) {
    logger.warn('Invalid Twilio signature on voice input');
    return res.status(403).send('Invalid signature');
  }

  const { incidentId } = req.params;
  const { Digits, From, CallSid } = req.body;

  logger.info({ incidentId, digits: Digits, from: From, callSid: CallSid }, 'Voice keypress received');

  const baseUrl = env.API_BASE_URL || 'http://localhost:3000';

  // Look up user by phone
  const user = await prisma.user.findFirst({
    where: { phone: From, isActive: true }
  });

  const incident = await prisma.incident.findUnique({
    where: { id: incidentId },
    include: { alerts: { take: 1 } }
  });

  if (!incident) {
    res.type('text/xml').send(`<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Incident not found. Goodbye.</Say>
</Response>`);
    return;
  }

  let twiml = '';

  switch (Digits) {
    case '1':
      // Acknowledge
      if (user) {
        try {
          await incidentService.acknowledge(incidentId, user.id, { note: 'Acknowledged via phone call' });
          logger.info({ incidentId, userId: user.id }, 'Incident acknowledged via voice');
          twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Incident ${incidentId.slice(-6)} has been acknowledged. Thank you.</Say>
</Response>`;
        } catch (error) {
          const msg = error instanceof Error ? error.message : 'Unknown error';
          twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Failed to acknowledge: ${msg}. Goodbye.</Say>
</Response>`;
        }
      } else {
        twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Your phone number is not registered. Goodbye.</Say>
</Response>`;
      }
      break;

    case '2':
      // Read details
      twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Gather numDigits="1" action="${baseUrl}/webhooks/twilio/voice/incident/${incidentId}/input" timeout="10">
    <Say voice="alice">
      ${incident.alerts[0]?.description || 'No additional details available'}.
      Alert count: ${incident.alertCount}.
      Press 1 to acknowledge, or hang up.
    </Say>
  </Gather>
  <Say voice="alice">Goodbye.</Say>
</Response>`;
      break;

    case '9':
      // Escalate (manual escalation)
      logger.info({ incidentId }, 'Manual escalation requested via voice');
      twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Escalating to next level. Goodbye.</Say>
</Response>`;
      // TODO: Trigger manual escalation in escalation service
      break;

    default:
      twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Invalid input. Goodbye.</Say>
</Response>`;
  }

  res.type('text/xml').send(twiml);
});

// Voice call status webhook
router.post('/voice/status', async (req: Request, res: Response) => {
  if (!validateTwilioSignature(req)) {
    return res.status(403).send('Invalid signature');
  }

  const { CallSid, CallStatus, Duration } = req.body;

  logger.info({ callSid: CallSid, status: CallStatus, duration: Duration }, 'Voice call status');

  // Update delivery tracker
  const delivered = ['completed', 'answered'].includes(CallStatus);
  const failed = ['failed', 'busy', 'no-answer', 'canceled'].includes(CallStatus);

  if (delivered || failed) {
    await deliveryTracker.updateFromProviderWebhook(
      CallSid,
      'voice',
      delivered,
      failed ? `Call ${CallStatus}` : undefined
    );
  }

  res.status(200).send('OK');
});

export const twilioWebhooksRouter = router;
```
  </action>
  <verify>npx tsc --noEmit src/services/notification/sms-reply.service.ts src/routes/webhooks/twilio-webhooks.ts</verify>
  <done>Twilio webhooks handle SMS replies, voice IVR, and delivery status updates</done>
</task>

<task type="auto">
  <name>Task 3: Mount magic links and Twilio webhooks in Express app</name>
  <files>src/index.ts</files>
  <action>
Add magic link and Twilio webhook routes to the Express app in `src/index.ts`.

```typescript
// Import at top of file
import { magicLinksRouter } from './routes/magic-links.js';
import { twilioWebhooksRouter } from './routes/webhooks/twilio-webhooks.js';

// Mount magic links (public route - no auth needed, token is the auth)
app.use('/magic', magicLinksRouter);

// Mount Twilio webhooks (before auth middleware - uses signature verification)
app.use('/webhooks/twilio', twilioWebhooksRouter);
```

These routes should be mounted before authentication middleware since:
- Magic links use the token itself for authorization
- Twilio webhooks use Twilio signature verification
  </action>
  <verify>grep -q "magicLinksRouter" src/index.ts && grep -q "twilioWebhooksRouter" src/index.ts</verify>
  <done>Magic link and Twilio webhook routes mounted in Express app</done>
</task>

</tasks>

<verification>
- Magic links verify token hash, expiration, and one-time use
- Magic links expire after 15 minutes (per user decision)
- SMS replies parse ACK keyword and incident ID
- Voice IVR responds to keypress 1/2/9
- Twilio signature validation on all webhook endpoints
- Delivery status webhooks update NotificationLog
- TypeScript compiles without errors
</verification>

<success_criteria>
1. Magic link acknowledge redirects to dashboard with success message
2. Magic link resolve redirects to dashboard with success message
3. Magic links reject: invalid token, expired (15 min), already used
4. SMS reply "ACK 123456" acknowledges incident
5. Voice call keypress 1 acknowledges incident
6. Voice call keypress 2 reads details
7. Delivery status webhooks update NotificationLog status
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-channel-notifications/05-08-SUMMARY.md`
</output>

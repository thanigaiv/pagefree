---
phase: 09-status-pages
plan: 09
type: execute
wave: 1
depends_on: []
files_modified: [src/routes/statusPublic.routes.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can subscribe to status page updates via email/webhook/Slack"
    - "User can verify email subscription via verification link"
    - "User can unsubscribe from status page updates"
  artifacts:
    - path: "src/routes/statusPublic.routes.ts"
      provides: "Wired subscription endpoints"
      contains: "statusSubscriberService"
  key_links:
    - from: "src/routes/statusPublic.routes.ts"
      to: "statusSubscriberService.subscribe()"
      via: "POST /:slug/subscribe handler"
      pattern: "statusSubscriberService\\.subscribe"
    - from: "src/routes/statusPublic.routes.ts"
      to: "statusSubscriberService.verify()"
      via: "GET /subscribe/verify handler"
      pattern: "statusSubscriberService\\.verify"
    - from: "src/routes/statusPublic.routes.ts"
      to: "statusSubscriberService.unsubscribeByDestination()"
      via: "GET /unsubscribe handler"
      pattern: "statusSubscriberService\\.unsubscribeByDestination"
---

<objective>
Wire public subscription endpoints to the fully implemented statusSubscriberService.

Purpose: Close the gap identified in verification - public subscription endpoints return hardcoded placeholders instead of calling the backend service that is already fully implemented.

Output: Working subscription flow where users can subscribe, verify email, and unsubscribe from status page updates.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-status-pages/09-VERIFICATION.md

# Service being wired
@src/services/statusSubscriber.service.ts

# Route file to update
@src/routes/statusPublic.routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire subscription endpoints to statusSubscriberService</name>
  <files>src/routes/statusPublic.routes.ts</files>
  <action>
Update the three subscription endpoints to call the existing statusSubscriberService methods:

1. **Import statusSubscriberService** at the top of the file:
   ```typescript
   import { statusSubscriberService } from '../services/statusSubscriber.service.js';
   ```

2. **POST /:slug/subscribe endpoint** (lines 152-191):
   Replace the placeholder response with actual service call:
   ```typescript
   // Call the subscriber service
   const result = await statusSubscriberService.subscribe(
     statusPage.id,
     channel,
     destination,
     {
       componentIds: req.body.componentIds,
       notifyOn: req.body.notifyOn
     }
   );

   return res.status(201).json({
     success: true,
     subscriberId: result.subscriber.id,
     requiresVerification: result.requiresVerification,
     message: result.requiresVerification
       ? 'Please check your email to verify your subscription'
       : 'Subscription created successfully'
   });
   ```

   Add error handling for the "Already subscribed" case from the service:
   ```typescript
   } catch (error) {
     if (error instanceof Error && error.message === 'Already subscribed') {
       return res.status(409).json({ error: 'Already subscribed to this status page' });
     }
     return next(error);
   }
   ```

3. **GET /subscribe/verify endpoint** (lines 197-214):
   Replace the placeholder response with actual service call:
   ```typescript
   const verified = await statusSubscriberService.verify(token as string);

   if (!verified) {
     return res.status(400).json({
       success: false,
       error: 'Invalid or expired verification token'
     });
   }

   return res.json({
     success: true,
     message: 'Email verified successfully. You are now subscribed to status updates.'
   });
   ```

4. **GET /unsubscribe endpoint** (lines 220-237):
   Replace the placeholder with actual service call. The unsubscribe endpoint needs a statusPageId to look up the subscription. Two options:
   - Use a signed token containing statusPageId + destination
   - Accept statusPageId as query param alongside destination

   For simplicity, accept both statusPageId and destination as query params:
   ```typescript
   const { statusPageId, destination } = req.query;

   if (!statusPageId || !destination) {
     return res.status(400).json({
       error: 'statusPageId and destination are required'
     });
   }

   const unsubscribed = await statusSubscriberService.unsubscribeByDestination(
     statusPageId as string,
     destination as string
   );

   if (!unsubscribed) {
     return res.status(404).json({
       success: false,
       error: 'Subscription not found'
     });
   }

   return res.json({
     success: true,
     message: 'You have been unsubscribed from status updates.'
   });
   ```

Remove all placeholder comments ("Note: statusSubscriberService.X() will be implemented in a later plan").
  </action>
  <verify>
Run TypeScript compilation to verify imports and types:
```bash
npx tsc --noEmit
```

Run existing status page tests:
```bash
npm test -- --grep "status"
```
  </verify>
  <done>
- POST /:slug/subscribe calls statusSubscriberService.subscribe() and returns subscriber ID
- GET /subscribe/verify calls statusSubscriberService.verify() and returns success/failure
- GET /unsubscribe calls statusSubscriberService.unsubscribeByDestination() and returns success/failure
- All placeholder comments removed
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add subscription endpoint integration tests</name>
  <files>tests/integration/statusSubscription.test.ts</files>
  <action>
Create integration tests for the public subscription endpoints to verify the wiring:

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import request from 'supertest';
import { app } from '../../src/index.js';
import { prisma } from '../../src/config/database.js';

describe('Public Status Subscription Endpoints', () => {
  let statusPageId: string;
  let statusPageSlug: string;
  let teamId: string;

  beforeAll(async () => {
    // Create test team
    const team = await prisma.team.create({
      data: {
        name: 'Subscription Test Team',
        slug: 'sub-test-team',
      },
    });
    teamId = team.id;

    // Create test status page
    const statusPage = await prisma.statusPage.create({
      data: {
        teamId,
        name: 'Test Status Page',
        slug: 'test-subscription-page',
        isPublic: true,
      },
    });
    statusPageId = statusPage.id;
    statusPageSlug = statusPage.slug;
  });

  afterAll(async () => {
    // Clean up in correct order for foreign keys
    await prisma.statusSubscriber.deleteMany({ where: { statusPageId } });
    await prisma.statusPage.deleteMany({ where: { id: statusPageId } });
    await prisma.team.deleteMany({ where: { id: teamId } });
  });

  beforeEach(async () => {
    // Clean up subscribers between tests
    await prisma.statusSubscriber.deleteMany({ where: { statusPageId } });
  });

  describe('POST /status/:slug/subscribe', () => {
    it('should create webhook subscription (auto-verified)', async () => {
      const res = await request(app)
        .post(`/status/${statusPageSlug}/subscribe`)
        .send({
          channel: 'WEBHOOK',
          destination: 'https://example.com/webhook',
        });

      expect(res.status).toBe(201);
      expect(res.body.success).toBe(true);
      expect(res.body.subscriberId).toBeDefined();
      expect(res.body.requiresVerification).toBe(false);

      // Verify in database
      const subscriber = await prisma.statusSubscriber.findFirst({
        where: { statusPageId, destination: 'https://example.com/webhook' },
      });
      expect(subscriber).toBeDefined();
      expect(subscriber?.isVerified).toBe(true);
      expect(subscriber?.isActive).toBe(true);
    });

    it('should create email subscription requiring verification', async () => {
      const res = await request(app)
        .post(`/status/${statusPageSlug}/subscribe`)
        .send({
          channel: 'EMAIL',
          destination: 'test@example.com',
        });

      expect(res.status).toBe(201);
      expect(res.body.success).toBe(true);
      expect(res.body.requiresVerification).toBe(true);

      // Verify in database
      const subscriber = await prisma.statusSubscriber.findFirst({
        where: { statusPageId, destination: 'test@example.com' },
      });
      expect(subscriber).toBeDefined();
      expect(subscriber?.isVerified).toBe(false);
      expect(subscriber?.verifyToken).not.toBeNull();
    });

    it('should return 409 for duplicate subscription', async () => {
      // Create first subscription
      await request(app)
        .post(`/status/${statusPageSlug}/subscribe`)
        .send({
          channel: 'WEBHOOK',
          destination: 'https://example.com/duplicate',
        });

      // Try duplicate
      const res = await request(app)
        .post(`/status/${statusPageSlug}/subscribe`)
        .send({
          channel: 'WEBHOOK',
          destination: 'https://example.com/duplicate',
        });

      expect(res.status).toBe(409);
      expect(res.body.error).toContain('Already subscribed');
    });

    it('should return 400 for missing channel', async () => {
      const res = await request(app)
        .post(`/status/${statusPageSlug}/subscribe`)
        .send({
          destination: 'test@example.com',
        });

      expect(res.status).toBe(400);
    });

    it('should return 404 for non-existent status page', async () => {
      const res = await request(app)
        .post('/status/non-existent-page/subscribe')
        .send({
          channel: 'EMAIL',
          destination: 'test@example.com',
        });

      expect(res.status).toBe(404);
    });
  });

  describe('GET /status/subscribe/verify', () => {
    it('should verify valid token', async () => {
      // Create subscription with verification token
      const subscriber = await prisma.statusSubscriber.create({
        data: {
          statusPageId,
          channel: 'EMAIL',
          destination: 'verify-test@example.com',
          isVerified: false,
          verifyToken: 'test-verify-token-123',
        },
      });

      const res = await request(app)
        .get('/status/subscribe/verify')
        .query({ token: 'test-verify-token-123' });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);

      // Verify in database
      const updated = await prisma.statusSubscriber.findUnique({
        where: { id: subscriber.id },
      });
      expect(updated?.isVerified).toBe(true);
      expect(updated?.verifyToken).toBeNull();
    });

    it('should return 400 for invalid token', async () => {
      const res = await request(app)
        .get('/status/subscribe/verify')
        .query({ token: 'invalid-token' });

      expect(res.status).toBe(400);
      expect(res.body.success).toBe(false);
    });

    it('should return 400 for missing token', async () => {
      const res = await request(app).get('/status/subscribe/verify');

      expect(res.status).toBe(400);
    });
  });

  describe('GET /status/unsubscribe', () => {
    it('should unsubscribe active subscriber', async () => {
      // Create active subscription
      await prisma.statusSubscriber.create({
        data: {
          statusPageId,
          channel: 'WEBHOOK',
          destination: 'https://example.com/unsub-test',
          isVerified: true,
          isActive: true,
        },
      });

      const res = await request(app)
        .get('/status/unsubscribe')
        .query({
          statusPageId,
          destination: 'https://example.com/unsub-test',
        });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);

      // Verify in database
      const subscriber = await prisma.statusSubscriber.findFirst({
        where: { statusPageId, destination: 'https://example.com/unsub-test' },
      });
      expect(subscriber?.isActive).toBe(false);
    });

    it('should return 404 for non-existent subscription', async () => {
      const res = await request(app)
        .get('/status/unsubscribe')
        .query({
          statusPageId,
          destination: 'nonexistent@example.com',
        });

      expect(res.status).toBe(404);
    });

    it('should return 400 for missing parameters', async () => {
      const res = await request(app).get('/status/unsubscribe');

      expect(res.status).toBe(400);
    });
  });
});
```

Handle test database setup appropriately - the tests should use the existing test infrastructure pattern from the project.
  </action>
  <verify>
Run the new subscription tests:
```bash
npm test -- tests/integration/statusSubscription.test.ts
```
  </verify>
  <done>
- Integration tests pass for subscribe, verify, and unsubscribe endpoints
- Tests verify database state changes, not just response codes
- Tests cover success cases, error cases, and edge cases
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. All existing status tests pass: `npm test -- --grep "status"`
3. New subscription tests pass: `npm test -- tests/integration/statusSubscription.test.ts`
4. Manual verification (optional):
   - POST to /status/:slug/subscribe creates subscriber in database
   - GET /status/subscribe/verify with valid token marks subscriber as verified
   - GET /status/unsubscribe deactivates subscriber
</verification>

<success_criteria>
- Public subscription endpoints call statusSubscriberService methods instead of returning placeholders
- Email subscriptions trigger verification email queue job
- Webhook/Slack subscriptions are auto-verified
- All three endpoints properly handle success and error cases
- Integration tests verify the complete subscription flow
- Gap from 09-VERIFICATION.md is closed
</success_criteria>

<output>
After completion, create `.planning/phases/09-status-pages/09-09-SUMMARY.md`
</output>

---
phase: 09-status-pages
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/types/statusPage.ts
autonomous: true

must_haves:
  truths:
    - "StatusPage, StatusPageComponent, StatusSubscriber, MaintenanceWindow, StatusIncident models exist in schema"
    - "TypeScript types for component status hierarchy are defined"
    - "Database migration completes without errors"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Status page data models"
      contains: "model StatusPage"
    - path: "src/types/statusPage.ts"
      provides: "TypeScript types for status pages"
      exports: ["ComponentStatus", "STATUS_SEVERITY_ORDER", "StatusPageWithComponents"]
  key_links:
    - from: "prisma/schema.prisma"
      to: "Incident model"
      via: "StatusIncident.incidentId foreign key"
      pattern: "incident\\s+Incident"
    - from: "prisma/schema.prisma"
      to: "Team model"
      via: "StatusPage.teamId foreign key"
      pattern: "team\\s+Team"
---

<objective>
Create database schema and TypeScript types for status pages, components, subscribers, maintenance windows, and status incidents.

Purpose: Establish the data foundation for all status page functionality per research schema design.
Output: Prisma schema models and TypeScript type definitions.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-status-pages/09-RESEARCH.md
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add status page models to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the following models at the end of the schema file (before any closing comments):

1. **StatusPage model:**
   - id: String @id @default(cuid())
   - name: String (e.g., "Internal Services Status")
   - description: String?
   - slug: String @unique (URL-friendly identifier)
   - isPublic: Boolean @default(false) (requires accessToken if false)
   - accessToken: String? @unique (for private page access)
   - teamId: String (foreign key to Team)
   - createdById: String
   - createdAt, updatedAt with @db.Timestamptz
   - Relations: components StatusPageComponent[], subscribers StatusSubscriber[], maintenanceWindows MaintenanceWindow[], statusIncidents StatusIncident[]
   - Indexes: [teamId], [slug]

2. **StatusPageComponent model:**
   - id: String @id @default(cuid())
   - statusPageId: String (foreign key to StatusPage with onDelete: Cascade)
   - name: String (e.g., "API Gateway")
   - description: String?
   - displayOrder: Int @default(0)
   - teamId: String? (incidents from this team affect component)
   - serviceIdentifier: String? (filter by alert source/service)
   - currentStatus: String @default("OPERATIONAL") (cache field)
   - statusUpdatedAt: DateTime @default(now()) @db.Timestamptz
   - createdAt, updatedAt with @db.Timestamptz
   - Relation: maintenanceWindows via @relation("ComponentMaintenance")
   - Unique: [statusPageId, name]
   - Index: [statusPageId, displayOrder]

3. **StatusSubscriber model:**
   - id: String @id @default(cuid())
   - statusPageId: String (foreign key to StatusPage with onDelete: Cascade)
   - channel: String (EMAIL, SLACK, WEBHOOK)
   - destination: String (email, webhook URL, Slack channel)
   - componentIds: String[] (empty = all components)
   - notifyOn: String[] (['degraded', 'outage', 'maintenance', 'resolved'])
   - isVerified: Boolean @default(false)
   - verifyToken: String? @unique
   - isActive: Boolean @default(true)
   - createdAt with @db.Timestamptz
   - Unique: [statusPageId, channel, destination]
   - Index: [statusPageId, isActive]

4. **MaintenanceWindow model:**
   - id: String @id @default(cuid())
   - statusPageId: String (foreign key to StatusPage with onDelete: Cascade)
   - title: String
   - description: String?
   - startTime: DateTime @db.Timestamptz
   - endTime: DateTime @db.Timestamptz
   - recurrenceRule: String? (RRULE for recurring)
   - autoUpdateStatus: Boolean @default(true)
   - notifySubscribers: Boolean @default(true)
   - status: String @default("SCHEDULED") (SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED)
   - components: StatusPageComponent[] @relation("ComponentMaintenance")
   - createdById: String
   - createdAt, updatedAt with @db.Timestamptz
   - Indexes: [statusPageId, startTime], [status, startTime]

5. **StatusIncident model:**
   - id: String @id @default(cuid())
   - statusPageId: String (foreign key to StatusPage with onDelete: Cascade)
   - incidentId: String? (optional link to platform Incident)
   - title: String (user-facing, may differ from internal)
   - message: String?
   - severity: String (MINOR, MAJOR, CRITICAL)
   - status: String (INVESTIGATING, IDENTIFIED, MONITORING, RESOLVED)
   - affectedComponentIds: String[]
   - createdAt, updatedAt, resolvedAt with @db.Timestamptz
   - updates: Json @default("[]") (array of {timestamp, status, message})
   - Indexes: [statusPageId, status], [incidentId]

6. **Add relation to Team model:**
   - statusPages StatusPage[]

7. **Add relation to Incident model:**
   - statusIncidents StatusIncident[]

Use existing schema patterns: @db.Timestamptz for all dates, @default(now()) for createdAt, @updatedAt for updatedAt, standard index patterns.
  </action>
  <verify>npx prisma validate</verify>
  <done>All 5 status page models defined with proper relations, cascades, and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeScript types for status pages</name>
  <files>src/types/statusPage.ts</files>
  <action>
Create TypeScript types for status page domain:

1. **ComponentStatus type and hierarchy:**
```typescript
export const STATUS_SEVERITY_ORDER = [
  'MAJOR_OUTAGE',
  'PARTIAL_OUTAGE',
  'DEGRADED_PERFORMANCE',
  'UNDER_MAINTENANCE',
  'OPERATIONAL'
] as const;

export type ComponentStatus = typeof STATUS_SEVERITY_ORDER[number];
```

2. **INCIDENT_PRIORITY_TO_STATUS mapping:**
```typescript
export const INCIDENT_PRIORITY_TO_STATUS: Record<string, ComponentStatus> = {
  'CRITICAL': 'MAJOR_OUTAGE',
  'HIGH': 'PARTIAL_OUTAGE',
  'MEDIUM': 'DEGRADED_PERFORMANCE',
  'LOW': 'OPERATIONAL',
  'INFO': 'OPERATIONAL'
};
```

3. **StatusPageSeverity enum values for StatusIncident:**
```typescript
export const STATUS_INCIDENT_SEVERITY = ['MINOR', 'MAJOR', 'CRITICAL'] as const;
export type StatusIncidentSeverity = typeof STATUS_INCIDENT_SEVERITY[number];
```

4. **StatusIncidentStatus enum values:**
```typescript
export const STATUS_INCIDENT_STATUS = ['INVESTIGATING', 'IDENTIFIED', 'MONITORING', 'RESOLVED'] as const;
export type StatusIncidentStatus = typeof STATUS_INCIDENT_STATUS[number];
```

5. **MaintenanceWindowStatus enum values:**
```typescript
export const MAINTENANCE_STATUS = ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'] as const;
export type MaintenanceStatus = typeof MAINTENANCE_STATUS[number];
```

6. **SubscriberChannel type:**
```typescript
export const SUBSCRIBER_CHANNELS = ['EMAIL', 'SLACK', 'WEBHOOK'] as const;
export type SubscriberChannel = typeof SUBSCRIBER_CHANNELS[number];
```

7. **NotifyOn type:**
```typescript
export const NOTIFY_ON_EVENTS = ['degraded', 'outage', 'maintenance', 'resolved'] as const;
export type NotifyOnEvent = typeof NOTIFY_ON_EVENTS[number];
```

8. **StatusPageWithComponents interface:**
```typescript
export interface StatusPageWithComponents {
  id: string;
  name: string;
  description: string | null;
  slug: string;
  isPublic: boolean;
  components: {
    id: string;
    name: string;
    description: string | null;
    displayOrder: number;
    currentStatus: ComponentStatus;
    statusUpdatedAt: Date;
  }[];
  overallStatus: ComponentStatus;
  updatedAt: Date;
}
```

9. **StatusChangeNotification interface for subscriber notifications:**
```typescript
export interface StatusChangeNotification {
  statusPageId: string;
  componentId: string;
  componentName: string;
  previousStatus: ComponentStatus;
  newStatus: ComponentStatus;
  incidentId?: string;
  maintenanceId?: string;
  message?: string;
}
```

10. **CreateMaintenanceWindow input type:**
```typescript
export interface CreateMaintenanceWindowInput {
  componentIds: string[];
  title: string;
  description?: string;
  startTime: Date;
  endTime: Date;
  autoUpdateStatus: boolean;
  notifySubscribers: boolean;
  recurrenceRule?: string;
}
```

11. **StatusUpdate interface for StatusIncident updates:**
```typescript
export interface StatusUpdate {
  timestamp: string;
  status: StatusIncidentStatus;
  message: string;
}
```

Export all types and constants.
  </action>
  <verify>npx tsc --noEmit src/types/statusPage.ts</verify>
  <done>All TypeScript types exported for status page domain</done>
</task>

<task type="auto">
  <name>Task 3: Generate and apply migration</name>
  <files>prisma/migrations/*</files>
  <action>
Run Prisma migration to create status page tables:

1. Generate migration:
```bash
npx prisma migrate dev --name add_status_page_models
```

2. Verify migration created tables:
   - StatusPage
   - StatusPageComponent
   - StatusSubscriber
   - MaintenanceWindow
   - StatusIncident

3. Generate Prisma client:
```bash
npx prisma generate
```

The migration should create all 5 tables with proper foreign keys, indexes, and constraints.
  </action>
  <verify>npx prisma db push --accept-data-loss --force-reset is NOT needed - just verify tables exist with: npx prisma studio (or check migration output)</verify>
  <done>Database migration applied, all status page tables created</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes
2. `npx tsc --noEmit` passes
3. Migration completes without errors
4. StatusPage model has teamId relation to Team
5. StatusIncident model has optional incidentId relation to Incident
6. StatusPageComponent has cascade delete from StatusPage
</verification>

<success_criteria>
- All 5 status page models exist in schema.prisma
- TypeScript types define status hierarchy and all enums
- Database tables created via migration
- Relations properly link to existing Team and Incident models
</success_criteria>

<output>
After completion, create `.planning/phases/09-status-pages/09-01-SUMMARY.md`
</output>

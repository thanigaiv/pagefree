---
phase: 09-status-pages
plan: 05
type: execute
wave: 3
depends_on: [09-02, 09-03]
files_modified:
  - src/routes/statusPage.routes.ts
  - src/routes/statusPublic.routes.ts
  - src/app.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create/update/delete status pages via API"
    - "Admin can manage components and maintenance windows"
    - "Public endpoint returns status page data with computed statuses"
    - "Access token protects private status pages"
  artifacts:
    - path: "src/routes/statusPage.routes.ts"
      provides: "Admin API for status page management"
      exports: ["statusPageRoutes"]
    - path: "src/routes/statusPublic.routes.ts"
      provides: "Public API for status page viewing"
      exports: ["statusPublicRoutes"]
  key_links:
    - from: "src/routes/statusPage.routes.ts"
      to: "src/services/statusPage.service.ts"
      via: "service method calls"
      pattern: "statusPageService\\."
    - from: "src/routes/statusPublic.routes.ts"
      to: "src/services/statusComputation.service.ts"
      via: "status computation"
      pattern: "statusComputationService\\."
    - from: "src/app.ts"
      to: "src/routes/statusPage.routes.ts"
      via: "Express router mounting"
      pattern: "app\\.use.*statusPage"
---

<objective>
Create REST API endpoints for status page management (admin) and public viewing.

Purpose: Expose status page functionality via API for STATUS-01 through STATUS-04.
Output: Admin routes for CRUD, public routes for viewing, mounted in Express app.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-status-pages/09-RESEARCH.md
@.planning/phases/09-status-pages/09-02-SUMMARY.md
@.planning/phases/09-status-pages/09-03-SUMMARY.md
@src/routes/incident.routes.ts
@src/middleware/requireAuth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create admin status page routes</name>
  <files>src/routes/statusPage.routes.ts</files>
  <action>
Create admin routes for status page management (requires authentication):

1. **Imports:**
   - { Router } from 'express'
   - { requireAuth } from '../middleware/requireAuth.js'
   - { statusPageService } from '../services/statusPage.service.js'
   - { statusComponentService } from '../services/statusComponent.service.js'
   - { maintenanceService } from '../services/maintenance.service.js'
   - { statusSubscriberService } from '../services/statusSubscriber.service.js'
   - { statusIncidentService } from '../services/statusIncident.service.js'
   - { auditService } from '../services/audit.service.js'

2. **Create router:**
```typescript
const router = Router();
router.use(requireAuth); // All routes require authentication
```

3. **Status Page CRUD:**

**POST /status-pages** - Create status page
- Body: { name, description?, teamId, isPublic? }
- Verify user is team admin or platform admin
- Call statusPageService.create()
- Log audit event: 'status.page.created'
- Return 201 with page including accessToken

**GET /status-pages** - List user's team's status pages
- Query: teamId (optional, defaults to user's teams)
- Call statusPageService.listByTeam()
- Return 200 with pages

**GET /status-pages/:id** - Get status page details
- Verify user has access to team
- Call statusPageService.getById()
- Return 200 with page and components

**PUT /status-pages/:id** - Update status page
- Body: { name?, description?, isPublic? }
- Verify team admin
- Call statusPageService.update()
- Log audit event
- Return 200

**DELETE /status-pages/:id** - Delete status page
- Verify team admin
- Call statusPageService.delete()
- Log audit event
- Return 204

**POST /status-pages/:id/regenerate-token** - Regenerate access token
- Verify team admin
- Call statusPageService.regenerateAccessToken()
- Log audit event
- Return 200 with new token

4. **Component routes:**

**POST /status-pages/:id/components** - Add component
- Body: { name, description?, teamId?, serviceIdentifier? }
- Verify team admin
- Call statusComponentService.create()
- Return 201

**PUT /status-pages/:pageId/components/:componentId** - Update component
- Body: { name?, description?, teamId?, serviceIdentifier? }
- Verify team admin
- Call statusComponentService.update()
- Return 200

**DELETE /status-pages/:pageId/components/:componentId** - Delete component
- Verify team admin
- Call statusComponentService.delete()
- Return 204

**PUT /status-pages/:id/components/reorder** - Reorder components
- Body: { componentIds: string[] }
- Verify team admin
- Call statusComponentService.reorder()
- Return 200

5. **Maintenance routes:**

**POST /status-pages/:id/maintenance** - Schedule maintenance
- Body: { title, description?, componentIds, startTime, endTime, autoUpdateStatus?, notifySubscribers?, recurrenceRule? }
- Verify team admin
- Call maintenanceService.create()
- Return 201

**GET /status-pages/:id/maintenance** - List maintenance windows
- Query: status (optional filter)
- Call maintenanceService.listByStatusPage()
- Return 200

**PUT /status-pages/:pageId/maintenance/:maintenanceId** - Update maintenance
- Verify team admin
- Call maintenanceService.update()
- Return 200

**DELETE /status-pages/:pageId/maintenance/:maintenanceId** - Cancel/delete maintenance
- Verify team admin
- Call maintenanceService.cancel() or delete()
- Return 204

6. **Status incident routes:**

**POST /status-pages/:id/incidents** - Create status incident
- Body: { title, message?, severity, affectedComponentIds, incidentId? }
- Verify team admin
- Call statusIncidentService.create()
- Return 201

**POST /status-pages/:pageId/incidents/:incidentId/updates** - Add update
- Body: { status, message }
- Verify team admin
- Call statusIncidentService.addUpdate()
- Return 200

**GET /status-pages/:id/incidents** - List status incidents
- Query: status (optional filter)
- Call statusIncidentService.listByStatusPage()
- Return 200

7. **Subscriber routes (admin view):**

**GET /status-pages/:id/subscribers** - List subscribers
- Verify team admin
- Call statusSubscriberService.listByStatusPage()
- Return 200

Export: export const statusPageRoutes = router;
  </action>
  <verify>npx tsc --noEmit src/routes/statusPage.routes.ts</verify>
  <done>Complete admin API for status pages, components, maintenance, incidents, subscribers</done>
</task>

<task type="auto">
  <name>Task 2: Create public status page routes</name>
  <files>src/routes/statusPublic.routes.ts</files>
  <action>
Create public routes per research Pattern 5 (no auth required, token-protected):

1. **Imports:**
   - { Router } from 'express'
   - { statusPageService } from '../services/statusPage.service.js'
   - { statusComputationService } from '../services/statusComputation.service.js'
   - { statusIncidentService } from '../services/statusIncident.service.js'
   - { statusSubscriberService } from '../services/statusSubscriber.service.js'

2. **Create router:**
```typescript
const router = Router();
// No requireAuth - these are public endpoints
```

3. **GET /status/:slug** - Get status page with computed statuses
   - Query param: token (for private pages)
   - Call statusPageService.getBySlug(slug, token)
   - If not found or access denied, return 404
   - For each component, get computed status via statusComputationService.getStatus()
   - Compute overall status (worst component status)
   - Return:
     ```typescript
     {
       id: page.id,
       name: page.name,
       description: page.description,
       slug: page.slug,
       overallStatus: computedOverall,
       components: [
         { id, name, description, status, statusUpdatedAt, displayOrder }
       ],
       updatedAt: new Date().toISOString()
     }
     ```
   - Do NOT return accessToken or internal details

4. **GET /status/:slug/history** - Recent incidents for status page
   - Query: days (default 7, max 90)
   - Verify access (slug + optional token)
   - Call statusIncidentService.getHistory(pageId, days)
   - Return resolved incidents with updates

5. **GET /status/:slug/maintenance** - Upcoming/active maintenance
   - Verify access
   - Get maintenance where status in ['SCHEDULED', 'IN_PROGRESS']
   - Return list with component names

6. **POST /status/:slug/subscribe** - Subscribe to updates
   - Body: { channel, destination, componentIds?, notifyOn? }
   - Verify access (private pages still need token)
   - Call statusSubscriberService.subscribe()
   - Return { success, requiresVerification }

7. **GET /status/subscribe/verify** - Verify email subscription
   - Query: token
   - Call statusSubscriberService.verify(token)
   - Return success page or redirect

8. **GET /status/unsubscribe** - Unsubscribe link handler
   - Query: token or subscriberId
   - Deactivate subscription
   - Return success page

Export: export const statusPublicRoutes = router;
  </action>
  <verify>npx tsc --noEmit src/routes/statusPublic.routes.ts</verify>
  <done>Public API for viewing status pages, history, and subscriber self-service</done>
</task>

<task type="auto">
  <name>Task 3: Mount routes in Express app</name>
  <files>src/app.ts</files>
  <action>
Mount the new routes in the Express application:

1. **Add imports at top of file:**
```typescript
import { statusPageRoutes } from './routes/statusPage.routes.js';
import { statusPublicRoutes } from './routes/statusPublic.routes.js';
```

2. **Mount public routes BEFORE auth middleware:**
   - Find where routes are mounted (typically after body parsing, before or with auth routes)
   - Add: `app.use('/status', statusPublicRoutes);`
   - This must be before general auth middleware so public routes work without session

3. **Mount admin routes AFTER auth setup:**
   - With other authenticated routes
   - Add: `app.use('/api/status-pages', statusPageRoutes);`

4. **Verify route order:**
   - Public: /status/:slug (no auth)
   - Public: /status/subscribe/* (no auth)
   - Admin: /api/status-pages/* (requires auth)

Note: Keep the route paths consistent with existing patterns in the codebase. Check how other routes are mounted (likely /api/... pattern for authenticated routes).
  </action>
  <verify>grep -E "(statusPageRoutes|statusPublicRoutes)" src/app.ts</verify>
  <done>Routes mounted in Express app with correct order (public before auth, admin after)</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Admin routes require authentication
3. Public routes work without authentication
4. Private pages require access token in query
5. Routes follow existing codebase patterns
6. All CRUD operations have corresponding endpoints
</verification>

<success_criteria>
- POST /api/status-pages creates new status page with access token
- GET /status/:slug returns computed status for all components
- POST /status/:slug/subscribe allows public subscription
- GET /status/subscribe/verify handles email verification
- Private pages reject requests without valid token
- Admin routes verify team membership/admin role
</success_criteria>

<output>
After completion, create `.planning/phases/09-status-pages/09-05-SUMMARY.md`
</output>

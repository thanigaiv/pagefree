---
phase: 09-status-pages
plan: 03
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - src/services/maintenance.service.ts
  - src/services/statusIncident.service.ts
  - src/queues/maintenance.queue.ts
  - src/workers/maintenance.worker.ts
autonomous: true

must_haves:
  truths:
    - "User can schedule maintenance windows with start/end times"
    - "System automatically starts/completes maintenance at scheduled times"
    - "User can post status incident updates"
  artifacts:
    - path: "src/services/maintenance.service.ts"
      provides: "Maintenance window scheduling"
      exports: ["maintenanceService"]
    - path: "src/services/statusIncident.service.ts"
      provides: "Status incident management"
      exports: ["statusIncidentService"]
    - path: "src/queues/maintenance.queue.ts"
      provides: "BullMQ queue for maintenance jobs"
      exports: ["maintenanceQueue", "scheduleMaintenanceJobs"]
    - path: "src/workers/maintenance.worker.ts"
      provides: "Worker to process maintenance start/end"
      exports: ["maintenanceWorker"]
  key_links:
    - from: "src/services/maintenance.service.ts"
      to: "src/queues/maintenance.queue.ts"
      via: "scheduleMaintenanceJobs function"
      pattern: "scheduleMaintenanceJobs"
    - from: "src/workers/maintenance.worker.ts"
      to: "prisma.maintenanceWindow"
      via: "status updates"
      pattern: "prisma\\.maintenanceWindow\\.update"
---

<objective>
Create maintenance window scheduling and status incident management services.

Purpose: Implement STATUS-03 (manual maintenance updates) and support STATUS-02 (maintenance affects component status).
Output: Maintenance service with BullMQ scheduling and status incident service.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-status-pages/09-RESEARCH.md
@.planning/phases/09-status-pages/09-01-SUMMARY.md
@src/queues/escalation.queue.ts
@src/workers/escalation.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create maintenance queue</name>
  <files>src/queues/maintenance.queue.ts</files>
  <action>
Create BullMQ queue for maintenance window jobs per existing escalation queue pattern:

1. **Imports:**
   - { Queue } from 'bullmq'
   - { redis } from '../config/redis.js'
   - { logger } from '../config/logger.js'

2. **MaintenanceJobData interface:**
```typescript
interface MaintenanceJobData {
  maintenanceId: string;
  action: 'start' | 'end';
}
```

3. **Create queue:**
```typescript
export const maintenanceQueue = new Queue<MaintenanceJobData>('maintenance', {
  connection: redis,
  defaultJobOptions: {
    attempts: 3,
    backoff: { type: 'exponential', delay: 30000 },
    removeOnComplete: true,
    removeOnFail: 100
  }
});
```

4. **scheduleMaintenanceJobs(maintenance) function:**
   - Calculate delay for start job: startTime - now
   - Calculate delay for end job: endTime - now
   - If start time is in future, add 'start' job with delay
   - Add 'end' job with delay
   - Return job IDs
   - If start time is in past but end is future, only add end job

5. **cancelMaintenanceJobs(maintenanceId) function:**
   - Find jobs by maintenanceId in data
   - Remove from queue
   - Return count removed

Export: maintenanceQueue, scheduleMaintenanceJobs, cancelMaintenanceJobs
  </action>
  <verify>npx tsc --noEmit src/queues/maintenance.queue.ts</verify>
  <done>BullMQ queue for maintenance scheduling with start/end job types</done>
</task>

<task type="auto">
  <name>Task 2: Create maintenance service</name>
  <files>src/services/maintenance.service.ts</files>
  <action>
Create MaintenanceService per research Pattern 3:

1. **Imports:**
   - prisma from '../config/database.js'
   - { RRule } from 'rrule'
   - { scheduleMaintenanceJobs, cancelMaintenanceJobs } from '../queues/maintenance.queue.js'
   - { logger } from '../config/logger.js'
   - { CreateMaintenanceWindowInput, MaintenanceStatus } from '../types/statusPage.js'

2. **create(statusPageId, createdById, data: CreateMaintenanceWindowInput):**
   - Validate endTime > startTime
   - Validate componentIds belong to statusPageId
   - Create MaintenanceWindow with Prisma
   - Connect components via relation
   - If autoUpdateStatus or notifySubscribers, call scheduleMaintenanceJobs
   - Return created maintenance

3. **update(id, data):**
   - Update title, description, startTime, endTime, autoUpdateStatus, notifySubscribers
   - If times changed and status is SCHEDULED:
     - Cancel existing jobs
     - Reschedule with new times
   - Return updated maintenance

4. **cancel(id):**
   - Update status to 'CANCELLED'
   - Cancel scheduled jobs
   - Return void

5. **delete(id):**
   - Cancel scheduled jobs
   - Delete maintenance window
   - Return void

6. **startMaintenance(id):**
   - Called by worker when start time reached
   - Update status to 'IN_PROGRESS'
   - If autoUpdateStatus, recompute affected component statuses
   - Return void

7. **completeMaintenance(id):**
   - Called by worker when end time reached
   - Update status to 'COMPLETED'
   - If autoUpdateStatus, recompute affected component statuses
   - Return void

8. **getActiveForComponent(componentId): Promise<MaintenanceWindow[]>**
   - Find maintenance windows that:
     - Affect this component (via relation)
     - Status is 'IN_PROGRESS'
   - Used by status computation service

9. **listByStatusPage(statusPageId, options?):**
   - Find maintenance windows for page
   - Filter by status if provided
   - Order by startTime
   - Include components

10. **isMaintenanceActive(window, now: Date): boolean** (for recurring)
    - If no recurrenceRule, simple time range check
    - If recurring, use RRule to find occurrences containing now
    - Return boolean

Export singleton: export const maintenanceService = new MaintenanceService();
  </action>
  <verify>npx tsc --noEmit src/services/maintenance.service.ts</verify>
  <done>MaintenanceService with scheduling, start/complete, and recurrence support</done>
</task>

<task type="auto">
  <name>Task 3: Create maintenance worker and status incident service</name>
  <files>src/workers/maintenance.worker.ts, src/services/statusIncident.service.ts</files>
  <action>
**Part A: Create maintenance worker (src/workers/maintenance.worker.ts):**

1. **Imports:**
   - { Worker, Job } from 'bullmq'
   - { redis } from '../config/redis.js'
   - { maintenanceService } from '../services/maintenance.service.js'
   - { logger } from '../config/logger.js'

2. **Process function:**
```typescript
async function processMaintenance(job: Job) {
  const { maintenanceId, action } = job.data;

  logger.info({ maintenanceId, action }, 'Processing maintenance job');

  if (action === 'start') {
    await maintenanceService.startMaintenance(maintenanceId);
  } else if (action === 'end') {
    await maintenanceService.completeMaintenance(maintenanceId);
  }

  logger.info({ maintenanceId, action }, 'Maintenance job completed');
}
```

3. **Create worker:**
```typescript
export const maintenanceWorker = new Worker('maintenance', processMaintenance, {
  connection: redis,
  concurrency: 5
});
```

4. **Error handling:**
```typescript
maintenanceWorker.on('failed', (job, err) => {
  logger.error({ jobId: job?.id, error: err.message }, 'Maintenance job failed');
});
```

Export: maintenanceWorker

**Part B: Create status incident service (src/services/statusIncident.service.ts):**

1. **Imports:**
   - prisma from '../config/database.js'
   - { logger } from '../config/logger.js'
   - { StatusIncidentStatus, StatusIncidentSeverity, StatusUpdate } from '../types/statusPage.js'

2. **create(statusPageId, data):**
   - Create StatusIncident with initial status (INVESTIGATING)
   - Optional incidentId link to platform incident
   - Return created status incident

3. **addUpdate(id, update: { status, message }):**
   - Get current updates array
   - Append new update with timestamp
   - Update status field to latest
   - If status is RESOLVED, set resolvedAt
   - Return updated incident

4. **resolve(id, message?):**
   - Add update with status=RESOLVED
   - Set resolvedAt
   - Return void

5. **linkToIncident(id, incidentId):**
   - Update statusIncident.incidentId
   - Used for auto-created status incidents from platform incidents

6. **listByStatusPage(statusPageId, options?):**
   - Find status incidents
   - Filter by status if provided
   - Order by createdAt desc
   - Limit for pagination

7. **getHistory(statusPageId, days: number):**
   - Get resolved incidents in last N days
   - For status page history display

Export singleton: export const statusIncidentService = new StatusIncidentService();
  </action>
  <verify>npx tsc --noEmit src/workers/maintenance.worker.ts src/services/statusIncident.service.ts</verify>
  <done>Maintenance worker processes scheduled jobs; StatusIncidentService manages public incident updates</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all files
2. maintenanceQueue can schedule jobs with delays
3. maintenanceService creates windows and schedules jobs
4. maintenanceWorker processes start/end actions
5. statusIncidentService can create incidents and add updates
6. Updates are stored as JSON array with timestamps
</verification>

<success_criteria>
- Maintenance windows can be scheduled for future times
- BullMQ jobs trigger start/end at correct times
- Maintenance completion triggers status recomputation
- Status incidents track public-facing incident information
- Updates history is maintained as JSON array
</success_criteria>

<output>
After completion, create `.planning/phases/09-status-pages/09-03-SUMMARY.md`
</output>

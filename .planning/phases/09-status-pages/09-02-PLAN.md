---
phase: 09-status-pages
plan: 02
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - src/services/statusPage.service.ts
  - src/services/statusComponent.service.ts
  - src/services/statusComputation.service.ts
autonomous: true

must_haves:
  truths:
    - "User can create a status page with components"
    - "System computes component status from active incidents"
    - "Status is cached in Redis with TTL"
  artifacts:
    - path: "src/services/statusPage.service.ts"
      provides: "Status page CRUD operations"
      exports: ["statusPageService"]
    - path: "src/services/statusComponent.service.ts"
      provides: "Component management"
      exports: ["statusComponentService"]
    - path: "src/services/statusComputation.service.ts"
      provides: "Status computation from incidents"
      exports: ["statusComputationService"]
  key_links:
    - from: "src/services/statusComputation.service.ts"
      to: "prisma.incident"
      via: "findMany for active incidents"
      pattern: "prisma\\.incident\\.findMany"
    - from: "src/services/statusComputation.service.ts"
      to: "redis"
      via: "Redis cache for computed status"
      pattern: "redis\\.(get|setex|del)"
---

<objective>
Create core services for status page management and automatic status computation from incidents.

Purpose: Implement STATUS-01 (create status pages) and STATUS-02 (automatic updates from incidents).
Output: Status page service, component service, and status computation service.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-status-pages/09-RESEARCH.md
@.planning/phases/09-status-pages/09-01-SUMMARY.md
@src/services/incident.service.ts
@src/config/redis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create status page service</name>
  <files>src/services/statusPage.service.ts</files>
  <action>
Create StatusPageService with CRUD operations:

1. **Imports:**
   - prisma from '../config/database.js'
   - crypto for access token generation
   - logger from '../config/logger.js'

2. **create(data):**
   - Generate unique slug from name (lowercase, hyphens, alphanumeric only)
   - If not isPublic, generate accessToken: crypto.randomBytes(32).toString('hex')
   - Create StatusPage with Prisma
   - Return created page with id, name, slug, accessToken (only on create)

3. **getById(id):**
   - Find StatusPage with components (ordered by displayOrder)
   - Return null if not found

4. **getBySlug(slug, accessToken?):**
   - Find StatusPage by slug
   - If not isPublic and accessToken doesn't match, return null
   - Include components ordered by displayOrder
   - Return page data (without accessToken in response)

5. **listByTeam(teamId):**
   - Find all StatusPages for team
   - Include component count
   - Order by createdAt desc

6. **update(id, data):**
   - Update name, description, isPublic
   - If changing isPublic from true to false and no accessToken, generate one
   - Return updated page

7. **delete(id):**
   - Delete StatusPage (cascades to components, subscribers, etc.)
   - Return void

8. **regenerateAccessToken(id):**
   - Generate new accessToken
   - Update page
   - Return new token (only time token is returned)

Helper function: slugify(name: string): string
- Convert to lowercase, replace spaces with hyphens, remove non-alphanumeric except hyphens
- Append short random suffix to ensure uniqueness

Export singleton: export const statusPageService = new StatusPageService();
  </action>
  <verify>npx tsc --noEmit src/services/statusPage.service.ts</verify>
  <done>StatusPageService with CRUD operations and access token management</done>
</task>

<task type="auto">
  <name>Task 2: Create status component service</name>
  <files>src/services/statusComponent.service.ts</files>
  <action>
Create StatusComponentService for component management:

1. **Imports:**
   - prisma from '../config/database.js'
   - logger from '../config/logger.js'
   - ComponentStatus from '../types/statusPage.js'

2. **create(statusPageId, data):**
   - Get max displayOrder for page and increment
   - Create StatusPageComponent
   - If teamId provided, validate team exists
   - Return created component

3. **update(id, data):**
   - Update name, description, teamId, serviceIdentifier
   - Return updated component

4. **delete(id):**
   - Delete component
   - Return void

5. **reorder(statusPageId, componentIds: string[]):**
   - Update displayOrder for each component based on array position
   - Use transaction for atomicity
   - Return void

6. **getByStatusPage(statusPageId):**
   - Find all components for page
   - Order by displayOrder
   - Include currentStatus and statusUpdatedAt

7. **updateStatus(componentId, status: ComponentStatus):**
   - Update currentStatus and statusUpdatedAt
   - Called by statusComputation service when status changes
   - Return void

Export singleton: export const statusComponentService = new StatusComponentService();
  </action>
  <verify>npx tsc --noEmit src/services/statusComponent.service.ts</verify>
  <done>StatusComponentService with component CRUD and status update</done>
</task>

<task type="auto">
  <name>Task 3: Create status computation service</name>
  <files>src/services/statusComputation.service.ts</files>
  <action>
Create StatusComputationService per research Pattern 1 and Pattern 6:

1. **Imports:**
   - prisma from '../config/database.js'
   - redis from '../config/redis.js'
   - logger from '../config/logger.js'
   - { ComponentStatus, STATUS_SEVERITY_ORDER, INCIDENT_PRIORITY_TO_STATUS } from '../types/statusPage.js'

2. **Constants:**
   - STATUS_CACHE_PREFIX = 'status:component:'
   - STATUS_CACHE_TTL = 300 (5 minutes)

3. **getStatus(componentId): Promise<ComponentStatus>**
   - Check Redis cache first
   - If cached, return cached value
   - If not cached, compute and cache
   - Return status

4. **computeStatus(componentId): Promise<ComponentStatus>**
   - Get component with maintenanceWindows where status = 'IN_PROGRESS'
   - If component not found, return 'OPERATIONAL'
   - Check hasActiveMaintenance = maintenanceWindows.length > 0
   - Find active incidents matching component's teamId and optional serviceIdentifier:
     ```typescript
     const whereClause: any = {
       status: { in: ['OPEN', 'ACKNOWLEDGED'] }
     };
     if (component.teamId) {
       whereClause.teamId = component.teamId;
     }
     ```
   - Include alerts with source field for serviceIdentifier matching
   - Filter by serviceIdentifier if specified
   - Compute worst status using STATUS_SEVERITY_ORDER
   - If hasActiveMaintenance and worst is OPERATIONAL, return 'UNDER_MAINTENANCE'
   - Return computed status

5. **setCachedStatus(componentId, status): Promise<void>**
   - Set Redis cache with TTL
   - Update component.currentStatus and statusUpdatedAt in database
   - Use Promise.all for parallel updates

6. **invalidateStatus(componentId): Promise<void>**
   - Delete Redis cache key
   - Called when manual refresh needed

7. **recomputeForIncident(incidentId): Promise<void>**
   - Called when incident state changes
   - Get incident with alerts (for source field)
   - Find all components that might be affected:
     - teamId matches incident.teamId AND (serviceIdentifier is null OR serviceIdentifier matches alert source)
   - For each component:
     - Get old status from currentStatus field
     - Compute new status
     - If changed:
       - Update cache and database
       - Log status change
       - (Notification dispatch added in later plan)

8. **warmCache(): Promise<void>**
   - Called on application startup (per research pitfall #2)
   - Find all components
   - Compute and cache status for each
   - Log completion

9. **computeOverallStatus(componentStatuses: ComponentStatus[]): ComponentStatus**
   - Return worst status from array using STATUS_SEVERITY_ORDER
   - If empty, return 'OPERATIONAL'

Export singleton: export const statusComputationService = new StatusComputationService();
  </action>
  <verify>npx tsc --noEmit src/services/statusComputation.service.ts</verify>
  <done>StatusComputationService computes status from incidents with Redis caching</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all three services
2. statusPageService can create page with auto-generated slug and accessToken
3. statusComponentService can create components with displayOrder
4. statusComputationService computes status using incident priority mapping
5. Redis cache operations use correct key prefix and TTL
</verification>

<success_criteria>
- StatusPageService handles CRUD with access token generation
- StatusComponentService manages components with ordering
- StatusComputationService computes status from incidents using priority hierarchy
- Status is cached in Redis with 5-minute TTL
- Incident changes trigger status recomputation for affected components
</success_criteria>

<output>
After completion, create `.planning/phases/09-status-pages/09-02-SUMMARY.md`
</output>

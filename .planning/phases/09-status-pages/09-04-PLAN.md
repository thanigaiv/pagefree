---
phase: 09-status-pages
plan: 04
type: execute
wave: 3
depends_on: [09-02, 09-03]
files_modified:
  - src/services/statusSubscriber.service.ts
  - src/services/statusNotification.service.ts
  - src/queues/statusNotification.queue.ts
  - src/workers/statusNotification.worker.ts
autonomous: true

must_haves:
  truths:
    - "User can subscribe to status page updates"
    - "Email subscribers must verify their address"
    - "System notifies subscribers on status changes"
    - "Notifications are queued and processed asynchronously"
  artifacts:
    - path: "src/services/statusSubscriber.service.ts"
      provides: "Subscriber management with verification"
      exports: ["statusSubscriberService"]
    - path: "src/services/statusNotification.service.ts"
      provides: "Status change notification dispatch"
      exports: ["statusNotificationService"]
    - path: "src/queues/statusNotification.queue.ts"
      provides: "BullMQ queue for notifications"
      exports: ["statusNotificationQueue"]
    - path: "src/workers/statusNotification.worker.ts"
      provides: "Worker to send notifications"
      exports: ["statusNotificationWorker"]
  key_links:
    - from: "src/services/statusNotification.service.ts"
      to: "src/queues/statusNotification.queue.ts"
      via: "queue.add for notification jobs"
      pattern: "statusNotificationQueue\\.add"
    - from: "src/workers/statusNotification.worker.ts"
      to: "email/webhook channels"
      via: "channel-specific delivery"
      pattern: "(sendEmail|fetch)"
---

<objective>
Create subscriber management and notification system for status page updates.

Purpose: Implement STATUS-04 (notify subscribers of status changes).
Output: Subscriber service with verification, notification service, queue, and worker.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-status-pages/09-RESEARCH.md
@.planning/phases/09-status-pages/09-02-SUMMARY.md
@.planning/phases/09-status-pages/09-03-SUMMARY.md
@src/services/notification/channels/email.channel.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subscriber service</name>
  <files>src/services/statusSubscriber.service.ts</files>
  <action>
Create StatusSubscriberService per research Pattern 4:

1. **Imports:**
   - crypto for token generation
   - prisma from '../config/database.js'
   - { logger } from '../config/logger.js'
   - { SubscriberChannel, NotifyOnEvent } from '../types/statusPage.js'
   - { statusNotificationQueue } from '../queues/statusNotification.queue.js'

2. **subscribe(statusPageId, channel, destination, options?):**
   - Check for existing subscription (unique constraint)
   - If exists and isActive, throw "Already subscribed"
   - If exists and not active, reactivate
   - Generate verifyToken for EMAIL channel: crypto.randomBytes(32).toString('hex')
   - Create StatusSubscriber:
     - isVerified: channel !== 'EMAIL' (webhooks/slack don't need verification)
     - notifyOn defaults to ['degraded', 'outage', 'maintenance', 'resolved']
     - componentIds defaults to [] (all components)
   - If EMAIL, queue verification email
   - Return { subscriber, requiresVerification: channel === 'EMAIL' }

3. **verify(token):**
   - Find subscriber by verifyToken
   - If not found, return false
   - Update isVerified = true, verifyToken = null
   - Return true

4. **unsubscribe(subscriberId):**
   - Update isActive = false
   - Return void

5. **unsubscribeByToken(token):**
   - For email unsubscribe links
   - Find by some identifier in destination
   - Deactivate
   - Return boolean

6. **updatePreferences(subscriberId, options):**
   - Update notifyOn and/or componentIds
   - Return updated subscriber

7. **listByStatusPage(statusPageId):**
   - Find active subscribers
   - Return list

8. **getActiveSubscribersForNotification(statusPageId, componentId, notifyType):**
   - Find subscribers where:
     - statusPageId matches
     - isActive = true
     - isVerified = true
     - componentIds is empty OR contains componentId
     - notifyOn contains notifyType
   - Return list of subscribers

**Private helper: sendVerificationEmail(subscriber, token):**
   - Get status page name
   - Build verify URL: `${API_BASE_URL}/status/subscribe/verify?token=${token}`
   - Queue via statusNotificationQueue:
     ```typescript
     await statusNotificationQueue.add('verify-email', {
       type: 'verification',
       channel: 'email',
       destination: subscriber.destination,
       data: { verifyUrl, statusPageName }
     });
     ```

Export singleton: export const statusSubscriberService = new StatusSubscriberService();
  </action>
  <verify>npx tsc --noEmit src/services/statusSubscriber.service.ts</verify>
  <done>StatusSubscriberService with subscription, verification, and preference management</done>
</task>

<task type="auto">
  <name>Task 2: Create notification queue and worker</name>
  <files>src/queues/statusNotification.queue.ts, src/workers/statusNotification.worker.ts</files>
  <action>
**Part A: Create notification queue (src/queues/statusNotification.queue.ts):**

1. **Imports:**
   - { Queue } from 'bullmq'
   - { redis } from '../config/redis.js'

2. **StatusNotificationJobData type:**
```typescript
interface StatusNotificationJobData {
  type: 'status_change' | 'verification' | 'maintenance';
  subscriberId?: string;
  channel: string;
  destination: string;
  data: {
    statusPageId?: string;
    statusPageName?: string;
    componentName?: string;
    previousStatus?: string;
    newStatus?: string;
    message?: string;
    verifyUrl?: string;
    maintenanceTitle?: string;
    maintenanceStartTime?: string;
    maintenanceEndTime?: string;
  };
}
```

3. **Create queue:**
```typescript
export const statusNotificationQueue = new Queue<StatusNotificationJobData>('status-notification', {
  connection: redis,
  defaultJobOptions: {
    attempts: 3,
    backoff: { type: 'exponential', delay: 30000 },
    removeOnComplete: 100,
    removeOnFail: 100
  }
});
```

Export: statusNotificationQueue, StatusNotificationJobData

**Part B: Create notification worker (src/workers/statusNotification.worker.ts):**

1. **Imports:**
   - { Worker, Job } from 'bullmq'
   - { redis } from '../config/redis.js'
   - { logger } from '../config/logger.js'
   - { sesClient } from '../config/ses.js' (or existing email sender)

2. **Process function:**
```typescript
async function processStatusNotification(job: Job<StatusNotificationJobData>) {
  const { type, channel, destination, data } = job.data;

  logger.info({ type, channel, destination }, 'Processing status notification');

  switch (channel) {
    case 'EMAIL':
      await sendEmailNotification(type, destination, data);
      break;
    case 'WEBHOOK':
      await sendWebhookNotification(type, destination, data);
      break;
    case 'SLACK':
      await sendSlackNotification(type, destination, data);
      break;
    default:
      logger.warn({ channel }, 'Unknown notification channel');
  }
}
```

3. **sendEmailNotification(type, email, data):**
   - Use existing SES/email infrastructure
   - For verification: subject "Verify your status page subscription"
   - For status_change: subject "[Status] {componentName} is now {newStatus}"
   - For maintenance: subject "[Maintenance] {maintenanceTitle}"
   - Simple text/html body (can enhance templates later)

4. **sendWebhookNotification(type, url, data):**
   - POST to URL with JSON body
   - Timeout: 5000ms
   - Include: type, statusPageId, componentName, status, message, timestamp
   - Log success/failure

5. **sendSlackNotification(type, webhookUrl, data):**
   - POST to Slack webhook URL
   - Format as Slack message blocks
   - Color-coded by status (green=operational, yellow=degraded, red=outage)

6. **Create worker:**
```typescript
export const statusNotificationWorker = new Worker(
  'status-notification',
  processStatusNotification,
  {
    connection: redis,
    concurrency: 10,
    limiter: { max: 50, duration: 60000 } // 50/min rate limit
  }
);
```

7. **Error handling:**
```typescript
statusNotificationWorker.on('failed', (job, err) => {
  logger.error({ jobId: job?.id, error: err.message }, 'Status notification failed');
});
```

Export: statusNotificationWorker
  </action>
  <verify>npx tsc --noEmit src/queues/statusNotification.queue.ts src/workers/statusNotification.worker.ts</verify>
  <done>Queue and worker for async notification delivery via email, webhook, Slack</done>
</task>

<task type="auto">
  <name>Task 3: Create status notification service</name>
  <files>src/services/statusNotification.service.ts</files>
  <action>
Create StatusNotificationService to dispatch notifications on status changes:

1. **Imports:**
   - prisma from '../config/database.js'
   - { statusNotificationQueue } from '../queues/statusNotification.queue.js'
   - { statusSubscriberService } from './statusSubscriber.service.js'
   - { logger } from '../config/logger.js'
   - { StatusChangeNotification, ComponentStatus } from '../types/statusPage.js'

2. **notifyStatusChange(notification: StatusChangeNotification):**
   - Determine notification type(s) from status change:
     ```typescript
     const notifyTypes = getNotifyTypesForChange(
       notification.previousStatus,
       notification.newStatus
     );
     ```
   - Get status page for name
   - Get active, verified subscribers who want these notification types
   - Queue notification for each subscriber:
     ```typescript
     for (const subscriber of subscribers) {
       await statusNotificationQueue.add('status-change', {
         type: 'status_change',
         subscriberId: subscriber.id,
         channel: subscriber.channel,
         destination: subscriber.destination,
         data: {
           statusPageId: notification.statusPageId,
           statusPageName: statusPage.name,
           componentName: notification.componentName,
           previousStatus: notification.previousStatus,
           newStatus: notification.newStatus,
           message: notification.message
         }
       });
     }
     ```
   - Log notification count

3. **notifyMaintenanceScheduled(maintenanceId):**
   - Get maintenance with status page and components
   - Get subscribers who want maintenance notifications
   - Queue notification for each

4. **notifyMaintenanceStarted(maintenanceId):**
   - Similar to scheduled, different message

5. **notifyMaintenanceCompleted(maintenanceId):**
   - Similar, include completion message

6. **getNotifyTypesForChange(previous, current): string[]:**
   ```typescript
   const types: string[] = [];
   if (current === 'OPERATIONAL' && previous !== 'OPERATIONAL') {
     types.push('resolved');
   }
   if (current === 'DEGRADED_PERFORMANCE') {
     types.push('degraded');
   }
   if (['PARTIAL_OUTAGE', 'MAJOR_OUTAGE'].includes(current)) {
     types.push('outage');
   }
   if (current === 'UNDER_MAINTENANCE') {
     types.push('maintenance');
   }
   return types;
   ```

7. **Debounce logic (per research pitfall #1):**
   - Track recent status changes in Redis: `status:debounce:{componentId}` with 5 min TTL
   - If status changed back within 5 min, skip notification
   - Only notify on "stable" changes

Export singleton: export const statusNotificationService = new StatusNotificationService();
  </action>
  <verify>npx tsc --noEmit src/services/statusNotification.service.ts</verify>
  <done>StatusNotificationService dispatches notifications with debounce protection</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes for all files
2. statusSubscriberService generates verification tokens for email
3. statusNotificationQueue has proper job structure
4. statusNotificationWorker handles email, webhook, slack channels
5. statusNotificationService queues notifications for affected subscribers
6. Debounce prevents rapid notification spam
</verification>

<success_criteria>
- Subscribers can subscribe via email, webhook, or Slack
- Email subscribers receive verification email
- Status changes trigger notifications to verified subscribers
- Notifications queued async via BullMQ
- Worker sends to appropriate channel (email/webhook/Slack)
- 5-minute debounce prevents notification spam during flapping
</success_criteria>

<output>
After completion, create `.planning/phases/09-status-pages/09-04-SUMMARY.md`
</output>

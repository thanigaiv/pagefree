---
phase: 09-status-pages
plan: 06
type: execute
wave: 4
depends_on: [09-02, 09-04]
files_modified:
  - src/services/incident.service.ts
  - src/services/statusComputation.service.ts
  - src/services/socket.service.ts
  - src/app.ts
autonomous: true

must_haves:
  truths:
    - "Incident state changes trigger status recomputation"
    - "Status changes trigger subscriber notifications"
    - "Status changes broadcast via WebSocket"
    - "Status cache warms on application startup"
  artifacts:
    - path: "src/services/incident.service.ts"
      provides: "Incident hooks for status updates"
      contains: "statusComputationService.recomputeForIncident"
    - path: "src/services/statusComputation.service.ts"
      provides: "Full integration with notifications and socket"
      contains: "statusNotificationService"
    - path: "src/app.ts"
      provides: "Startup cache warming and worker initialization"
      contains: "warmCache"
  key_links:
    - from: "src/services/incident.service.ts"
      to: "src/services/statusComputation.service.ts"
      via: "recomputeForIncident call"
      pattern: "statusComputationService\\.recomputeForIncident"
    - from: "src/services/statusComputation.service.ts"
      to: "src/services/statusNotification.service.ts"
      via: "notifyStatusChange call"
      pattern: "statusNotificationService\\.notifyStatusChange"
---

<objective>
Integrate status page system with incident lifecycle, socket broadcasts, and application startup.

Purpose: Complete STATUS-02 (automatic updates) by wiring incident changes to status computation and notification.
Output: Full integration between incidents, status pages, notifications, and real-time updates.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-status-pages/09-RESEARCH.md
@.planning/phases/09-status-pages/09-02-SUMMARY.md
@.planning/phases/09-status-pages/09-04-SUMMARY.md
@src/services/incident.service.ts
@src/services/socket.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate status updates with incident lifecycle</name>
  <files>src/services/incident.service.ts</files>
  <action>
Add status page integration to incident service:

1. **Add import at top of file:**
```typescript
import { statusComputationService } from './statusComputation.service.js';
```

2. **Find or create incident state change hook:**
   - Look for existing patterns like onIncidentStateChanged or workflow triggers
   - If exists, add status recomputation call
   - If not, add hook in acknowledge(), resolve(), close() methods

3. **Add status recomputation after state changes:**

In acknowledge() method, after audit logging:
```typescript
// Trigger status page recomputation (async, don't block)
statusComputationService.recomputeForIncident(incidentId).catch(err => {
  logger.warn({ error: err.message, incidentId }, 'Failed to recompute status for incident');
});
```

In resolve() method, after audit logging:
```typescript
// Trigger status page recomputation (async, don't block)
statusComputationService.recomputeForIncident(incidentId).catch(err => {
  logger.warn({ error: err.message, incidentId }, 'Failed to recompute status for incident');
});
```

In any method that creates incidents or changes status:
- Add same status recomputation call
- Always wrap in try/catch with warning log (best-effort, don't block incident flow)

4. **Important: Use async fire-and-forget pattern:**
   - Status updates should not block incident operations
   - Use .catch() to log warnings but not throw
   - Per research: "Status update should succeed even if all notifications fail"
  </action>
  <verify>grep -n "statusComputationService" src/services/incident.service.ts</verify>
  <done>Incident state changes trigger status recomputation asynchronously</done>
</task>

<task type="auto">
  <name>Task 2: Complete status computation service with notifications and socket</name>
  <files>src/services/statusComputation.service.ts</files>
  <action>
Enhance statusComputationService to dispatch notifications and socket broadcasts:

1. **Add imports (if not already present):**
```typescript
import { statusNotificationService } from './statusNotification.service.js';
import { socketService } from './socket.service.js';
```

2. **Update recomputeForIncident() to trigger notifications:**

After detecting status change:
```typescript
if (oldStatus !== newStatus) {
  await this.setCachedStatus(component.id, newStatus);

  logger.info(
    { componentId: component.id, oldStatus, newStatus, incidentId },
    'Component status changed'
  );

  // Notify subscribers (async, best-effort)
  try {
    await statusNotificationService.notifyStatusChange({
      statusPageId: component.statusPageId,
      componentId: component.id,
      componentName: component.name,
      previousStatus: oldStatus as ComponentStatus,
      newStatus: newStatus,
      incidentId
    });
  } catch (err) {
    logger.warn({ error: (err as Error).message, componentId: component.id }, 'Failed to notify subscribers');
  }

  // Broadcast via WebSocket for real-time UI (best-effort)
  try {
    socketService.broadcast('status:changed', {
      statusPageId: component.statusPageId,
      componentId: component.id,
      componentName: component.name,
      status: newStatus,
      incidentId,
      updatedAt: new Date().toISOString()
    });
  } catch (err) {
    logger.warn({ error: (err as Error).message }, 'Failed to broadcast status change');
  }
}
```

3. **Add socket broadcast types to socket.service.ts if needed:**
   - Check if socketService.broadcast() exists
   - If not, use similar pattern to existing incident broadcasts
   - Event name: 'status:changed'

4. **Add maintenance status change triggers:**
   - When maintenance starts/completes, also recompute affected components
   - Call from maintenance.service.ts startMaintenance/completeMaintenance methods:
```typescript
for (const component of maintenance.components) {
  await statusComputationService.invalidateStatus(component.id);
  const newStatus = await statusComputationService.getStatus(component.id);
  // Notification and broadcast handled by getStatus -> setCachedStatus flow
}
```

Note: Ensure all external service calls are wrapped in try/catch with warning logs - status page updates should never break incident operations.
  </action>
  <verify>grep -n "statusNotificationService\|socketService" src/services/statusComputation.service.ts</verify>
  <done>Status computation triggers notifications and socket broadcasts on changes</done>
</task>

<task type="auto">
  <name>Task 3: Add startup initialization and worker startup</name>
  <files>src/app.ts</files>
  <action>
Add status page system initialization on application startup:

1. **Add imports:**
```typescript
import { statusComputationService } from './services/statusComputation.service.js';
import { maintenanceWorker } from './workers/maintenance.worker.js';
import { statusNotificationWorker } from './workers/statusNotification.worker.js';
```

2. **Find application startup/initialization section:**
   - Look for where other workers are started (escalation, notification)
   - Look for server.listen() or similar

3. **Add status cache warming on startup:**
```typescript
// After database connection is established, before server starts listening
// Warm status cache in background (don't block startup)
statusComputationService.warmCache().catch(err => {
  logger.warn({ error: err.message }, 'Failed to warm status cache on startup');
});
```

4. **Add worker startup:**
   - Near existing worker startups (if any)
```typescript
// Start status page workers
logger.info('Starting maintenance worker');
// maintenanceWorker is auto-started on import, just log
logger.info('Starting status notification worker');
// statusNotificationWorker is auto-started on import, just log
```

5. **Add graceful shutdown for workers:**
   - Find existing shutdown handlers (SIGTERM, SIGINT)
   - Add worker close:
```typescript
await maintenanceWorker.close();
await statusNotificationWorker.close();
```

6. **Check for Redis availability:**
   - Status page features depend on Redis for caching
   - If Redis connection check exists, add status warning:
```typescript
if (!redis.status === 'ready') {
  logger.warn('Redis not available - status page caching will not work');
}
```

Note: Follow existing patterns in app.ts for worker initialization and shutdown. The exact structure may vary based on current codebase patterns.
  </action>
  <verify>grep -n "statusComputationService\|maintenanceWorker\|statusNotificationWorker" src/app.ts</verify>
  <done>Application startup warms cache and initializes workers; graceful shutdown added</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Incident acknowledge triggers status recomputation
3. Status change logs appear in console
4. Socket broadcasts 'status:changed' events
5. Notification queue receives jobs on status change
6. Cache warms on startup without blocking
7. Workers shut down gracefully on SIGTERM
</verification>

<success_criteria>
- Acknowledging an incident triggers status recomputation for affected components
- Resolving an incident updates status to OPERATIONAL (if no other active incidents)
- Status changes are broadcast via WebSocket for real-time UI
- Subscribers receive notifications for status changes
- Status cache is warm on application startup
- All status page workers initialize and shutdown cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/09-status-pages/09-06-SUMMARY.md`
</output>

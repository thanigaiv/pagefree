---
phase: 16-runbook-integration
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - frontend/src/types/workflow.ts
  - frontend/src/components/workflow/WorkflowSidebar.tsx
  - frontend/src/components/workflow/NodeConfigPanel.tsx
  - frontend/src/pages/WorkflowBuilderPage.tsx
  - frontend/src/components/IncidentDetail.tsx
  - frontend/src/components/RunbookExecutionModal.tsx
  - frontend/src/hooks/useRunbooks.ts
autonomous: true

must_haves:
  truths:
    - "Workflow builder sidebar shows 'Run Runbook' action node with book icon"
    - "Runbook node config panel shows dropdown of APPROVED runbooks and parameter inputs"
    - "Incident detail page shows 'Run Runbook' button that opens modal"
    - "Runbook selection modal filters by team scope and shows confirmation dialog"
    - "Runbook execution status appears in incident timeline"
  artifacts:
    - path: "frontend/src/components/workflow/WorkflowSidebar.tsx"
      provides: "Runbook action node in sidebar"
      contains: "Run Runbook"
    - path: "frontend/src/components/workflow/NodeConfigPanel.tsx"
      provides: "RunbookConfig component"
      contains: "RunbookConfig"
    - path: "frontend/src/components/RunbookExecutionModal.tsx"
      provides: "Modal for manual runbook trigger"
      contains: "RunbookExecutionModal"
    - path: "frontend/src/hooks/useRunbooks.ts"
      provides: "React Query hooks for runbook API"
      contains: "useApprovedRunbooks"
  key_links:
    - from: "frontend/src/components/workflow/NodeConfigPanel.tsx"
      to: "frontend/src/hooks/useRunbooks.ts"
      via: "useApprovedRunbooks hook"
      pattern: "useApprovedRunbooks"
    - from: "frontend/src/components/IncidentDetail.tsx"
      to: "frontend/src/components/RunbookExecutionModal.tsx"
      via: "modal state and component"
      pattern: "RunbookExecutionModal"
---

<objective>
Add runbook action node to workflow builder and manual runbook trigger to incident detail page.

Purpose: Complete runbook integration in UI (AUTO-09 workflow builder, AUTO-10 incident page)
Output: Workflow builder supports runbook nodes, incident page has Run Runbook button with modal
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-runbook-integration/16-01-SUMMARY.md
@frontend/src/types/workflow.ts
@frontend/src/components/workflow/WorkflowSidebar.tsx
@frontend/src/components/workflow/NodeConfigPanel.tsx
@frontend/src/pages/WorkflowBuilderPage.tsx
@frontend/src/components/IncidentDetail.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Runbook Types and Hooks</name>
  <files>frontend/src/types/workflow.ts, frontend/src/hooks/useRunbooks.ts</files>
  <action>
1. Update frontend workflow types to match backend (frontend/src/types/workflow.ts):

Add RunbookActionData to ActionType and ActionData:
```typescript
export type ActionType = 'webhook' | 'jira' | 'linear' | 'runbook';

export interface RunbookActionData extends BaseActionData {
  actionType: 'runbook';
  config: RunbookActionConfig;
}

export interface RunbookActionConfig {
  runbookId: string;
  parameters: Record<string, unknown>;
}
```

Update ActionData union:
```typescript
export type ActionData = WebhookActionData | JiraActionData | LinearActionData | RunbookActionData;
```

Add type guard:
```typescript
export function isRunbookAction(data: ActionData): data is RunbookActionData {
  return data.actionType === 'runbook';
}
```

2. Create frontend/src/hooks/useRunbooks.ts with React Query hooks:
```typescript
/**
 * Runbook React Query Hooks
 *
 * Provides data fetching for runbook selection in workflow builder
 * and incident detail page.
 */

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';

// Types
export interface Runbook {
  id: string;
  name: string;
  description: string;
  approvalStatus: 'DRAFT' | 'APPROVED' | 'DEPRECATED';
  teamId: string | null;
  parameters: {
    type: 'object';
    properties: Record<string, {
      type: 'string' | 'number' | 'boolean';
      description?: string;
      default?: string | number | boolean;
      enum?: (string | number)[];
    }>;
    required?: string[];
  };
  version: number;
}

export interface RunbookExecution {
  id: string;
  runbookId: string;
  runbookName?: string;
  status: 'PENDING' | 'RUNNING' | 'SUCCESS' | 'FAILED';
  triggeredBy: 'workflow' | 'manual';
  executedBy?: { id: string; firstName: string; lastName: string };
  parameters: Record<string, unknown>;
  result?: unknown;
  error?: string;
  createdAt: string;
  completedAt?: string;
}

/**
 * Fetch APPROVED runbooks for workflow builder dropdown.
 * Optionally filter by teamId for team-scoped selection.
 */
export function useApprovedRunbooks(teamId?: string) {
  return useQuery({
    queryKey: ['runbooks', 'approved', teamId],
    queryFn: async () => {
      const params = new URLSearchParams({ approvalStatus: 'APPROVED' });
      if (teamId) params.append('teamId', teamId);
      const res = await api.get(`/runbooks?${params.toString()}`);
      return res.data.runbooks as Runbook[];
    }
  });
}

/**
 * Fetch single runbook by ID.
 */
export function useRunbook(id: string | undefined) {
  return useQuery({
    queryKey: ['runbook', id],
    queryFn: async () => {
      const res = await api.get(`/runbooks/${id}`);
      return res.data.runbook as Runbook;
    },
    enabled: !!id
  });
}

/**
 * Fetch runbook executions for an incident (for timeline display).
 */
export function useIncidentRunbookExecutions(incidentId: string) {
  return useQuery({
    queryKey: ['incidents', incidentId, 'runbook-executions'],
    queryFn: async () => {
      const res = await api.get(`/incidents/${incidentId}/runbooks/executions`);
      return res.data.executions as RunbookExecution[];
    }
  });
}

/**
 * Trigger manual runbook execution for an incident.
 */
export function useExecuteRunbook(incidentId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      runbookId,
      parameters
    }: {
      runbookId: string;
      parameters: Record<string, unknown>;
    }) => {
      const res = await api.post(
        `/incidents/${incidentId}/runbooks/${runbookId}/execute`,
        { parameters }
      );
      return res.data.execution;
    },
    onSuccess: () => {
      // Invalidate timeline and executions to show new entry
      queryClient.invalidateQueries({ queryKey: ['incidents', incidentId, 'timeline'] });
      queryClient.invalidateQueries({ queryKey: ['incidents', incidentId, 'runbook-executions'] });
    }
  });
}
```
  </action>
  <verify>npx tsc --noEmit passes for frontend; grep -q "useApprovedRunbooks" frontend/src/hooks/useRunbooks.ts</verify>
  <done>Frontend types updated with RunbookActionData, useRunbooks.ts provides hooks for runbook fetching and execution</done>
</task>

<task type="auto">
  <name>Task 2: Add Runbook Node to Workflow Builder</name>
  <files>frontend/src/components/workflow/WorkflowSidebar.tsx, frontend/src/components/workflow/NodeConfigPanel.tsx, frontend/src/pages/WorkflowBuilderPage.tsx</files>
  <action>
1. Update WorkflowSidebar.tsx to add runbook action node:

Import Book icon:
```typescript
import { ..., BookOpen } from 'lucide-react';
```

Add runbook to actionNodes array:
```typescript
const actionNodes: DraggableNodeConfig[] = [
  // ... existing webhook, jira, linear ...
  {
    type: 'action',
    subType: 'runbook',
    label: 'Run Runbook',
    description: 'Execute an approved runbook',
    icon: BookOpen,
    color: 'text-green-600 dark:text-green-400',
    iconBg: 'bg-green-100 dark:bg-green-900',
  },
];
```

2. Update NodeConfigPanel.tsx to add RunbookConfig:

Add imports:
```typescript
import { ..., BookOpen } from 'lucide-react';
import { useApprovedRunbooks, useRunbook } from '@/hooks/useRunbooks';
```

Add RunbookConfig component after LinearConfig:
```typescript
// =============================================================================
// RUNBOOK ACTION CONFIG
// =============================================================================

interface RunbookConfigProps {
  data: ActionData & { actionType: 'runbook' };
  onChange: (data: Partial<ActionData>) => void;
}

function RunbookConfig({ data, onChange }: RunbookConfigProps) {
  const config = data.config;
  const { data: runbooks, isLoading: loadingRunbooks } = useApprovedRunbooks();
  const { data: selectedRunbook } = useRunbook(config.runbookId);

  const updateConfig = (updates: Partial<typeof config>) => {
    onChange({
      ...data,
      config: { ...config, ...updates },
    });
  };

  // Build parameter inputs from selected runbook's schema
  const renderParameterInputs = () => {
    if (!selectedRunbook?.parameters?.properties) return null;

    const { properties, required = [] } = selectedRunbook.parameters;

    return Object.entries(properties).map(([key, prop]) => {
      const isRequired = required.includes(key);
      const value = config.parameters?.[key] ?? prop.default ?? '';

      return (
        <div key={key} className="space-y-1">
          <Label htmlFor={`param-${key}`}>
            {key} {isRequired && <span className="text-red-500">*</span>}
          </Label>
          {prop.description && (
            <p className="text-xs text-muted-foreground">{prop.description}</p>
          )}
          {prop.enum ? (
            <Select
              value={String(value)}
              onValueChange={(v) =>
                updateConfig({
                  parameters: { ...config.parameters, [key]: prop.type === 'number' ? Number(v) : v }
                })
              }
            >
              <SelectTrigger>
                <SelectValue placeholder={`Select ${key}`} />
              </SelectTrigger>
              <SelectContent>
                {prop.enum.map((opt) => (
                  <SelectItem key={String(opt)} value={String(opt)}>
                    {String(opt)}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          ) : prop.type === 'boolean' ? (
            <Select
              value={String(value)}
              onValueChange={(v) =>
                updateConfig({ parameters: { ...config.parameters, [key]: v === 'true' } })
              }
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="true">True</SelectItem>
                <SelectItem value="false">False</SelectItem>
              </SelectContent>
            </Select>
          ) : (
            <Input
              id={`param-${key}`}
              type={prop.type === 'number' ? 'number' : 'text'}
              value={String(value)}
              onChange={(e) =>
                updateConfig({
                  parameters: {
                    ...config.parameters,
                    [key]: prop.type === 'number' ? Number(e.target.value) : e.target.value
                  }
                })
              }
              placeholder={prop.default !== undefined ? `Default: ${prop.default}` : undefined}
            />
          )}
        </div>
      );
    });
  };

  return (
    <div className="space-y-4">
      {/* Name */}
      <div className="space-y-2">
        <Label htmlFor="runbook-name">
          Name <span className="text-red-500">*</span>
        </Label>
        <Input
          id="runbook-name"
          value={data.name || ''}
          onChange={(e) => onChange({ ...data, name: e.target.value })}
          placeholder="e.g., Restart Service"
        />
      </div>

      {/* Runbook Selector */}
      <div className="space-y-2">
        <Label htmlFor="runbook-select">
          Runbook <span className="text-red-500">*</span>
        </Label>
        <Select
          value={config.runbookId || ''}
          onValueChange={(value) =>
            updateConfig({ runbookId: value, parameters: {} })
          }
          disabled={loadingRunbooks}
        >
          <SelectTrigger className={cn(!config.runbookId && 'border-red-300')}>
            <SelectValue placeholder={loadingRunbooks ? 'Loading...' : 'Select runbook'} />
          </SelectTrigger>
          <SelectContent>
            {runbooks?.map((rb) => (
              <SelectItem key={rb.id} value={rb.id}>
                <div className="flex flex-col">
                  <span>{rb.name}</span>
                  <span className="text-xs text-muted-foreground truncate max-w-[200px]">
                    {rb.description}
                  </span>
                </div>
              </SelectItem>
            ))}
            {runbooks?.length === 0 && (
              <div className="px-2 py-4 text-sm text-muted-foreground text-center">
                No approved runbooks available
              </div>
            )}
          </SelectContent>
        </Select>
      </div>

      {/* Selected Runbook Info */}
      {selectedRunbook && (
        <div className="bg-muted/50 rounded-lg p-3 text-sm">
          <div className="font-medium">{selectedRunbook.name}</div>
          <div className="text-muted-foreground text-xs mt-1">
            {selectedRunbook.description}
          </div>
          <Badge variant="secondary" className="mt-2 text-xs">
            v{selectedRunbook.version}
          </Badge>
        </div>
      )}

      {/* Parameters */}
      {selectedRunbook && Object.keys(selectedRunbook.parameters?.properties || {}).length > 0 && (
        <div className="space-y-3">
          <Label>Parameters</Label>
          {renderParameterInputs()}
        </div>
      )}

      {/* Retry config (reuse pattern from webhook) */}
      <div className="space-y-2">
        <Label>Retry Configuration</Label>
        <p className="text-xs text-muted-foreground">
          Runbook uses built-in retry (3 attempts with exponential backoff)
        </p>
      </div>
    </div>
  );
}
```

3. Update main NodeConfigPanel component to handle runbook type:

In the icon/title section, add runbook case:
```typescript
} else if (nodeType === 'action') {
  const actionType = (nodeData as ActionData).actionType;
  if (actionType === 'webhook') {
    // ... existing
  } else if (actionType === 'jira') {
    // ... existing
  } else if (actionType === 'linear') {
    // ... existing
  } else if (actionType === 'runbook') {
    Icon = BookOpen;
    title = 'Configure Runbook';
    color = 'text-green-600';
  }
}
```

In the config form rendering section, add runbook case:
```typescript
{nodeType === 'action' && (nodeData as ActionData).actionType === 'runbook' && (
  <RunbookConfig
    data={nodeData as ActionData & { actionType: 'runbook' }}
    onChange={handleChange}
  />
)}
```

4. Update WorkflowBuilderPage.tsx createDefaultNodeData to handle runbook:

Add runbook case in the action switch:
```typescript
} else if (subType === 'runbook') {
  return {
    name: 'New Runbook',
    actionType: 'runbook',
    config: {
      runbookId: '',
      parameters: {},
    },
    retry: { attempts: 3, backoff: 'exponential', initialDelayMs: 1000 },
  };
}
```

Update validateWorkflow to validate runbook config:
```typescript
if (actionData.actionType === 'runbook' && !actionData.config?.runbookId) {
  errors.push(`Runbook action "${data.name || node.id}" is missing runbook selection`);
}
```
  </action>
  <verify>npm run build passes in frontend; visual check shows runbook node in sidebar</verify>
  <done>Workflow builder shows Run Runbook action node, config panel has runbook dropdown with parameter inputs</done>
</task>

<task type="auto">
  <name>Task 3: Add Run Runbook Button to Incident Detail</name>
  <files>frontend/src/components/RunbookExecutionModal.tsx, frontend/src/components/IncidentDetail.tsx</files>
  <action>
1. Create frontend/src/components/RunbookExecutionModal.tsx:
```typescript
/**
 * RunbookExecutionModal - Modal for manual runbook execution
 *
 * Features (per AUTO-10):
 * - Runbook selection dropdown (filtered by team scope)
 * - Parameter input form
 * - Confirmation dialog before execution
 * - Execution status feedback
 */

import { useState } from 'react';
import { BookOpen, Play, AlertCircle, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { useToast } from '@/components/ui/use-toast';
import {
  useApprovedRunbooks,
  useRunbook,
  useExecuteRunbook,
  type Runbook
} from '@/hooks/useRunbooks';

interface RunbookExecutionModalProps {
  incidentId: string;
  teamId: string;
  isOpen: boolean;
  onClose: () => void;
}

export function RunbookExecutionModal({
  incidentId,
  teamId,
  isOpen,
  onClose
}: RunbookExecutionModalProps) {
  const { toast } = useToast();
  const [selectedRunbookId, setSelectedRunbookId] = useState<string>('');
  const [parameters, setParameters] = useState<Record<string, unknown>>({});
  const [showConfirm, setShowConfirm] = useState(false);

  // Fetch runbooks - filter by team scope (team-specific + global)
  const { data: runbooks, isLoading: loadingRunbooks } = useApprovedRunbooks(teamId);
  const { data: selectedRunbook } = useRunbook(selectedRunbookId || undefined);
  const executeRunbook = useExecuteRunbook(incidentId);

  const handleRunbookSelect = (runbookId: string) => {
    setSelectedRunbookId(runbookId);
    setParameters({}); // Reset parameters when runbook changes
  };

  const handleParameterChange = (key: string, value: unknown) => {
    setParameters((prev) => ({ ...prev, [key]: value }));
  };

  const handleExecute = async () => {
    setShowConfirm(false);

    try {
      await executeRunbook.mutateAsync({
        runbookId: selectedRunbookId,
        parameters
      });

      toast({
        title: 'Runbook triggered',
        description: `${selectedRunbook?.name} has been scheduled for execution.`,
      });

      // Reset and close
      setSelectedRunbookId('');
      setParameters({});
      onClose();
    } catch (error: any) {
      toast({
        title: 'Execution failed',
        description: error.response?.data?.error || error.message,
        variant: 'destructive',
      });
    }
  };

  const handleClose = () => {
    setSelectedRunbookId('');
    setParameters({});
    onClose();
  };

  // Filter runbooks to show team-scoped (matching team) + global (no team)
  const filteredRunbooks = runbooks?.filter(
    (rb) => rb.teamId === null || rb.teamId === teamId
  );

  const renderParameterInputs = () => {
    if (!selectedRunbook?.parameters?.properties) return null;

    const { properties, required = [] } = selectedRunbook.parameters;

    return Object.entries(properties).map(([key, prop]) => {
      const isRequired = required.includes(key);
      const value = parameters[key] ?? prop.default ?? '';

      return (
        <div key={key} className="space-y-1">
          <Label>
            {key} {isRequired && <span className="text-red-500">*</span>}
          </Label>
          {prop.description && (
            <p className="text-xs text-muted-foreground">{prop.description}</p>
          )}
          {prop.enum ? (
            <Select
              value={String(value)}
              onValueChange={(v) =>
                handleParameterChange(key, prop.type === 'number' ? Number(v) : v)
              }
            >
              <SelectTrigger>
                <SelectValue placeholder={`Select ${key}`} />
              </SelectTrigger>
              <SelectContent>
                {prop.enum.map((opt) => (
                  <SelectItem key={String(opt)} value={String(opt)}>
                    {String(opt)}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          ) : prop.type === 'boolean' ? (
            <Select
              value={String(value)}
              onValueChange={(v) => handleParameterChange(key, v === 'true')}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="true">True</SelectItem>
                <SelectItem value="false">False</SelectItem>
              </SelectContent>
            </Select>
          ) : (
            <Input
              type={prop.type === 'number' ? 'number' : 'text'}
              value={String(value)}
              onChange={(e) =>
                handleParameterChange(
                  key,
                  prop.type === 'number' ? Number(e.target.value) : e.target.value
                )
              }
              placeholder={prop.default !== undefined ? `Default: ${prop.default}` : undefined}
            />
          )}
        </div>
      );
    });
  };

  return (
    <>
      <Dialog open={isOpen} onOpenChange={handleClose}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <BookOpen className="h-5 w-5 text-green-600" />
              Run Runbook
            </DialogTitle>
            <DialogDescription>
              Select and execute an approved runbook for this incident.
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4">
            {/* Runbook selector */}
            <div className="space-y-2">
              <Label>Runbook</Label>
              <Select
                value={selectedRunbookId}
                onValueChange={handleRunbookSelect}
                disabled={loadingRunbooks}
              >
                <SelectTrigger>
                  <SelectValue placeholder={loadingRunbooks ? 'Loading...' : 'Select runbook'} />
                </SelectTrigger>
                <SelectContent>
                  {filteredRunbooks?.map((rb) => (
                    <SelectItem key={rb.id} value={rb.id}>
                      <div className="flex items-center gap-2">
                        <span>{rb.name}</span>
                        {rb.teamId === null && (
                          <Badge variant="outline" className="text-xs">Global</Badge>
                        )}
                      </div>
                    </SelectItem>
                  ))}
                  {filteredRunbooks?.length === 0 && (
                    <div className="px-2 py-4 text-sm text-muted-foreground text-center">
                      No approved runbooks available for this team
                    </div>
                  )}
                </SelectContent>
              </Select>
            </div>

            {/* Selected runbook info */}
            {selectedRunbook && (
              <div className="bg-muted/50 rounded-lg p-3">
                <div className="font-medium">{selectedRunbook.name}</div>
                <div className="text-sm text-muted-foreground mt-1">
                  {selectedRunbook.description}
                </div>
                <Badge variant="secondary" className="mt-2 text-xs">
                  v{selectedRunbook.version}
                </Badge>
              </div>
            )}

            {/* Parameters */}
            {selectedRunbook && Object.keys(selectedRunbook.parameters?.properties || {}).length > 0 && (
              <div className="space-y-3">
                <Label>Parameters</Label>
                {renderParameterInputs()}
              </div>
            )}
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={handleClose}>
              Cancel
            </Button>
            <Button
              onClick={() => setShowConfirm(true)}
              disabled={!selectedRunbookId || executeRunbook.isPending}
            >
              {executeRunbook.isPending ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Executing...
                </>
              ) : (
                <>
                  <Play className="h-4 w-4 mr-2" />
                  Execute
                </>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Confirmation dialog (AUTO-10 requirement) */}
      <AlertDialog open={showConfirm} onOpenChange={setShowConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="flex items-center gap-2">
              <AlertCircle className="h-5 w-5 text-yellow-500" />
              Confirm Runbook Execution
            </AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to execute <strong>{selectedRunbook?.name}</strong>?
              This will trigger the runbook's webhook and cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleExecute}>
              Yes, Execute
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
```

2. Update frontend/src/components/IncidentDetail.tsx to add Run Runbook button:

Add imports:
```typescript
import { useState } from 'react';
import { BookOpen } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { RunbookExecutionModal } from './RunbookExecutionModal';
```

Add state for modal:
```typescript
const [showRunbookModal, setShowRunbookModal] = useState(false);
```

Add Run Runbook button in the Actions section (after IncidentActions):
```typescript
{/* Actions */}
<div className="mb-4 flex items-center gap-2">
  <IncidentActions
    incident={incident}
    variant={isInline ? 'inline' : 'full'}
    onAcknowledgeSuccess={onAcknowledgeSuccess}
  />
  {/* Run Runbook button (AUTO-10) */}
  {!isInline && (
    <Button
      variant="outline"
      size="sm"
      onClick={() => setShowRunbookModal(true)}
    >
      <BookOpen className="h-4 w-4 mr-2" />
      Run Runbook
    </Button>
  )}
</div>
```

Add modal component at end of return:
```typescript
{/* Runbook execution modal */}
{!isInline && (
  <RunbookExecutionModal
    incidentId={incident.id}
    teamId={incident.teamId}
    isOpen={showRunbookModal}
    onClose={() => setShowRunbookModal(false)}
  />
)}
```

The timeline will automatically show runbook executions because the query invalidation in useExecuteRunbook refreshes the timeline, and the runbook execution creates timeline entries via the audit log.
  </action>
  <verify>npm run build passes in frontend; visual check shows Run Runbook button on incident detail page</verify>
  <done>Incident detail shows Run Runbook button, modal allows team-scoped selection with parameters and confirmation</done>
</task>

</tasks>

<verification>
1. Frontend build: `cd frontend && npm run build` passes without errors
2. Runbook node in sidebar: Visually verify "Run Runbook" appears in Actions section
3. Runbook config panel: Select a runbook node and verify dropdown + parameters appear
4. Run Runbook button: Navigate to incident detail and verify button is visible
5. Modal flow: Click button, select runbook, fill parameters, confirm execution
</verification>

<success_criteria>
- Workflow builder sidebar shows "Run Runbook" action node with book icon and green styling
- Selecting runbook node in canvas opens config panel with runbook dropdown
- Config panel shows parameter inputs based on selected runbook's JSON Schema
- Incident detail page shows "Run Runbook" button (not in inline mode)
- Clicking button opens modal with runbook selection filtered by team scope
- Modal shows confirmation dialog before execution
- Successful execution triggers toast notification and timeline refresh
- Frontend builds without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-runbook-integration/16-02-SUMMARY.md`
</output>

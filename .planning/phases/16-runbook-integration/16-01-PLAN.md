---
phase: 16-runbook-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/workflow.ts
  - src/services/workflow/workflow-executor.service.ts
  - src/routes/incident.routes.ts
autonomous: true

must_haves:
  truths:
    - "Workflow executor handles runbook action type by calling runbook-executor service"
    - "POST /api/incidents/:id/runbooks/:runbookId/execute endpoint triggers manual runbook execution"
    - "Runbook execution logs link to workflow execution context for traceability"
  artifacts:
    - path: "src/types/workflow.ts"
      provides: "RunbookActionData type and type guard"
      contains: "actionType: 'runbook'"
    - path: "src/services/workflow/workflow-executor.service.ts"
      provides: "Runbook action execution handler"
      contains: "executeRunbookAction"
    - path: "src/routes/incident.routes.ts"
      provides: "Manual runbook execution endpoint"
      contains: "/runbooks/:runbookId/execute"
  key_links:
    - from: "src/services/workflow/workflow-executor.service.ts"
      to: "src/services/runbook/runbook-executor.service.ts"
      via: "runbookExecutor.execute call"
      pattern: "runbookExecutor\\.execute"
    - from: "src/routes/incident.routes.ts"
      to: "src/services/runbook/runbook.service.ts"
      via: "runbookService.get and execution trigger"
      pattern: "runbookService\\.get"
---

<objective>
Add runbook action type to workflow system and manual trigger API endpoint.

Purpose: Enable automated runbook execution via workflows and manual triggering from incidents (AUTO-09, AUTO-10 backend)
Output: Extended workflow types, executor integration, and incident runbook execution route
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-runbook-automation-foundation/15-01-SUMMARY.md
@.planning/phases/15-runbook-automation-foundation/15-02-SUMMARY.md
@src/types/workflow.ts
@src/services/workflow/workflow-executor.service.ts
@src/services/runbook/runbook-executor.service.ts
@src/routes/incident.routes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Runbook Action Type to Workflow Types</name>
  <files>src/types/workflow.ts</files>
  <action>
Extend workflow type definitions to support runbook actions:

1. Update ActionType union to include 'runbook':
   ```typescript
   export type ActionType = 'webhook' | 'jira' | 'linear' | 'runbook';
   ```

2. Add RunbookActionData interface following existing pattern:
   ```typescript
   export interface RunbookActionData extends BaseActionData {
     actionType: 'runbook';
     config: RunbookActionConfig;
   }

   export interface RunbookActionConfig {
     runbookId: string;
     parameters: Record<string, unknown>;
   }
   ```

3. Update ActionData discriminated union:
   ```typescript
   export type ActionData = WebhookActionData | JiraActionData | LinearActionData | RunbookActionData;
   ```

4. Add type guard for RunbookActionData:
   ```typescript
   export function isRunbookAction(data: ActionData): data is RunbookActionData {
     return data.actionType === 'runbook';
   }
   ```

Follow existing patterns from WebhookActionData, JiraActionData, LinearActionData.
  </action>
  <verify>npx tsc --noEmit passes with no errors in src/types/workflow.ts</verify>
  <done>RunbookActionData type defined with config containing runbookId and parameters, ActionType includes 'runbook'</done>
</task>

<task type="auto">
  <name>Task 2: Add Runbook Action Handler to Workflow Executor</name>
  <files>src/services/workflow/workflow-executor.service.ts</files>
  <action>
Extend workflow executor to handle runbook action type:

1. Import runbook dependencies at top:
   ```typescript
   import { runbookService } from '../runbook/runbook.service.js';
   import { scheduleRunbook } from '../../queues/runbook.queue.js';
   import type { RunbookActionData } from '../../types/workflow.js';
   ```

2. Add case for 'runbook' in executeActionNode switch:
   ```typescript
   case 'runbook':
     return await executeRunbookAction(node.id, data as RunbookActionData, context, execution);
   ```

3. Create executeRunbookAction function:
   ```typescript
   async function executeRunbookAction(
     nodeId: string,
     data: RunbookActionData,
     context: Awaited<ReturnType<typeof buildTemplateContext>>,
     execution: WorkflowExecution
   ): Promise<NodeResult> {
     const startedAt = new Date();

     try {
       // Get runbook and verify it's APPROVED
       const runbook = await runbookService.get(data.config.runbookId);
       if (!runbook) {
         return {
           nodeId,
           status: 'failed',
           error: `Runbook not found: ${data.config.runbookId}`,
           startedAt,
           completedAt: new Date()
         };
       }

       if (runbook.approvalStatus !== 'APPROVED') {
         return {
           nodeId,
           status: 'failed',
           error: `Runbook is ${runbook.approvalStatus}, not APPROVED`,
           startedAt,
           completedAt: new Date()
         };
       }

       // Create RunbookExecution record with workflow execution link
       const runbookExecution = await prisma.runbookExecution.create({
         data: {
           runbookId: data.config.runbookId,
           incidentId: execution.incidentId,
           runbookVersion: runbook.version,
           definitionSnapshot: {
             name: runbook.name,
             description: runbook.description,
             webhookUrl: runbook.webhookUrl,
             webhookMethod: runbook.webhookMethod,
             webhookHeaders: runbook.webhookHeaders,
             webhookAuth: runbook.webhookAuth,
             parameters: runbook.parameters,
             payloadTemplate: runbook.payloadTemplate,
             timeoutSeconds: runbook.timeoutSeconds
           },
           parameters: data.config.parameters,
           status: 'PENDING',
           triggeredBy: 'workflow',
           // Link to workflow execution for traceability (AUTO-09)
           workflowExecutionId: execution.id
         }
       });

       // Schedule for async execution
       await scheduleRunbook(runbookExecution.id);

       logger.info({
         nodeId,
         runbookId: data.config.runbookId,
         runbookExecutionId: runbookExecution.id,
         workflowExecutionId: execution.id
       }, 'Runbook action scheduled from workflow');

       return {
         nodeId,
         status: 'completed',
         result: {
           runbookExecutionId: runbookExecution.id,
           runbookName: runbook.name,
           status: 'scheduled'
         },
         startedAt,
         completedAt: new Date()
       };
     } catch (error) {
       const errorMessage = error instanceof Error ? error.message : 'Runbook action failed';
       return {
         nodeId,
         status: 'failed',
         error: errorMessage,
         startedAt,
         completedAt: new Date()
       };
     }
   }
   ```

Note: The workflow executor schedules the runbook and returns immediately (non-blocking). The runbook executes asynchronously via the BullMQ worker. This matches the existing pattern where workflow nodes complete quickly and external operations happen async.

Add workflowExecutionId to Prisma RunbookExecution model if not present (check schema first).
  </action>
  <verify>npx tsc --noEmit passes; grep -q "executeRunbookAction" src/services/workflow/workflow-executor.service.ts</verify>
  <done>Workflow executor handles 'runbook' action type, creates RunbookExecution with workflow link, schedules via queue</done>
</task>

<task type="auto">
  <name>Task 3: Add Manual Runbook Execution Endpoint</name>
  <files>src/routes/incident.routes.ts, prisma/schema.prisma</files>
  <action>
Add endpoint for manual runbook trigger from incident detail page (AUTO-10):

1. First check if RunbookExecution needs workflowExecutionId field in Prisma schema. If not present, add:
   ```prisma
   model RunbookExecution {
     // ... existing fields ...
     workflowExecutionId String?
     workflowExecution   WorkflowExecution? @relation(fields: [workflowExecutionId], references: [id])
   }
   ```
   Also add reverse relation to WorkflowExecution if needed:
   ```prisma
   model WorkflowExecution {
     // ... existing fields ...
     runbookExecutions RunbookExecution[]
   }
   ```
   Run `npx prisma db push` after schema changes.

2. Add imports to incident.routes.ts:
   ```typescript
   import { runbookService } from '../services/runbook/runbook.service.js';
   import { validateParameters } from '../services/runbook/runbook-executor.service.js';
   import { scheduleRunbook } from '../queues/runbook.queue.js';
   import { auditService } from '../services/audit.service.js';
   ```

3. Add POST /api/incidents/:id/runbooks/:runbookId/execute endpoint:
   ```typescript
   // POST /api/incidents/:id/runbooks/:runbookId/execute - Manual runbook trigger (AUTO-10)
   router.post('/:id/runbooks/:runbookId/execute', async (req: Request, res: Response, next: NextFunction) => {
     try {
       const { id: incidentId, runbookId } = req.params;
       const { parameters } = req.body;
       const user = (req as any).user;

       // Get incident for team check
       const incident = await incidentService.getById(incidentId);
       if (!incident) {
         return res.status(404).json({ error: 'Incident not found' });
       }

       // Check team access - must be able to respond to incident
       const permission = permissionService.canRespondToIncident(user, incident.teamId);
       if (!permission.allowed) {
         return res.status(403).json({ error: permission.reason });
       }

       // Get runbook
       const runbook = await runbookService.get(runbookId);
       if (!runbook) {
         return res.status(404).json({ error: 'Runbook not found' });
       }

       // Check runbook is APPROVED
       if (runbook.approvalStatus !== 'APPROVED') {
         return res.status(400).json({
           error: `Runbook is ${runbook.approvalStatus}, only APPROVED runbooks can be executed`
         });
       }

       // Check runbook team scope (if team-scoped, must match incident team)
       if (runbook.teamId && runbook.teamId !== incident.teamId) {
         return res.status(403).json({
           error: 'Runbook is scoped to a different team'
         });
       }

       // Validate parameters against runbook schema
       const validation = validateParameters(runbook.parameters, parameters || {});
       if (!validation.valid) {
         return res.status(400).json({
           error: 'Invalid parameters',
           details: validation.errors
         });
       }

       // Create RunbookExecution record
       const execution = await prisma.runbookExecution.create({
         data: {
           runbookId,
           incidentId,
           runbookVersion: runbook.version,
           definitionSnapshot: {
             name: runbook.name,
             description: runbook.description,
             webhookUrl: runbook.webhookUrl,
             webhookMethod: runbook.webhookMethod,
             webhookHeaders: runbook.webhookHeaders,
             webhookAuth: runbook.webhookAuth,
             parameters: runbook.parameters,
             payloadTemplate: runbook.payloadTemplate,
             timeoutSeconds: runbook.timeoutSeconds
           },
           parameters: parameters || {},
           status: 'PENDING',
           triggeredBy: 'manual',
           executedById: user.id
         }
       });

       // Schedule for execution
       await scheduleRunbook(execution.id);

       // Audit log (AUTO-10 requirement)
       await auditService.log({
         action: 'runbook.manual_trigger',
         resourceType: 'runbook',
         resourceId: runbookId,
         userId: user.id,
         severity: 'INFO',
         metadata: {
           executionId: execution.id,
           incidentId,
           runbookName: runbook.name,
           parameters
         }
       });

       return res.status(201).json({
         execution: {
           id: execution.id,
           runbookId,
           runbookName: runbook.name,
           status: execution.status,
           triggeredBy: execution.triggeredBy
         }
       });
     } catch (error) {
       return next(error);
     }
   });
   ```

4. Add GET endpoint to list runbook executions for an incident:
   ```typescript
   // GET /api/incidents/:id/runbooks/executions - List runbook executions for incident
   router.get('/:id/runbooks/executions', async (req: Request, res: Response, next: NextFunction) => {
     try {
       const incident = await incidentService.getById(req.params.id);
       if (!incident) {
         return res.status(404).json({ error: 'Incident not found' });
       }

       const permission = permissionService.canViewTeam((req as any).user, incident.teamId);
       if (!permission.allowed) {
         return res.status(403).json({ error: permission.reason });
       }

       const executions = await prisma.runbookExecution.findMany({
         where: { incidentId: req.params.id },
         include: {
           runbook: { select: { name: true, description: true } },
           executedBy: { select: { id: true, firstName: true, lastName: true } }
         },
         orderBy: { createdAt: 'desc' }
       });

       return res.json({ executions });
     } catch (error) {
       return next(error);
     }
   });
   ```

Import prisma at top if not already imported:
```typescript
import { prisma } from '../config/database.js';
```
  </action>
  <verify>npx tsc --noEmit passes; curl test shows endpoint exists (may return 401 without auth)</verify>
  <done>POST /api/incidents/:id/runbooks/:runbookId/execute triggers manual runbook with validation, audit log, and team scope check</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes without errors
2. Runbook action type exists: `grep -q "actionType: 'runbook'" src/types/workflow.ts`
3. Executor handles runbook: `grep -q "executeRunbookAction" src/services/workflow/workflow-executor.service.ts`
4. Manual trigger route exists: `grep -q "runbooks/:runbookId/execute" src/routes/incident.routes.ts`
5. Workflow-runbook link: `grep -q "workflowExecutionId" prisma/schema.prisma`
</verification>

<success_criteria>
- WorkflowDefinition schema supports 'runbook' action type with runbookId and parameters config
- Workflow executor routes runbook actions to runbook-executor service via BullMQ queue
- RunbookExecution records link to WorkflowExecution for traceability
- POST /api/incidents/:id/runbooks/:runbookId/execute validates parameters, checks team scope, creates audit log
- All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/16-runbook-integration/16-01-SUMMARY.md`
</output>

---
phase: 08-automation-workflows
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/services/workflow/workflow-trigger.service.ts
  - src/services/workflow/workflow-executor.service.ts
  - src/queues/workflow.queue.ts
  - src/workers/workflow.worker.ts
autonomous: true

must_haves:
  truths:
    - "Trigger service finds workflows matching incident events (created, state_changed, escalation, manual, age)"
    - "Executor orchestrates sequential action execution with stop-on-error"
    - "Worker processes workflow jobs with configurable timeout"
    - "Execution state persisted to database after each action"
  artifacts:
    - path: "src/services/workflow/workflow-trigger.service.ts"
      provides: "Event matching and trigger evaluation"
      exports: ["findMatchingWorkflows", "evaluateTrigger"]
    - path: "src/services/workflow/workflow-executor.service.ts"
      provides: "Workflow orchestration"
      exports: ["executeWorkflow", "WorkflowExecutor"]
    - path: "src/queues/workflow.queue.ts"
      provides: "BullMQ workflow queue"
      exports: ["workflowQueue", "scheduleWorkflow"]
    - path: "src/workers/workflow.worker.ts"
      provides: "Worker processing workflow jobs"
      exports: ["startWorkflowWorker"]
  key_links:
    - from: "src/services/workflow/workflow-trigger.service.ts"
      to: "prisma.workflow.findMany"
      via: "Find enabled workflows"
      pattern: "prisma\\.workflow\\.findMany"
    - from: "src/workers/workflow.worker.ts"
      to: "src/services/workflow/workflow-executor.service.ts"
      via: "Execute workflow"
      pattern: "executeWorkflow"
---

<objective>
Create trigger matching service, workflow executor, and BullMQ queue infrastructure.

Purpose: Enable workflows to automatically trigger on incident events and execute actions sequentially with proper error handling.

Output: Trigger service, executor with sequential/stop-on-error execution, BullMQ queue and worker.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-automation-workflows/08-CONTEXT.md
@.planning/phases/08-automation-workflows/08-RESEARCH.md

# Existing BullMQ patterns
@src/queues/escalation.queue.ts
@src/workers/escalation.worker.ts
@src/config/redis.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trigger matching service</name>
  <files>src/services/workflow/workflow-trigger.service.ts</files>
  <action>
Create src/services/workflow/workflow-trigger.service.ts:

1. Define TriggerEvent interface:
   ```typescript
   interface TriggerEvent {
     type: 'incident_created' | 'state_changed' | 'escalation' | 'manual' | 'age';
     incident: {
       id: string;
       priority: string;
       status: string;
       teamId: string;
       metadata?: Record<string, any>;
     };
     previousState?: string;  // For state_changed
     newState?: string;
   }
   ```

2. Export findMatchingWorkflows function (per research pattern):
   - Query all enabled workflows for incident's team OR global scope
   - Filter by trigger type match
   - For state_changed: check stateTransition.to matches newState
   - For age: check incident age > ageThresholdMinutes
   - Apply all conditions using simple field matching (per user decision - no AND/OR)
   - Return array of matching Workflow objects
   - Per Claude's discretion: allow all matching workflows to run in parallel

3. Create matchCondition helper:
   - Simple equality check: getFieldValue(incident, condition.field) === condition.value
   - Support nested paths like 'metadata.service' using dot notation

4. Create getFieldValue helper:
   - Split field by '.' and traverse object
   - Handle undefined gracefully

5. Export evaluateTrigger for single workflow:
   ```typescript
   export function evaluateTrigger(
     workflow: Workflow,
     event: TriggerEvent
   ): boolean
   ```

6. Implement cycle detection (per research pitfall #2):
   - Track execution chain in context
   - MAX_WORKFLOW_DEPTH = 3
   - Reject if workflow.id already in chain
   - Log warning when cycle detected

Log matching results with logger.info.
  </action>
  <verify>npx tsc --noEmit src/services/workflow/workflow-trigger.service.ts</verify>
  <done>Trigger service finds workflows matching incident events with cycle detection</done>
</task>

<task type="auto">
  <name>Task 2: Create workflow executor service</name>
  <files>src/services/workflow/workflow-executor.service.ts</files>
  <action>
Create src/services/workflow/workflow-executor.service.ts:

1. Import action executors and types:
   - executeWebhook, createJiraTicket, createLinearTicket
   - WorkflowDefinition, WorkflowNode, NodeResult

2. Define timeout constants (per user decision):
   ```typescript
   const WORKFLOW_TIMEOUTS = {
     '1min': 60_000,
     '5min': 300_000,
     '15min': 900_000
   };
   ```

3. Export executeWorkflow function:
   ```typescript
   export async function executeWorkflow(
     execution: WorkflowExecution,
     secrets: Map<string, string>
   ): Promise<WorkflowExecutionResult>
   ```

4. Implementation (sequential execution, stop on first error per user decision):
   - Parse definition from execution.definitionSnapshot
   - Topologically sort nodes following edges
   - For each node in order:
     a. Update execution.currentNodeId in database
     b. Check workflow timeout (per research pitfall #4)
     c. Execute node based on type:
        - 'trigger': No-op (start marker)
        - 'action': Execute appropriate action executor
        - 'condition': Evaluate condition, determine next path
        - 'delay': Wait for configured duration
     d. Record NodeResult
     e. Update completedNodes in database (per research pitfall #5)
     f. If failed: Stop execution, set status FAILED, return
   - On completion: Set status COMPLETED

5. Create executeAction helper:
   ```typescript
   async function executeAction(
     node: WorkflowNode,
     context: TemplateContext,
     secrets: Map<string, string>,
     remainingTimeout: number
   ): Promise<NodeResult>
   ```
   - Route to correct executor based on actionType
   - Apply per-action timeout = min(30s, remainingTimeout * 0.8) per research
   - Handle retry with exponential backoff (per user decision)
   - Return NodeResult with status, result, error, timing

6. Create evaluateCondition helper:
   - Extract field value from context using nested path
   - Simple equality check (per user decision)
   - Return 'true' or 'false' to determine edge to follow

7. Implement timeout enforcement:
   - Track startTime at execution start
   - Before each node: check elapsed < WORKFLOW_TIMEOUTS[settings.timeout]
   - If exceeded: Set status CANCELLED, return

8. Log progress with logger.info at each step.
  </action>
  <verify>npx tsc --noEmit src/services/workflow/workflow-executor.service.ts</verify>
  <done>Executor runs actions sequentially, stops on error, respects timeout</done>
</task>

<task type="auto">
  <name>Task 3: Create BullMQ queue and worker</name>
  <files>src/queues/workflow.queue.ts, src/workers/workflow.worker.ts</files>
  <action>
Create src/queues/workflow.queue.ts following escalation.queue.ts pattern:

1. Define WorkflowJobData interface:
   ```typescript
   export interface WorkflowJobData {
     executionId: string;
     incidentId: string;
     workflowId: string;
     triggeredBy: 'event' | 'manual';
     executionChain: string[];  // For cycle detection
   }
   ```

2. Create workflow queue:
   ```typescript
   export const workflowQueue = new Queue<WorkflowJobData>('workflow', {
     connection: getRedisConnectionOptions(),
     defaultJobOptions: {
       removeOnComplete: true,
       removeOnFail: false,
       attempts: 1  // No retry at job level - actions have their own retry
     }
   });
   ```

3. Export scheduleWorkflow function:
   ```typescript
   export async function scheduleWorkflow(
     executionId: string,
     incidentId: string,
     workflowId: string,
     triggeredBy: 'event' | 'manual',
     executionChain: string[] = []
   ): Promise<string>
   ```
   - Add job with jobId = executionId
   - Log scheduling

4. Export cancelWorkflow function to cancel pending job

---

Create src/workers/workflow.worker.ts following escalation.worker.ts pattern:

1. Create processWorkflowJob function:
   - Load execution from database
   - Check execution not already CANCELLED
   - Load secrets from WorkflowActionSecret
   - Update status to RUNNING, set startedAt
   - Call executeWorkflow
   - Update final status (COMPLETED or FAILED)
   - Log completion

2. Handle execution failures (per user decision):
   - Send notification to incident assignee
   - Send notification to workflow creator
   - Send Slack/Teams alert to team channel
   Use existing notification dispatcher

3. Export startWorkflowWorker:
   ```typescript
   export async function startWorkflowWorker(): Promise<void>
   ```
   - Create Worker with concurrency 5
   - Add event handlers (completed, failed, error)
   - Log startup

4. Export stopWorkflowWorker for graceful shutdown

5. Setup graceful shutdown handlers (SIGINT, SIGTERM)

Worker should handle errors gracefully and never crash the process.
  </action>
  <verify>npx tsc --noEmit src/queues/workflow.queue.ts src/workers/workflow.worker.ts</verify>
  <done>BullMQ queue and worker process workflows with failure notifications</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all service files
2. Trigger service finds workflows for incident events
3. Executor runs actions sequentially with stop-on-error
4. Worker processes jobs and sends failure notifications
5. Timeout enforcement prevents runaway executions
</verification>

<success_criteria>
- Trigger matching supports all event types (created, state_changed, escalation, manual, age)
- Simple field matching per user decision (no AND/OR)
- Sequential execution with stop-on-first-error per user decision
- Configurable timeout (1min, 5min, 15min) per user decision
- Execution state persisted to database after each action
- Failure notifications sent to assignee, creator, team channel per user decision
- Cycle detection prevents infinite workflow loops
</success_criteria>

<output>
After completion, create `.planning/phases/08-automation-workflows/08-03-SUMMARY.md`
</output>

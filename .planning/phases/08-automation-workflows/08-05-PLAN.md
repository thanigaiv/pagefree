---
phase: 08-automation-workflows
plan: 05
type: execute
wave: 3
depends_on: ["08-01", "08-04"]
files_modified:
  - frontend/src/components/workflow/nodes/TriggerNode.tsx
  - frontend/src/components/workflow/nodes/ActionNode.tsx
  - frontend/src/components/workflow/nodes/ConditionNode.tsx
  - frontend/src/components/workflow/nodes/DelayNode.tsx
  - frontend/src/components/workflow/WorkflowCanvas.tsx
  - frontend/src/hooks/useWorkflows.ts
autonomous: true

must_haves:
  truths:
    - "React Flow canvas renders workflow with custom nodes"
    - "TriggerNode displays incident event configuration"
    - "ActionNode shows webhook/Jira/Linear action details"
    - "ConditionNode visualizes if/else branching"
  artifacts:
    - path: "frontend/src/components/workflow/WorkflowCanvas.tsx"
      provides: "React Flow canvas with node types"
      min_lines: 100
    - path: "frontend/src/components/workflow/nodes/TriggerNode.tsx"
      provides: "Trigger node component"
      min_lines: 40
    - path: "frontend/src/components/workflow/nodes/ActionNode.tsx"
      provides: "Action node component"
      min_lines: 60
    - path: "frontend/src/hooks/useWorkflows.ts"
      provides: "TanStack Query hooks for workflow CRUD"
      exports: ["useWorkflows", "useWorkflow", "useCreateWorkflow"]
  key_links:
    - from: "frontend/src/components/workflow/WorkflowCanvas.tsx"
      to: "@xyflow/react"
      via: "ReactFlow import"
      pattern: "import.*ReactFlow"
    - from: "frontend/src/hooks/useWorkflows.ts"
      to: "/api/workflows"
      via: "fetch calls"
      pattern: "apiFetch.*workflows"
---

<objective>
Install React Flow, create custom workflow nodes, and set up the visual canvas component.

Purpose: Build the foundation for the visual drag-and-drop workflow builder with custom node types.

Output: React Flow integration, custom nodes (Trigger, Action, Condition, Delay), workflow canvas, API hooks.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-automation-workflows/08-CONTEXT.md
@.planning/phases/08-automation-workflows/08-RESEARCH.md

# Existing frontend patterns
@frontend/src/hooks/useIncidents.ts
@frontend/src/components/IntegrationCard.tsx
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install React Flow and create custom nodes</name>
  <files>frontend/src/components/workflow/nodes/TriggerNode.tsx, frontend/src/components/workflow/nodes/ActionNode.tsx, frontend/src/components/workflow/nodes/ConditionNode.tsx, frontend/src/components/workflow/nodes/DelayNode.tsx</files>
  <action>
First install React Flow and dagre:
```bash
cd frontend && npm install @xyflow/react dagre @types/dagre
```

Create frontend/src/components/workflow/nodes/TriggerNode.tsx:
```tsx
// Custom node for workflow triggers
// Display trigger type (incident_created, state_changed, escalation, manual, age)
// Show conditions visually
// Purple/indigo color scheme for triggers

import { Handle, Position, NodeProps } from '@xyflow/react';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Zap, RefreshCw, ArrowUp, Hand, Clock } from 'lucide-react';

// TriggerData interface from workflow types
// Icon mapping for trigger types
// Render conditions as badges
// Source handle at bottom only
```

Create frontend/src/components/workflow/nodes/ActionNode.tsx:
```tsx
// Custom node for workflow actions (webhook, jira, linear)
// Display action type with appropriate icon
// Show action name and brief config summary
// Color coding: webhook=blue, jira=blue-500, linear=purple

import { Handle, Position, NodeProps } from '@xyflow/react';
import { Card } from '@/components/ui/card';
import { Globe, Ticket, ListTodo } from 'lucide-react';

// ActionData interface from workflow types
// Icon and color mapping for action types
// Handle for input (top) and output (bottom)
// Show retry config badge if retries > 1
```

Create frontend/src/components/workflow/nodes/ConditionNode.tsx:
```tsx
// Custom node for if/else branching (per user decision - full branching support)
// Diamond shape or distinctive visual
// Show condition: field operator value
// Two output handles: 'true' (right) and 'false' (left)

import { Handle, Position, NodeProps } from '@xyflow/react';
import { Card } from '@/components/ui/card';
import { GitBranch } from 'lucide-react';

// ConditionData interface
// Yellow/amber color for conditions
// Clearly label true/false paths
```

Create frontend/src/components/workflow/nodes/DelayNode.tsx:
```tsx
// Custom node for delays (per user decision - configurable delays)
// Show duration in human-readable format
// Clock icon

import { Handle, Position, NodeProps } from '@xyflow/react';
import { Card } from '@/components/ui/card';
import { Timer } from 'lucide-react';

// DelayData interface
// Gray color for delays
// Format duration: "5 minutes", "1 hour"
```

All nodes should:
- Use shadcn/ui Card for consistent styling
- Have appropriate Handle positions
- Be selectable/focusable
- Show validation errors if data incomplete
  </action>
  <verify>cd frontend && npx tsc --noEmit</verify>
  <done>All 4 custom node components created with proper styling and handles</done>
</task>

<task type="auto">
  <name>Task 2: Create WorkflowCanvas component with React Flow</name>
  <files>frontend/src/components/workflow/WorkflowCanvas.tsx</files>
  <action>
Create frontend/src/components/workflow/WorkflowCanvas.tsx per research pattern:

1. Import React Flow and custom nodes:
   ```tsx
   import {
     ReactFlow,
     Background,
     Controls,
     MiniMap,
     addEdge,
     useNodesState,
     useEdgesState,
     Connection,
     Node,
     Edge
   } from '@xyflow/react';
   import dagre from 'dagre';
   import '@xyflow/react/dist/style.css';
   ```

2. Register custom node types:
   ```tsx
   const nodeTypes = {
     trigger: TriggerNode,
     action: ActionNode,
     condition: ConditionNode,
     delay: DelayNode
   };
   ```

3. Props interface:
   ```tsx
   interface WorkflowCanvasProps {
     initialNodes: Node[];
     initialEdges: Edge[];
     onChange?: (nodes: Node[], edges: Edge[]) => void;
     readOnly?: boolean;
   }
   ```

4. Implement component:
   - useNodesState and useEdgesState for state management
   - onConnect callback to add edges (validate connections per research)
   - Auto-layout using dagre getLayoutedElements function
   - Include Background, Controls components
   - Include MiniMap per Claude's discretion (show for complex workflows)
   - Call onChange when nodes/edges change

5. Create getLayoutedElements helper using dagre:
   - Direction: 'TB' (top to bottom)
   - nodesep: 50, ranksep: 100
   - Calculate positions for each node

6. Create isValidConnection validator:
   - Cannot connect to trigger nodes (they're always first)
   - Cannot create cycles
   - Condition nodes can only connect via sourceHandle 'true' or 'false'

7. Handle edge styling:
   - Default edges are gray
   - Edges from condition 'true' handle are green
   - Edges from condition 'false' handle are red/orange

8. Performance optimization (per research pitfall #6):
   - Show warning if >20 nodes
   - Disable dragging in readOnly mode
  </action>
  <verify>cd frontend && npx tsc --noEmit</verify>
  <done>WorkflowCanvas renders React Flow with auto-layout and custom nodes</done>
</task>

<task type="auto">
  <name>Task 3: Create workflow API hooks</name>
  <files>frontend/src/hooks/useWorkflows.ts</files>
  <action>
Create frontend/src/hooks/useWorkflows.ts following existing useIncidents.ts pattern:

1. Import TanStack Query and API utilities:
   ```tsx
   import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
   import { apiFetch } from '@/lib/api';
   ```

2. Define types (or import from shared):
   ```tsx
   interface Workflow { ... }
   interface WorkflowListParams { teamId?, scopeType?, isEnabled?, page?, limit? }
   interface CreateWorkflowInput { name, description, definition, scopeType, teamId? }
   ```

3. Export hooks:

**useWorkflows(params):**
- Query key: ['workflows', params]
- Fetch: GET /api/workflows with query params
- Returns paginated list

**useWorkflow(id):**
- Query key: ['workflow', id]
- Fetch: GET /api/workflows/:id
- Returns single workflow with versions

**useCreateWorkflow():**
- Mutation: POST /api/workflows
- Invalidate: ['workflows']

**useUpdateWorkflow():**
- Mutation: PUT /api/workflows/:id
- Invalidate: ['workflows'], ['workflow', id]

**useDeleteWorkflow():**
- Mutation: DELETE /api/workflows/:id
- Invalidate: ['workflows']

**useDuplicateWorkflow():** (per user decision)
- Mutation: POST /api/workflows/:id/duplicate
- Invalidate: ['workflows']

**useToggleWorkflow():** (per user decision)
- Mutation: PATCH /api/workflows/:id/toggle
- Optimistic update

**useRollbackWorkflow():** (per user decision)
- Mutation: POST /api/workflows/:id/rollback
- Invalidate: ['workflow', id]

**useExportWorkflow():**
- Query: GET /api/workflows/:id/export
- Returns JSON blob

**useImportWorkflow():**
- Mutation: POST /api/workflows/import
- Invalidate: ['workflows']

**useWorkflowAnalytics(id):** (per user decision)
- Query: GET /api/workflows/:id/analytics
- Returns execution stats

**useWorkflowTemplates(params):** (per user decision)
- Query: GET /api/workflow-templates
- Filter by category

**useCreateFromTemplate():** (per user decision)
- Mutation: POST /api/workflow-templates/:id/use
- Invalidate: ['workflows']

All hooks should handle loading, error states appropriately.
  </action>
  <verify>cd frontend && npx tsc --noEmit</verify>
  <done>All workflow CRUD hooks created with proper cache invalidation</done>
</task>

</tasks>

<verification>
1. `npm install` adds @xyflow/react and dagre
2. `npx tsc --noEmit` compiles frontend
3. Custom nodes render with correct styling
4. WorkflowCanvas auto-layouts nodes with dagre
5. API hooks connect to backend endpoints
</verification>

<success_criteria>
- React Flow installed and configured
- 4 custom node types (trigger, action, condition, delay) per user decisions
- Canvas with auto-layout using dagre
- MiniMap included per Claude's discretion
- Full branching support via condition node handles
- All CRUD hooks with optimistic updates
- Template library hooks per user decision
</success_criteria>

<output>
After completion, create `.planning/phases/08-automation-workflows/08-05-SUMMARY.md`
</output>

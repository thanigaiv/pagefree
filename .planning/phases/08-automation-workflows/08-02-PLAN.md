---
phase: 08-automation-workflows
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/workflow/template.service.ts
  - src/services/actions/webhook.action.ts
  - src/services/actions/jira.action.ts
  - src/services/actions/linear.action.ts
autonomous: true

must_haves:
  truths:
    - "Template service interpolates {{variable}} syntax using Handlebars"
    - "Webhook action supports POST/PUT/PATCH with Bearer/Basic/OAuth2/custom auth"
    - "Jira action creates tickets with template interpolation"
    - "Linear action creates issues with template interpolation"
  artifacts:
    - path: "src/services/workflow/template.service.ts"
      provides: "Handlebars template interpolation"
      exports: ["interpolateTemplate", "TemplateContext"]
    - path: "src/services/actions/webhook.action.ts"
      provides: "HTTP webhook executor"
      exports: ["executeWebhook", "WebhookResult"]
    - path: "src/services/actions/jira.action.ts"
      provides: "Jira ticket creation"
      exports: ["createJiraTicket"]
    - path: "src/services/actions/linear.action.ts"
      provides: "Linear issue creation"
      exports: ["createLinearTicket"]
  key_links:
    - from: "src/services/actions/webhook.action.ts"
      to: "src/services/workflow/template.service.ts"
      via: "interpolateTemplate call"
      pattern: "interpolateTemplate"
    - from: "src/services/actions/linear.action.ts"
      to: "prisma.incident"
      via: "Store ticket URL in metadata"
      pattern: "prisma\\.incident\\.update"
---

<objective>
Create template interpolation service and action executors for webhooks, Jira, and Linear.

Purpose: Enable workflows to execute external actions with dynamic content using {{incident.title}} style templates.

Output: Template service using Handlebars, webhook executor with auth support, Jira and Linear ticket creation actions.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/08-automation-workflows/08-CONTEXT.md
@.planning/phases/08-automation-workflows/08-RESEARCH.md

# Existing patterns
@src/services/notification/channels/slack.channel.ts
@src/config/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create template service</name>
  <files>src/services/workflow/template.service.ts</files>
  <action>
First install required packages:
```bash
npm install handlebars @linear/sdk
npm install -D @types/handlebars
```

Create src/services/workflow/template.service.ts:

1. Import Handlebars and create SAFE environment (per research pitfall):
   ```typescript
   const safeHandlebars = Handlebars.create();
   ```

2. Register ONLY safe helpers (per research - no eval/exec):
   - 'uppercase': (str) => String(str ?? '').toUpperCase()
   - 'lowercase': (str) => String(str ?? '').toLowerCase()
   - 'json': (obj) => JSON.stringify(obj)
   - 'shortId': (id) => String(id ?? '').slice(-6) (for incident IDs)
   - 'dateFormat': (date) => format date using date-fns

3. Export TemplateContext interface matching the type definition:
   - incident: { id, title, priority, status, createdAt, acknowledgedAt?, teamName, metadata }
   - assignee?: { id, email, firstName, lastName, phone? }
   - team: { id, name, slackChannel? }
   - workflow: { id, name, executionId }

4. Export interpolateTemplate function:
   ```typescript
   export function interpolateTemplate(template: string, context: TemplateContext): string {
     try {
       const compiled = safeHandlebars.compile(template);
       return compiled(context);
     } catch (error) {
       logger.error({ template, error }, 'Template interpolation failed');
       throw new Error(`Template error: ${error.message}`);
     }
   }
   ```

5. Export buildTemplateContext function to construct context from incident/user data:
   ```typescript
   export async function buildTemplateContext(
     incidentId: string,
     workflowId: string,
     executionId: string
   ): Promise<TemplateContext>
   ```
   This loads incident with team, assignedUser from database and formats context.
  </action>
  <verify>npx tsc --noEmit src/services/workflow/template.service.ts</verify>
  <done>Template service compiles, interpolates {{variable}} syntax safely</done>
</task>

<task type="auto">
  <name>Task 2: Create webhook action executor</name>
  <files>src/services/actions/webhook.action.ts</files>
  <action>
Create src/services/actions/webhook.action.ts following existing slack.channel.ts patterns:

1. Import types from workflow types:
   - WebhookConfig, WebhookAuth, WebhookResult

2. Export executeWebhook function:
   ```typescript
   export async function executeWebhook(
     config: WebhookConfig,
     context: TemplateContext,
     timeout: number = 30_000
   ): Promise<WebhookResult>
   ```

3. Implementation:
   - Interpolate URL, body, and headers using interpolateTemplate
   - Add auth headers based on config.auth.type:
     - 'bearer': Authorization: Bearer {token}
     - 'basic': Authorization: Basic {base64(user:pass)}
     - 'oauth2': Get token from tokenUrl using client credentials flow, then Bearer
     - 'custom': Merge customHeaders directly
   - Execute fetch with AbortController timeout (per research pitfall #4)
   - Return WebhookResult with success, statusCode, responseBody (truncated to 1000 chars), duration

4. Create helper getOAuth2Token for client credentials flow:
   - POST to tokenUrl with grant_type=client_credentials
   - Cache token briefly (1 minute) to avoid repeated requests
   - Handle token refresh on 401 (per Claude's discretion)

5. Log execution with logger (url, method, statusCode, duration)

6. Handle errors gracefully - return success: false with error message

Per research: Truncate response body for storage, use timing-safe comparisons where needed.
  </action>
  <verify>npx tsc --noEmit src/services/actions/webhook.action.ts</verify>
  <done>Webhook action supports POST/PUT/PATCH with all 4 auth types</done>
</task>

<task type="auto">
  <name>Task 3: Create Jira and Linear action executors</name>
  <files>src/services/actions/jira.action.ts, src/services/actions/linear.action.ts</files>
  <action>
Create src/services/actions/jira.action.ts:

1. Import types: JiraConfig from workflow types

2. Export createJiraTicket function:
   ```typescript
   export async function createJiraTicket(
     config: JiraConfig,
     context: TemplateContext,
     credentials: { baseUrl: string; email: string; apiToken: string }
   ): Promise<JiraResult>
   ```

3. Implementation:
   - Interpolate summary, description using interpolateTemplate
   - POST to {baseUrl}/rest/api/3/issue with Basic auth (email:apiToken)
   - Body: { fields: { project: { key }, issuetype: { name }, summary, description, priority?, labels? } }
   - Return JiraResult with success, ticketId, ticketUrl, error

4. Store ticket URL in incident metadata (per user decision):
   ```typescript
   await prisma.incident.update({
     where: { id: context.incident.id },
     data: {
       // Merge ticketUrl into existing metadata
     }
   });
   ```

5. Log ticket creation

---

Create src/services/actions/linear.action.ts:

1. Import LinearClient from @linear/sdk

2. Export createLinearTicket function:
   ```typescript
   export async function createLinearTicket(
     config: LinearConfig,
     context: TemplateContext,
     apiKey: string
   ): Promise<LinearResult>
   ```

3. Implementation per research:
   - Create LinearClient with apiKey
   - Interpolate title, description
   - Call client.createIssue({ teamId, title, description, priority?, labelIds? })
   - Get issue URL from created issue
   - Store ticket URL in incident metadata (per user decision)
   - Return LinearResult with success, ticketId, ticketUrl, error

4. Handle errors gracefully, log with logger

Both files should follow existing service patterns with proper error handling and audit logging.
  </action>
  <verify>npx tsc --noEmit src/services/actions/jira.action.ts src/services/actions/linear.action.ts</verify>
  <done>Jira and Linear actions create tickets with template interpolation, store URL in incident metadata</done>
</task>

</tasks>

<verification>
1. `npm install` adds handlebars, @linear/sdk
2. `npx tsc --noEmit` compiles all service files
3. Template service handles {{incident.title}}, {{assignee.email}}, {{uppercase incident.priority}}
4. Webhook action supports all 4 auth types
5. Jira/Linear actions store ticket URL in incident metadata
</verification>

<success_criteria>
- Template interpolation using {{variable}} syntax per user decision
- Webhook executor with Bearer, Basic, OAuth2, custom auth per user decision
- Jira ticket creation with REST API v3
- Linear ticket creation with official SDK
- Ticket URLs stored in incident metadata per user decision
- All actions return result objects with success/error status
</success_criteria>

<output>
After completion, create `.planning/phases/08-automation-workflows/08-02-SUMMARY.md`
</output>

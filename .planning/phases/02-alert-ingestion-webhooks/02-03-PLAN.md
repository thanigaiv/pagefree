---
phase: 02-alert-ingestion-webhooks
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/utils/content-fingerprint.ts
  - src/services/idempotency.service.ts
autonomous: true

must_haves:
  truths:
    - "Hybrid duplicate detection checks external idempotency key first"
    - "Falls back to content fingerprint if no external key"
    - "Deduplication window is configurable per integration"
    - "Duplicates return existing alert ID (not error)"
  artifacts:
    - path: "src/utils/content-fingerprint.ts"
      provides: "Content fingerprinting for webhook payloads"
      exports: ["generateContentFingerprint"]
    - path: "src/services/idempotency.service.ts"
      provides: "Idempotency detection service"
      exports: ["idempotencyService"]
  key_links:
    - from: "src/services/idempotency.service.ts"
      to: "src/utils/content-fingerprint.ts"
      via: "import generateContentFingerprint"
      pattern: "import.*generateContentFingerprint"
    - from: "src/services/idempotency.service.ts"
      to: "prisma WebhookDelivery"
      via: "prisma.webhookDelivery.findFirst"
      pattern: "prisma\\.webhookDelivery"
---

<objective>
Implement hybrid idempotency detection: check external idempotency key first, fall back to content fingerprinting.

Purpose: Prevent duplicate alerts when monitoring tools retry webhooks. Hybrid approach works with tools that provide idempotency keys (GitHub, Stripe) and those that don't (content-based deduplication).

Output: Reusable idempotency service that can be used by webhook handlers.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-alert-ingestion-webhooks/02-RESEARCH.md (Pattern 3: Hybrid Idempotency Detection)
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content fingerprinting utility</name>
  <files>src/utils/content-fingerprint.ts</files>
  <action>
Create a utility that generates deterministic fingerprints from webhook payloads.

Key implementation details:
1. Extract stable semantic fields only (title, severity, source, message hash)
2. Ignore delivery timestamps (use event timestamp)
3. Sort object keys for consistent JSON stringification
4. Sort arrays for order-independent comparison
5. Truncate long messages to fixed-length hash (16 chars)
6. Return SHA-256 hash as hex string

```typescript
import crypto from 'crypto';

/**
 * Generates a deterministic fingerprint from webhook payload.
 * Used for content-based deduplication when no external idempotency key is provided.
 *
 * The fingerprint is based on semantic content only, ignoring:
 * - Delivery timestamps
 * - Request metadata
 * - Field ordering
 * - Array ordering
 *
 * @param payload - Parsed webhook payload (any shape)
 * @returns SHA-256 hex hash of normalized content
 */
export function generateContentFingerprint(payload: any): string {
  const normalized = normalizePayload(payload);
  const content = JSON.stringify(normalized, Object.keys(normalized).sort());
  return crypto.createHash('sha256').update(content).digest('hex');
}

/**
 * Normalizes payload by extracting and standardizing semantic fields.
 */
function normalizePayload(payload: any): Record<string, any> {
  const normalized: Record<string, any> = {};

  // Core alert fields (stable across retries)
  if (payload.title) {
    normalized.title = String(payload.title).trim().toLowerCase();
  }

  if (payload.severity) {
    normalized.severity = String(payload.severity).toLowerCase();
  }

  if (payload.source) {
    normalized.source = String(payload.source).trim().toLowerCase();
  }

  // External ID from monitoring tool (most reliable dedup key)
  if (payload.external_id || payload.externalId || payload.id || payload.alert_id) {
    normalized.externalId = String(
      payload.external_id || payload.externalId || payload.id || payload.alert_id
    );
  }

  // Event/alert timestamp (not delivery timestamp)
  // Convert to ISO string for consistent hashing
  const timestamp = payload.timestamp || payload.triggered_at || payload.triggeredAt ||
                    payload.event_time || payload.eventTime || payload.occurred_at;
  if (timestamp) {
    try {
      // Handle both ISO strings and Unix timestamps
      const date = typeof timestamp === 'number'
        ? new Date(timestamp * (timestamp > 1e11 ? 1 : 1000)) // Handle ms vs seconds
        : new Date(timestamp);
      normalized.timestamp = date.toISOString();
    } catch {
      // Invalid timestamp - include raw value for uniqueness
      normalized.timestamp = String(timestamp);
    }
  }

  // Message/description - hash long content to fixed length
  const message = payload.message || payload.description || payload.body;
  if (message) {
    const messageStr = String(message).trim();
    if (messageStr.length > 100) {
      // Hash long messages to keep fingerprint consistent even with truncation
      normalized.messageHash = crypto
        .createHash('sha256')
        .update(messageStr)
        .digest('hex')
        .substring(0, 16);
    } else {
      normalized.message = messageStr.toLowerCase();
    }
  }

  // Tags - sort for order independence
  if (Array.isArray(payload.tags)) {
    normalized.tags = payload.tags
      .map((t: any) => String(t).trim().toLowerCase())
      .sort();
  }

  // Host/service identifier
  if (payload.host || payload.hostname || payload.service) {
    normalized.host = String(payload.host || payload.hostname || payload.service)
      .trim()
      .toLowerCase();
  }

  return normalized;
}

/**
 * Extracts common idempotency key headers from request.
 * Returns the first found key or undefined.
 */
export function extractIdempotencyKey(headers: Record<string, string | string[] | undefined>): string | undefined {
  // Check common idempotency header patterns (case-insensitive)
  const headerNames = [
    'idempotency-key',
    'x-idempotency-key',
    'x-delivery-id',
    'x-request-id',
    'x-github-delivery',
    'x-datadog-delivery-id',
    'x-trace-id'
  ];

  for (const name of headerNames) {
    const value = headers[name] || headers[name.toLowerCase()];
    if (value) {
      return Array.isArray(value) ? value[0] : value;
    }
  }

  return undefined;
}
```

Note: The normalizePayload function handles common field name variations across monitoring tools (snake_case, camelCase, etc.).
  </action>
  <verify>File exists at src/utils/content-fingerprint.ts with generateContentFingerprint and extractIdempotencyKey exports</verify>
  <done>Content fingerprinting utility created with field normalization, sorting, and message hashing</done>
</task>

<task type="auto">
  <name>Task 2: Create idempotency detection service</name>
  <files>src/services/idempotency.service.ts</files>
  <action>
Create a service that implements hybrid idempotency detection.

Key implementation details:
1. Check external idempotency key first (most reliable)
2. Fall back to content fingerprint if no key
3. Query WebhookDelivery within configurable deduplication window
4. Return { isDuplicate: boolean, existingAlertId?: string, webhookDeliveryId?: string }
5. Support recording new deliveries atomically

```typescript
import { prisma } from '../config/database.js';
import { generateContentFingerprint, extractIdempotencyKey } from '../utils/content-fingerprint.js';

export interface DuplicateCheckResult {
  isDuplicate: boolean;
  existingAlertId?: string;
  existingDeliveryId?: string;
}

export interface RecordDeliveryParams {
  integrationId: string;
  alertId?: string;        // Null for duplicates or failures
  idempotencyKey?: string;
  contentFingerprint: string;
  rawPayload: any;
  headers: Record<string, any>;
  statusCode: number;
  errorMessage?: string;
}

class IdempotencyService {
  /**
   * Checks if a webhook payload is a duplicate using hybrid detection.
   *
   * 1. First checks external idempotency key (if provided in headers)
   * 2. Falls back to content fingerprint matching
   *
   * @param integrationId - Integration ID for scoping
   * @param headers - Request headers (to extract idempotency key)
   * @param payload - Parsed webhook payload
   * @param windowMinutes - Deduplication window (from integration config)
   * @returns DuplicateCheckResult
   */
  async checkDuplicate(
    integrationId: string,
    headers: Record<string, string | string[] | undefined>,
    payload: any,
    windowMinutes: number
  ): Promise<DuplicateCheckResult> {
    const windowStart = new Date(Date.now() - windowMinutes * 60 * 1000);

    // 1. Check external idempotency key first (most reliable)
    const idempotencyKey = extractIdempotencyKey(headers);

    if (idempotencyKey) {
      const existingByKey = await prisma.webhookDelivery.findFirst({
        where: {
          integrationId,
          idempotencyKey,
          createdAt: { gte: windowStart }
        },
        select: {
          id: true,
          alertId: true
        }
      });

      if (existingByKey) {
        return {
          isDuplicate: true,
          existingAlertId: existingByKey.alertId || undefined,
          existingDeliveryId: existingByKey.id
        };
      }
    }

    // 2. Fall back to content fingerprint
    const fingerprint = generateContentFingerprint(payload);

    const existingByFingerprint = await prisma.webhookDelivery.findFirst({
      where: {
        integrationId,
        contentFingerprint: fingerprint,
        createdAt: { gte: windowStart }
      },
      select: {
        id: true,
        alertId: true
      }
    });

    if (existingByFingerprint) {
      return {
        isDuplicate: true,
        existingAlertId: existingByFingerprint.alertId || undefined,
        existingDeliveryId: existingByFingerprint.id
      };
    }

    return { isDuplicate: false };
  }

  /**
   * Records a webhook delivery attempt.
   * Should be called for every webhook received (success, duplicate, or failure).
   *
   * @param params - Delivery details
   * @returns Created WebhookDelivery record
   */
  async recordDelivery(params: RecordDeliveryParams) {
    return prisma.webhookDelivery.create({
      data: {
        integrationId: params.integrationId,
        alertId: params.alertId,
        idempotencyKey: params.idempotencyKey,
        contentFingerprint: params.contentFingerprint,
        rawPayload: params.rawPayload,
        headers: this.sanitizeHeaders(params.headers),
        statusCode: params.statusCode,
        errorMessage: params.errorMessage,
        processedAt: new Date()
      }
    });
  }

  /**
   * Generates fingerprint for a payload.
   * Exposed for use when recording deliveries.
   */
  generateFingerprint(payload: any): string {
    return generateContentFingerprint(payload);
  }

  /**
   * Extracts idempotency key from headers.
   * Exposed for use when recording deliveries.
   */
  extractKey(headers: Record<string, string | string[] | undefined>): string | undefined {
    return extractIdempotencyKey(headers);
  }

  /**
   * Sanitizes headers by removing sensitive values.
   * Stored for debugging but secrets should not be persisted.
   */
  private sanitizeHeaders(headers: Record<string, any>): Record<string, any> {
    const sensitivePatterns = [
      /authorization/i,
      /x-webhook-secret/i,
      /x-api-key/i,
      /cookie/i,
      /x-.*-token/i,
      /x-.*-signature/i  // Signatures are sensitive
    ];

    const sanitized: Record<string, any> = {};

    for (const [key, value] of Object.entries(headers)) {
      const isSensitive = sensitivePatterns.some(pattern => pattern.test(key));
      sanitized[key] = isSensitive ? '[REDACTED]' : value;
    }

    return sanitized;
  }
}

export const idempotencyService = new IdempotencyService();
```
  </action>
  <verify>File exists at src/services/idempotency.service.ts with idempotencyService export. TypeScript compiles without errors.</verify>
  <done>Idempotency service created with hybrid detection (key-first, fingerprint fallback), delivery recording, and header sanitization</done>
</task>

</tasks>

<verification>
- All files exist in expected locations
- `npm run build` succeeds (TypeScript compiles)
- `npm test` passes (no regressions)
- Exports: generateContentFingerprint, extractIdempotencyKey, idempotencyService
</verification>

<success_criteria>
- Hybrid detection checks external key before fingerprint
- Content fingerprinting normalizes fields and is order-independent
- Deduplication window is parameterized (from integration config)
- Delivery recording sanitizes sensitive headers
- Service returns existing alert ID for duplicates (enabling 200 response)
</success_criteria>

<output>
After completion, create `.planning/phases/02-alert-ingestion-webhooks/02-03-SUMMARY.md`
</output>

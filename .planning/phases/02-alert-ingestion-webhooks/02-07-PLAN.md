---
phase: 02-alert-ingestion-webhooks
plan: 07
type: execute
wave: 4
depends_on: ["02-05", "02-06"]
files_modified:
  - src/tests/webhook.test.ts
  - src/tests/integration.test.ts
autonomous: true

must_haves:
  truths:
    - "Integration CRUD operations tested (create, list, get, update, delete)"
    - "Webhook signature verification tested (valid, invalid, missing)"
    - "Idempotency tested (duplicate detection, fingerprint matching)"
    - "Alert creation flow tested end-to-end"
    - "RFC 7807 error responses verified"
  artifacts:
    - path: "src/tests/webhook.test.ts"
      provides: "Webhook receiver integration tests"
      min_lines: 150
    - path: "src/tests/integration.test.ts"
      provides: "Integration management API tests"
      min_lines: 100
  key_links:
    - from: "src/tests/webhook.test.ts"
      to: "src/webhooks/alert-receiver.ts"
      via: "tests POST /webhooks/alerts/:integration"
      pattern: "POST.*webhooks/alerts"
    - from: "src/tests/integration.test.ts"
      to: "src/routes/integration.routes.ts"
      via: "tests /api/integrations endpoints"
      pattern: "/api/integrations"
---

<objective>
Create integration tests for the webhook receiver and integration management API to verify Phase 2 success criteria.

Purpose: Validate that the complete alert ingestion pipeline works correctly: integration setup, signature verification, idempotency detection, validation, alert creation, and error handling.

Output: Comprehensive test suite covering happy path and error cases.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-alert-ingestion-webhooks/02-RESEARCH.md (Success criteria, patterns)
@src/tests/setup.ts (test utilities from Phase 1)
@src/tests/auth.test.ts (test patterns)
@src/tests/scim.test.ts (test patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration management API tests</name>
  <files>src/tests/integration.test.ts</files>
  <action>
Create tests for the integration management API.

Key test cases:
1. Create integration (returns secret once)
2. List integrations (secrets redacted)
3. Get integration by ID
4. Update integration
5. Rotate secret
6. Delete integration
7. Authorization (platform admin only)

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import request from 'supertest';
import { app } from '../index.js';
import { prisma } from '../config/database.js';
import crypto from 'crypto';

describe('Integration Management API', () => {
  let adminSessionCookie: string;
  let regularUserCookie: string;
  let testIntegrationId: string;

  beforeAll(async () => {
    // Ensure test database
    if (!process.env.DATABASE_URL?.includes('test')) {
      throw new Error('Tests must run against test database');
    }

    // Create platform admin user
    const adminUser = await prisma.user.upsert({
      where: { email: 'admin@test.com' },
      update: {},
      create: {
        email: 'admin@test.com',
        firstName: 'Admin',
        lastName: 'User',
        platformRole: 'PLATFORM_ADMIN',
        isBreakGlassAccount: true,
        passwordHash: await hashPassword('testpass123')
      }
    });

    // Create regular user
    const regularUser = await prisma.user.upsert({
      where: { email: 'user@test.com' },
      update: {},
      create: {
        email: 'user@test.com',
        firstName: 'Regular',
        lastName: 'User',
        platformRole: 'USER',
        isBreakGlassAccount: true,
        passwordHash: await hashPassword('testpass123')
      }
    });

    // Get session cookies
    const adminLogin = await request(app)
      .post('/auth/local/login')
      .send({ email: 'admin@test.com', password: 'testpass123' });
    adminSessionCookie = adminLogin.headers['set-cookie']?.[0] || '';

    const userLogin = await request(app)
      .post('/auth/local/login')
      .send({ email: 'user@test.com', password: 'testpass123' });
    regularUserCookie = userLogin.headers['set-cookie']?.[0] || '';
  });

  afterAll(async () => {
    // Cleanup
    await prisma.webhookDelivery.deleteMany({});
    await prisma.alert.deleteMany({});
    await prisma.integration.deleteMany({});
    await prisma.session.deleteMany({});
    await prisma.user.deleteMany({
      where: { email: { in: ['admin@test.com', 'user@test.com'] } }
    });
  });

  describe('POST /api/integrations', () => {
    it('should create integration with generated secret', async () => {
      const res = await request(app)
        .post('/api/integrations')
        .set('Cookie', adminSessionCookie)
        .send({
          name: 'test-datadog',
          type: 'datadog'
        });

      expect(res.status).toBe(201);
      expect(res.body.id).toBeDefined();
      expect(res.body.name).toBe('test-datadog');
      expect(res.body.type).toBe('datadog');
      expect(res.body.webhookSecret).toBeDefined();
      expect(res.body.webhookSecret.length).toBe(64); // 32 bytes hex
      expect(res.body.webhook_url).toBe('/webhooks/alerts/test-datadog');

      testIntegrationId = res.body.id;
    });

    it('should reject duplicate integration names', async () => {
      const res = await request(app)
        .post('/api/integrations')
        .set('Cookie', adminSessionCookie)
        .send({
          name: 'test-datadog',
          type: 'generic'
        });

      expect(res.status).toBe(409);
      expect(res.body.type).toContain('duplicate');
    });

    it('should require platform admin', async () => {
      const res = await request(app)
        .post('/api/integrations')
        .set('Cookie', regularUserCookie)
        .send({
          name: 'another-integration',
          type: 'generic'
        });

      expect(res.status).toBe(403);
    });

    it('should validate integration name format', async () => {
      const res = await request(app)
        .post('/api/integrations')
        .set('Cookie', adminSessionCookie)
        .send({
          name: 'Invalid Name!',
          type: 'generic'
        });

      expect(res.status).toBe(400);
      expect(res.body.validation_errors).toBeDefined();
    });
  });

  describe('GET /api/integrations', () => {
    it('should list integrations with secrets redacted', async () => {
      const res = await request(app)
        .get('/api/integrations')
        .set('Cookie', adminSessionCookie);

      expect(res.status).toBe(200);
      expect(res.body.integrations).toBeInstanceOf(Array);
      expect(res.body.integrations.length).toBeGreaterThan(0);

      const integration = res.body.integrations[0];
      expect(integration.webhookSecret).toBeUndefined();
      expect(integration.secretPrefix).toBeDefined();
      expect(integration.secretPrefix).toContain('...');
    });
  });

  describe('GET /api/integrations/:id', () => {
    it('should get single integration', async () => {
      const res = await request(app)
        .get(`/api/integrations/${testIntegrationId}`)
        .set('Cookie', adminSessionCookie);

      expect(res.status).toBe(200);
      expect(res.body.id).toBe(testIntegrationId);
      expect(res.body.webhookSecret).toBeUndefined();
    });

    it('should return 404 for unknown integration', async () => {
      const res = await request(app)
        .get('/api/integrations/unknown-id')
        .set('Cookie', adminSessionCookie);

      expect(res.status).toBe(404);
    });
  });

  describe('PATCH /api/integrations/:id', () => {
    it('should update integration', async () => {
      const res = await request(app)
        .patch(`/api/integrations/${testIntegrationId}`)
        .set('Cookie', adminSessionCookie)
        .send({
          deduplicationWindowMinutes: 30
        });

      expect(res.status).toBe(200);
      expect(res.body.deduplicationWindowMinutes).toBe(30);
    });

    it('should disable integration', async () => {
      const res = await request(app)
        .patch(`/api/integrations/${testIntegrationId}`)
        .set('Cookie', adminSessionCookie)
        .send({
          isActive: false
        });

      expect(res.status).toBe(200);
      expect(res.body.isActive).toBe(false);

      // Re-enable for subsequent tests
      await request(app)
        .patch(`/api/integrations/${testIntegrationId}`)
        .set('Cookie', adminSessionCookie)
        .send({ isActive: true });
    });
  });

  describe('POST /api/integrations/:id/rotate-secret', () => {
    it('should generate new secret', async () => {
      // Get current secret prefix
      const before = await request(app)
        .get(`/api/integrations/${testIntegrationId}`)
        .set('Cookie', adminSessionCookie);

      const res = await request(app)
        .post(`/api/integrations/${testIntegrationId}/rotate-secret`)
        .set('Cookie', adminSessionCookie);

      expect(res.status).toBe(200);
      expect(res.body.webhookSecret).toBeDefined();
      expect(res.body.webhookSecret.length).toBe(64);

      // New secret should be different
      const after = await request(app)
        .get(`/api/integrations/${testIntegrationId}`)
        .set('Cookie', adminSessionCookie);

      expect(after.body.secretPrefix).not.toBe(before.body.secretPrefix);
    });
  });

  describe('DELETE /api/integrations/:id', () => {
    it('should delete integration', async () => {
      // Create integration to delete
      const created = await request(app)
        .post('/api/integrations')
        .set('Cookie', adminSessionCookie)
        .send({ name: 'to-delete', type: 'generic' });

      const res = await request(app)
        .delete(`/api/integrations/${created.body.id}`)
        .set('Cookie', adminSessionCookie);

      expect(res.status).toBe(204);

      // Verify deleted
      const check = await request(app)
        .get(`/api/integrations/${created.body.id}`)
        .set('Cookie', adminSessionCookie);

      expect(check.status).toBe(404);
    });
  });
});

async function hashPassword(password: string): Promise<string> {
  const bcrypt = await import('bcryptjs');
  return bcrypt.hash(password, 10);
}
```
  </action>
  <verify>File exists at src/tests/integration.test.ts with test cases for CRUD operations</verify>
  <done>Integration API tests created covering create, list, get, update, rotate-secret, delete, and authorization</done>
</task>

<task type="auto">
  <name>Task 2: Create webhook receiver tests</name>
  <files>src/tests/webhook.test.ts</files>
  <action>
Create tests for the webhook receiver endpoint.

Key test cases:
1. Valid webhook creates alert
2. Invalid signature returns 401
3. Missing signature returns 401
4. Duplicate webhook returns 200 with existing alert ID
5. Invalid payload returns 400 with validation errors
6. Disabled integration returns 404
7. Test endpoint is accessible without auth

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import request from 'supertest';
import crypto from 'crypto';
import { app } from '../index.js';
import { prisma } from '../config/database.js';

describe('Webhook Receiver', () => {
  let integration: any;
  let webhookSecret: string;

  beforeAll(async () => {
    // Ensure test database
    if (!process.env.DATABASE_URL?.includes('test')) {
      throw new Error('Tests must run against test database');
    }

    // Create test integration directly (bypass API to get secret)
    webhookSecret = crypto.randomBytes(32).toString('hex');

    integration = await prisma.integration.create({
      data: {
        name: 'test-webhook-integration',
        type: 'generic',
        webhookSecret,
        signatureHeader: 'X-Webhook-Signature',
        signatureAlgorithm: 'sha256',
        signatureFormat: 'hex',
        deduplicationWindowMinutes: 15
      }
    });
  });

  afterAll(async () => {
    // Cleanup in order (respect foreign keys)
    await prisma.webhookDelivery.deleteMany({});
    await prisma.alert.deleteMany({});
    await prisma.integration.deleteMany({});
  });

  beforeEach(async () => {
    // Clean alerts and deliveries between tests
    await prisma.webhookDelivery.deleteMany({});
    await prisma.alert.deleteMany({});
  });

  function generateSignature(payload: string, secret: string): string {
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(payload);
    return hmac.digest('hex');
  }

  describe('POST /webhooks/alerts/:integrationName', () => {
    it('should create alert from valid webhook', async () => {
      const payload = {
        title: 'High CPU Alert',
        severity: 'critical',
        timestamp: new Date().toISOString(),
        description: 'CPU usage exceeded 90%',
        source: 'test-server',
        external_id: 'alert-123'
      };

      const payloadString = JSON.stringify(payload);
      const signature = generateSignature(payloadString, webhookSecret);

      const res = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', signature)
        .send(payload);

      expect(res.status).toBe(201);
      expect(res.body.alert_id).toBeDefined();
      expect(res.body.status).toBe('created');
      expect(res.body.title).toBe('High CPU Alert');
      expect(res.body.severity).toBe('CRITICAL');

      // Verify alert in database
      const alert = await prisma.alert.findUnique({
        where: { id: res.body.alert_id }
      });
      expect(alert).toBeDefined();
      expect(alert?.title).toBe('High CPU Alert');
      expect(alert?.status).toBe('OPEN');

      // Verify delivery logged
      const delivery = await prisma.webhookDelivery.findFirst({
        where: { alertId: alert?.id }
      });
      expect(delivery).toBeDefined();
      expect(delivery?.statusCode).toBe(201);
    });

    it('should reject webhook with invalid signature', async () => {
      const payload = {
        title: 'Test Alert',
        severity: 'low',
        timestamp: new Date().toISOString()
      };

      const res = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', 'invalid-signature')
        .send(payload);

      expect(res.status).toBe(401);
      expect(res.body.type).toContain('invalid-signature');
    });

    it('should reject webhook with missing signature', async () => {
      const payload = {
        title: 'Test Alert',
        severity: 'low',
        timestamp: new Date().toISOString()
      };

      const res = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .send(payload);

      expect(res.status).toBe(401);
      expect(res.body.type).toContain('missing-signature');
    });

    it('should return 200 for duplicate webhook (idempotent)', async () => {
      const payload = {
        title: 'Duplicate Test',
        severity: 'high',
        timestamp: new Date().toISOString(),
        external_id: 'dup-123'
      };

      const payloadString = JSON.stringify(payload);
      const signature = generateSignature(payloadString, webhookSecret);

      // First request creates alert
      const first = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', signature)
        .send(payload);

      expect(first.status).toBe(201);
      const alertId = first.body.alert_id;

      // Second request is duplicate
      const second = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', signature)
        .send(payload);

      expect(second.status).toBe(200);
      expect(second.body.status).toBe('duplicate');
      expect(second.body.alert_id).toBe(alertId);
      expect(second.body.idempotent).toBe(true);

      // Verify only one alert created
      const alertCount = await prisma.alert.count();
      expect(alertCount).toBe(1);

      // Verify both deliveries logged
      const deliveryCount = await prisma.webhookDelivery.count();
      expect(deliveryCount).toBe(2);
    });

    it('should detect duplicate by idempotency key header', async () => {
      const idempotencyKey = `test-${Date.now()}`;

      // Different payloads but same idempotency key
      const payload1 = {
        title: 'Alert 1',
        severity: 'low',
        timestamp: new Date().toISOString()
      };

      const payload2 = {
        title: 'Alert 2',
        severity: 'medium',
        timestamp: new Date().toISOString()
      };

      const signature1 = generateSignature(JSON.stringify(payload1), webhookSecret);
      const signature2 = generateSignature(JSON.stringify(payload2), webhookSecret);

      // First request
      const first = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', signature1)
        .set('Idempotency-Key', idempotencyKey)
        .send(payload1);

      expect(first.status).toBe(201);

      // Second request with same idempotency key
      const second = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', signature2)
        .set('Idempotency-Key', idempotencyKey)
        .send(payload2);

      expect(second.status).toBe(200);
      expect(second.body.status).toBe('duplicate');
      expect(second.body.alert_id).toBe(first.body.alert_id);
    });

    it('should return 400 for invalid payload', async () => {
      const payload = {
        // Missing required title
        severity: 'high',
        timestamp: new Date().toISOString()
      };

      const payloadString = JSON.stringify(payload);
      const signature = generateSignature(payloadString, webhookSecret);

      const res = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', signature)
        .send(payload);

      expect(res.status).toBe(400);
      expect(res.body.type).toContain('validation-failed');
      expect(res.body.validation_errors).toBeDefined();
      expect(res.body.validation_errors.some((e: any) => e.field === 'title')).toBe(true);

      // Verify delivery logged with 400
      const delivery = await prisma.webhookDelivery.findFirst({
        orderBy: { createdAt: 'desc' }
      });
      expect(delivery?.statusCode).toBe(400);
    });

    it('should return 404 for unknown integration', async () => {
      const payload = {
        title: 'Test',
        severity: 'low',
        timestamp: new Date().toISOString()
      };

      const res = await request(app)
        .post('/webhooks/alerts/nonexistent-integration')
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', 'any')
        .send(payload);

      expect(res.status).toBe(404);
    });

    it('should return 404 for disabled integration', async () => {
      // Disable integration
      await prisma.integration.update({
        where: { id: integration.id },
        data: { isActive: false }
      });

      const payload = {
        title: 'Test',
        severity: 'low',
        timestamp: new Date().toISOString()
      };

      const payloadString = JSON.stringify(payload);
      const signature = generateSignature(payloadString, webhookSecret);

      const res = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', signature)
        .send(payload);

      expect(res.status).toBe(404);

      // Re-enable
      await prisma.integration.update({
        where: { id: integration.id },
        data: { isActive: true }
      });
    });

    it('should normalize severity values', async () => {
      const testCases = [
        { input: 'P1', expected: 'CRITICAL' },
        { input: 'warning', expected: 'MEDIUM' },
        { input: 'EMERGENCY', expected: 'CRITICAL' },
        { input: 'info', expected: 'INFO' }
      ];

      for (const { input, expected } of testCases) {
        const payload = {
          title: `Test ${input}`,
          severity: input,
          timestamp: new Date().toISOString()
        };

        const payloadString = JSON.stringify(payload);
        const signature = generateSignature(payloadString, webhookSecret);

        const res = await request(app)
          .post(`/webhooks/alerts/${integration.name}`)
          .set('Content-Type', 'application/json')
          .set('X-Webhook-Signature', signature)
          .send(payload);

        expect(res.status).toBe(201);
        expect(res.body.severity).toBe(expected);

        // Cleanup for next iteration
        await prisma.webhookDelivery.deleteMany({});
        await prisma.alert.deleteMany({});
      }
    });

    it('should handle Unix timestamps', async () => {
      const unixTimestamp = Math.floor(Date.now() / 1000);
      const payload = {
        title: 'Unix Timestamp Test',
        severity: 'low',
        timestamp: unixTimestamp
      };

      const payloadString = JSON.stringify(payload);
      const signature = generateSignature(payloadString, webhookSecret);

      const res = await request(app)
        .post(`/webhooks/alerts/${integration.name}`)
        .set('Content-Type', 'application/json')
        .set('X-Webhook-Signature', signature)
        .send(payload);

      expect(res.status).toBe(201);
      expect(res.body.triggered_at).toBeDefined();
      // Should be close to now
      const triggeredAt = new Date(res.body.triggered_at);
      expect(Math.abs(triggeredAt.getTime() - Date.now())).toBeLessThan(5000);
    });
  });

  describe('GET /webhooks/alerts/:integrationName/test', () => {
    it('should return 200 without auth', async () => {
      const res = await request(app)
        .get(`/webhooks/alerts/${integration.name}/test`);

      expect(res.status).toBe(200);
      expect(res.body.status).toBe('ok');
      expect(res.body.message).toContain('reachable');
    });
  });
});
```
  </action>
  <verify>File exists at src/tests/webhook.test.ts with test cases for signature, idempotency, validation</verify>
  <done>Webhook receiver tests created covering valid webhooks, signature verification, idempotency, validation errors, and edge cases</done>
</task>

<task type="auto">
  <name>Task 3: Run tests and verify all pass</name>
  <files></files>
  <action>
Run the full test suite to verify Phase 2 implementation:

```bash
npm test
```

All tests should pass. If any fail:
1. Read the error message carefully
2. Fix the issue in the relevant source file
3. Re-run tests

Expected test output should show all tests passing including:
- auth.test.ts (Phase 1)
- scim.test.ts (Phase 1)
- team.test.ts (Phase 1)
- integration.test.ts (Phase 2 - new)
- webhook.test.ts (Phase 2 - new)

Also verify build succeeds:
```bash
npm run build
```
  </action>
  <verify>npm test passes with 0 failures. npm run build succeeds.</verify>
  <done>All tests pass including new Phase 2 tests. Build succeeds.</done>
</task>

</tasks>

<verification>
- `npm test` passes with all tests green
- `npm run build` succeeds
- Test coverage includes:
  - Integration CRUD operations
  - Webhook signature verification (valid/invalid/missing)
  - Idempotency detection (key-based and fingerprint-based)
  - Alert creation with delivery logging
  - RFC 7807 error responses
  - Severity normalization
  - Timestamp handling
</verification>

<success_criteria>
- All Phase 2 tests pass
- No regressions in Phase 1 tests
- Tests cover all roadmap success criteria:
  1. System receives alerts via webhook API - tested
  2. System validates webhook signatures - tested
  3. System processes idempotently - tested
  4. System stores alerts with audit trail - tested
  5. System handles retries correctly - tested via idempotency
</success_criteria>

<output>
After completion, create `.planning/phases/02-alert-ingestion-webhooks/02-07-SUMMARY.md`
</output>

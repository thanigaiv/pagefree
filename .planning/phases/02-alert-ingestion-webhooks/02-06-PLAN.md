---
phase: 02-alert-ingestion-webhooks
plan: 06
type: execute
wave: 3
depends_on: ["02-02", "02-03", "02-04"]
files_modified:
  - src/services/alert.service.ts
  - src/webhooks/alert-receiver.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Webhooks received at /webhooks/alerts/:integrationName"
    - "Signature verified before processing using integration's secret"
    - "Duplicate webhooks return 200 with existing alert ID"
    - "Valid webhooks create Alert and WebhookDelivery records"
    - "All webhook attempts logged (success, duplicate, failure)"
  artifacts:
    - path: "src/services/alert.service.ts"
      provides: "Alert creation service"
      exports: ["alertService"]
    - path: "src/webhooks/alert-receiver.ts"
      provides: "Generic webhook receiver router"
      exports: ["alertWebhookRouter"]
  key_links:
    - from: "src/webhooks/alert-receiver.ts"
      to: "src/webhooks/middleware/signature-verification.ts"
      via: "import createDynamicSignatureVerifier"
      pattern: "import.*createDynamicSignatureVerifier"
    - from: "src/webhooks/alert-receiver.ts"
      to: "src/services/idempotency.service.ts"
      via: "import idempotencyService"
      pattern: "import.*idempotencyService"
    - from: "src/webhooks/alert-receiver.ts"
      to: "src/webhooks/schemas/alert.schema.ts"
      via: "import validateAlertPayload"
      pattern: "import.*validateAlertPayload"
    - from: "src/index.ts"
      to: "src/webhooks/alert-receiver.ts"
      via: "app.use('/webhooks/alerts', alertWebhookRouter)"
      pattern: "app\\.use.*alertWebhookRouter"
---

<objective>
Create the main webhook receiver endpoint that ties together signature verification, idempotency, validation, and alert creation.

Purpose: This is the entry point for monitoring tools to send alerts. It implements the full webhook pipeline: verify signature, check duplicate, validate payload, create alert, log delivery.

Output: Working webhook endpoint at /webhooks/alerts/:integrationName that receives and processes alerts.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-alert-ingestion-webhooks/02-RESEARCH.md (Architecture patterns, Code examples)
@.planning/phases/02-alert-ingestion-webhooks/02-02-SUMMARY.md (Signature verification)
@.planning/phases/02-alert-ingestion-webhooks/02-03-SUMMARY.md (Idempotency service)
@.planning/phases/02-alert-ingestion-webhooks/02-04-SUMMARY.md (Alert schema)
@prisma/schema.prisma
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create alert service</name>
  <files>src/services/alert.service.ts</files>
  <action>
Create a service for creating and managing alerts.

Key implementation details:
1. Create alert with normalized data from validated payload
2. Use transaction to ensure alert and webhook delivery are created together
3. Return alert for response
4. Add methods for future operations (acknowledge, resolve, etc.)

```typescript
import { prisma } from '../config/database.js';
import { AlertSeverity, AlertStatus } from '@prisma/client';
import { auditService } from './audit.service.js';

export interface CreateAlertParams {
  title: string;
  description: string | null;
  severity: AlertSeverity;
  triggeredAt: Date;
  source: string | null;
  externalId: string | null;
  metadata: Record<string, any>;
  integrationId: string;
}

export interface RecordDeliveryParams {
  integrationId: string;
  alertId?: string;
  idempotencyKey?: string;
  contentFingerprint: string;
  rawPayload: any;
  headers: Record<string, any>;
  statusCode: number;
  errorMessage?: string;
}

class AlertService {
  /**
   * Creates an alert and records the webhook delivery atomically.
   */
  async createWithDelivery(
    alertParams: CreateAlertParams,
    deliveryParams: Omit<RecordDeliveryParams, 'integrationId' | 'alertId'>
  ) {
    return prisma.$transaction(async (tx) => {
      // Create the alert
      const alert = await tx.alert.create({
        data: {
          title: alertParams.title,
          description: alertParams.description,
          severity: alertParams.severity,
          status: AlertStatus.OPEN,
          source: alertParams.source || 'unknown',
          externalId: alertParams.externalId,
          triggeredAt: alertParams.triggeredAt,
          metadata: alertParams.metadata,
          integrationId: alertParams.integrationId
        }
      });

      // Record the webhook delivery
      const delivery = await tx.webhookDelivery.create({
        data: {
          integrationId: alertParams.integrationId,
          alertId: alert.id,
          idempotencyKey: deliveryParams.idempotencyKey,
          contentFingerprint: deliveryParams.contentFingerprint,
          rawPayload: deliveryParams.rawPayload,
          headers: deliveryParams.headers,
          statusCode: deliveryParams.statusCode,
          errorMessage: deliveryParams.errorMessage,
          processedAt: new Date()
        }
      });

      return { alert, delivery };
    });
  }

  /**
   * Records a webhook delivery without creating an alert (for duplicates/failures).
   */
  async recordDeliveryOnly(params: RecordDeliveryParams) {
    return prisma.webhookDelivery.create({
      data: {
        integrationId: params.integrationId,
        alertId: params.alertId,
        idempotencyKey: params.idempotencyKey,
        contentFingerprint: params.contentFingerprint,
        rawPayload: params.rawPayload,
        headers: params.headers,
        statusCode: params.statusCode,
        errorMessage: params.errorMessage,
        processedAt: new Date()
      }
    });
  }

  /**
   * Gets an alert by ID.
   */
  async getById(id: string) {
    return prisma.alert.findUnique({
      where: { id },
      include: {
        integration: {
          select: { id: true, name: true, type: true }
        }
      }
    });
  }

  /**
   * Lists alerts with filters.
   */
  async list(options: {
    integrationId?: string;
    status?: AlertStatus;
    severity?: AlertSeverity;
    limit?: number;
    offset?: number;
  } = {}) {
    const { integrationId, status, severity, limit = 50, offset = 0 } = options;

    return prisma.alert.findMany({
      where: {
        ...(integrationId && { integrationId }),
        ...(status && { status }),
        ...(severity && { severity })
      },
      orderBy: { triggeredAt: 'desc' },
      take: limit,
      skip: offset,
      include: {
        integration: {
          select: { id: true, name: true, type: true }
        }
      }
    });
  }

  /**
   * Acknowledges an alert.
   */
  async acknowledge(id: string, userId: string) {
    const alert = await prisma.alert.update({
      where: { id },
      data: {
        status: AlertStatus.ACKNOWLEDGED,
        acknowledgedAt: new Date()
      }
    });

    await auditService.log({
      action: 'alert.acknowledged',
      userId,
      resourceType: 'alert',
      resourceId: id,
      metadata: { title: alert.title }
    });

    return alert;
  }

  /**
   * Resolves an alert.
   */
  async resolve(id: string, userId: string) {
    const alert = await prisma.alert.update({
      where: { id },
      data: {
        status: AlertStatus.RESOLVED,
        resolvedAt: new Date()
      }
    });

    await auditService.log({
      action: 'alert.resolved',
      userId,
      resourceType: 'alert',
      resourceId: id,
      metadata: { title: alert.title }
    });

    return alert;
  }

  /**
   * Sanitizes headers for storage (remove sensitive values).
   */
  sanitizeHeaders(headers: Record<string, any>): Record<string, any> {
    const sensitivePatterns = [
      /authorization/i,
      /x-webhook-secret/i,
      /x-api-key/i,
      /cookie/i,
      /x-.*-token/i,
      /x-.*-signature/i
    ];

    const sanitized: Record<string, any> = {};

    for (const [key, value] of Object.entries(headers)) {
      const isSensitive = sensitivePatterns.some(pattern => pattern.test(key));
      sanitized[key] = isSensitive ? '[REDACTED]' : value;
    }

    return sanitized;
  }
}

export const alertService = new AlertService();
```
  </action>
  <verify>File exists at src/services/alert.service.ts with alertService export</verify>
  <done>Alert service created with createWithDelivery, recordDeliveryOnly, and basic CRUD operations</done>
</task>

<task type="auto">
  <name>Task 2: Create alert webhook receiver router</name>
  <files>src/webhooks/alert-receiver.ts</files>
  <action>
Create the main webhook receiver that processes alerts from monitoring tools.

Key implementation details:
1. Use rawBodyCapture middleware for body parsing
2. Use dynamic signature verifier (integration name from URL)
3. Check idempotency before validation
4. Validate payload and normalize
5. Create alert with delivery log
6. Return appropriate responses (201 created, 200 duplicate, 400 invalid, 401 unauthorized)
7. Log all attempts to audit trail

```typescript
import { Router, Request, Response } from 'express';
import { rawBodyCapture } from './middleware/raw-body-capture.js';
import { createDynamicSignatureVerifier } from './middleware/signature-verification.js';
import { idempotencyService } from '../services/idempotency.service.js';
import { alertService } from '../services/alert.service.js';
import { validateAlertPayload } from './schemas/alert.schema.js';
import { formatValidationError, createProblemDetails } from '../utils/problem-details.js';
import { auditService } from '../services/audit.service.js';
import { logger } from '../config/logger.js';

export const alertWebhookRouter = Router();

// Apply raw body capture (required for signature verification)
alertWebhookRouter.use(rawBodyCapture('1mb'));

/**
 * POST /webhooks/alerts/:integrationName
 * Receives alerts from monitoring tools.
 */
alertWebhookRouter.post(
  '/:integrationName',
  createDynamicSignatureVerifier(),
  async (req: Request, res: Response): Promise<void> => {
    // Integration attached by signature verifier
    const integration = (req as any).integration;

    if (!integration) {
      // This shouldn't happen if signature verifier ran, but guard anyway
      res.status(500).json(createProblemDetails(
        'internal-error',
        'Integration context missing',
        500
      ));
      return;
    }

    const headers = req.headers as Record<string, string | string[] | undefined>;
    const fingerprint = idempotencyService.generateFingerprint(req.body);
    const idempotencyKey = idempotencyService.extractKey(headers);

    try {
      // 1. Check for duplicate
      const duplicateCheck = await idempotencyService.checkDuplicate(
        integration.id,
        headers,
        req.body,
        integration.deduplicationWindowMinutes
      );

      if (duplicateCheck.isDuplicate) {
        // Record the delivery attempt (duplicate)
        await alertService.recordDeliveryOnly({
          integrationId: integration.id,
          alertId: duplicateCheck.existingAlertId,
          idempotencyKey,
          contentFingerprint: fingerprint,
          rawPayload: req.body,
          headers: alertService.sanitizeHeaders(req.headers),
          statusCode: 200,
          errorMessage: 'Duplicate webhook'
        });

        await auditService.log({
          action: 'webhook.duplicate',
          resourceType: 'alert',
          resourceId: duplicateCheck.existingAlertId,
          metadata: {
            integration: integration.name,
            idempotencyKey,
            fingerprint: fingerprint.substring(0, 16)
          }
        });

        // Return 200 with existing alert ID (idempotent behavior per locked decision)
        res.status(200).json({
          alert_id: duplicateCheck.existingAlertId,
          status: 'duplicate',
          message: 'Alert already processed',
          idempotent: true
        });
        return;
      }

      // 2. Validate payload
      const validation = validateAlertPayload(req.body, integration.name);

      if (!validation.success) {
        // Record the delivery attempt (validation failure)
        await alertService.recordDeliveryOnly({
          integrationId: integration.id,
          idempotencyKey,
          contentFingerprint: fingerprint,
          rawPayload: req.body,
          headers: alertService.sanitizeHeaders(req.headers),
          statusCode: 400,
          errorMessage: validation.error.message
        });

        await auditService.log({
          action: 'webhook.validation_failed',
          severity: 'WARN',
          metadata: {
            integration: integration.name,
            errors: validation.error.issues.length
          }
        });

        res.status(400).json(formatValidationError(validation.error, req.path));
        return;
      }

      // 3. Create alert with delivery log
      const { alert, delivery } = await alertService.createWithDelivery(
        {
          title: validation.data.title,
          description: validation.data.description,
          severity: validation.data.severity,
          triggeredAt: validation.data.triggeredAt,
          source: validation.data.source,
          externalId: validation.data.externalId,
          metadata: validation.data.metadata,
          integrationId: integration.id
        },
        {
          idempotencyKey,
          contentFingerprint: fingerprint,
          rawPayload: req.body,
          headers: alertService.sanitizeHeaders(req.headers),
          statusCode: 201
        }
      );

      await auditService.log({
        action: 'alert.created',
        resourceType: 'alert',
        resourceId: alert.id,
        metadata: {
          integration: integration.name,
          title: alert.title,
          severity: alert.severity
        }
      });

      logger.info({
        msg: 'Alert created from webhook',
        alertId: alert.id,
        integration: integration.name,
        severity: alert.severity
      });

      res.status(201).json({
        alert_id: alert.id,
        status: 'created',
        title: alert.title,
        severity: alert.severity,
        triggered_at: alert.triggeredAt.toISOString()
      });

    } catch (error) {
      // Record delivery failure
      try {
        await alertService.recordDeliveryOnly({
          integrationId: integration.id,
          idempotencyKey,
          contentFingerprint: fingerprint,
          rawPayload: req.body,
          headers: alertService.sanitizeHeaders(req.headers),
          statusCode: 500,
          errorMessage: error instanceof Error ? error.message : 'Unknown error'
        });
      } catch (logError) {
        logger.error({ error: logError }, 'Failed to log delivery failure');
      }

      await auditService.log({
        action: 'webhook.processing_failed',
        severity: 'HIGH',
        metadata: {
          integration: integration.name,
          error: error instanceof Error ? error.message : 'Unknown error'
        }
      });

      logger.error({ error }, 'Webhook processing failed');

      res.status(500).json(createProblemDetails(
        'processing-failed',
        'Internal processing error',
        500,
        { detail: 'An unexpected error occurred while processing the webhook' }
      ));
    }
  }
);

/**
 * GET /webhooks/alerts/:integrationName/test
 * Test endpoint to verify webhook URL is reachable (no auth required).
 */
alertWebhookRouter.get('/:integrationName/test', (_req: Request, res: Response) => {
  res.json({
    status: 'ok',
    message: 'Webhook endpoint is reachable. POST alerts to this URL.',
    timestamp: new Date().toISOString()
  });
});
```
  </action>
  <verify>File exists at src/webhooks/alert-receiver.ts with alertWebhookRouter export</verify>
  <done>Alert webhook receiver created with full pipeline: signature verification, idempotency check, validation, alert creation, delivery logging</done>
</task>

<task type="auto">
  <name>Task 3: Mount webhook router in app</name>
  <files>src/index.ts</files>
  <action>
Add alert webhook routes to the Express application.

Add import at top with other imports:
```typescript
import { alertWebhookRouter } from './webhooks/alert-receiver.js';
```

Add route mounting BEFORE the generic body parser and AFTER the Okta webhook (around line 50, after the Okta webhook mount):
```typescript
// Alert webhooks (uses its own body parser for raw body capture)
app.use('/webhooks/alerts', alertWebhookRouter);
```

IMPORTANT: This MUST be mounted BEFORE `app.use(express.json())` because the alertWebhookRouter uses its own body parser (rawBodyCapture) that captures the raw body for signature verification. If express.json() runs first, the body is already parsed and raw body cannot be captured.

The order should be:
1. Session middleware
2. Passport
3. Okta webhooks (existing)
4. Alert webhooks (new)
5. SCIM endpoints
6. express.json() for remaining routes
7. Other API routes
  </action>
  <verify>src/index.ts contains import for alertWebhookRouter and app.use('/webhooks/alerts') BEFORE express.json()</verify>
  <done>Alert webhook router mounted at /webhooks/alerts before body parser</done>
</task>

</tasks>

<verification>
- All files exist in expected locations
- `npm run build` succeeds (TypeScript compiles)
- `npm test` passes (no regressions)
- Server starts without errors
- GET /webhooks/alerts/test-integration/test returns 200 (reachability check)
</verification>

<success_criteria>
- Webhook endpoint exists at POST /webhooks/alerts/:integrationName
- Signature verified using integration's secret and configuration
- Duplicates return 200 with existing alert_id (idempotent)
- Valid webhooks create Alert and WebhookDelivery records
- Invalid payloads return 400 with RFC 7807 validation errors
- All attempts logged (success, duplicate, validation failure, processing error)
- Raw body captured for signature verification
</success_criteria>

<output>
After completion, create `.planning/phases/02-alert-ingestion-webhooks/02-06-SUMMARY.md`
</output>

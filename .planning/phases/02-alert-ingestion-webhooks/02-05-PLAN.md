---
phase: 02-alert-ingestion-webhooks
plan: 05
type: execute
wave: 3
depends_on: ["02-01"]
files_modified:
  - src/services/integration.service.ts
  - src/routes/integration.routes.ts
  - src/index.ts
  - src/config/env.ts
autonomous: true

must_haves:
  truths:
    - "Platform admins can create integrations with webhook secrets"
    - "Integration webhook secrets are generated cryptographically securely"
    - "Integrations can be enabled/disabled without deletion"
    - "Integration list shows all configured integrations with status"
  artifacts:
    - path: "src/services/integration.service.ts"
      provides: "Integration CRUD service"
      exports: ["integrationService"]
    - path: "src/routes/integration.routes.ts"
      provides: "Integration management API routes"
      exports: ["integrationRouter"]
  key_links:
    - from: "src/routes/integration.routes.ts"
      to: "src/services/integration.service.ts"
      via: "import integrationService"
      pattern: "import.*integrationService"
    - from: "src/index.ts"
      to: "src/routes/integration.routes.ts"
      via: "app.use('/api/integrations', integrationRouter)"
      pattern: "app\\.use.*integrationRouter"
---

<objective>
Create integration management service and API for configuring webhook sources (DataDog, New Relic, generic).

Purpose: Before webhooks can be received, integrations must be configured with secrets and settings. This provides the admin interface to set up monitoring tool connections.

Output: REST API for CRUD operations on integrations, accessible to platform admins only.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-alert-ingestion-webhooks/02-RESEARCH.md (Integration model)
@src/routes/apiKey.routes.ts (pattern for admin-only routes)
@src/middleware/auth.ts (requireAuth, requirePlatformAdmin)
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration service</name>
  <files>src/services/integration.service.ts</files>
  <action>
Create a service for managing Integration records.

Key implementation details:
1. Generate cryptographically secure webhook secrets (32 bytes hex)
2. Support common integration types (datadog, newrelic, pagerduty, generic)
3. Provide sensible defaults for signature configuration per type
4. Never expose full webhook secret after creation (show prefix only)
5. Support enable/disable without deletion

```typescript
import crypto from 'crypto';
import { prisma } from '../config/database.js';
import { auditService } from './audit.service.js';

export interface CreateIntegrationParams {
  name: string;
  type: 'datadog' | 'newrelic' | 'pagerduty' | 'generic';
  signatureHeader?: string;
  signatureAlgorithm?: 'sha256' | 'sha512';
  signatureFormat?: 'hex' | 'base64';
  signaturePrefix?: string;
  deduplicationWindowMinutes?: number;
}

export interface UpdateIntegrationParams {
  name?: string;
  signatureHeader?: string;
  signatureAlgorithm?: 'sha256' | 'sha512';
  signatureFormat?: 'hex' | 'base64';
  signaturePrefix?: string;
  deduplicationWindowMinutes?: number;
  isActive?: boolean;
}

// Default configurations per integration type
const TYPE_DEFAULTS: Record<string, Partial<CreateIntegrationParams>> = {
  datadog: {
    signatureHeader: 'X-Datadog-Signature',
    signatureAlgorithm: 'sha256',
    signatureFormat: 'hex',
    signaturePrefix: '',
    deduplicationWindowMinutes: 15
  },
  newrelic: {
    signatureHeader: 'X-NewRelic-Signature',
    signatureAlgorithm: 'sha256',
    signatureFormat: 'hex',
    signaturePrefix: '',
    deduplicationWindowMinutes: 15
  },
  pagerduty: {
    signatureHeader: 'X-PagerDuty-Signature',
    signatureAlgorithm: 'sha256',
    signatureFormat: 'base64',
    signaturePrefix: 'v1=',
    deduplicationWindowMinutes: 10
  },
  generic: {
    signatureHeader: 'X-Webhook-Signature',
    signatureAlgorithm: 'sha256',
    signatureFormat: 'hex',
    signaturePrefix: '',
    deduplicationWindowMinutes: 15
  }
};

class IntegrationService {
  /**
   * Creates a new integration with a generated webhook secret.
   * Returns the secret ONCE - it cannot be retrieved later.
   */
  async create(params: CreateIntegrationParams, userId: string) {
    // Generate cryptographically secure secret
    const webhookSecret = crypto.randomBytes(32).toString('hex');

    // Merge type defaults with provided params
    const defaults = TYPE_DEFAULTS[params.type] || TYPE_DEFAULTS.generic;

    const integration = await prisma.integration.create({
      data: {
        name: params.name,
        type: params.type,
        webhookSecret,
        signatureHeader: params.signatureHeader || defaults.signatureHeader!,
        signatureAlgorithm: params.signatureAlgorithm || defaults.signatureAlgorithm!,
        signatureFormat: params.signatureFormat || defaults.signatureFormat!,
        signaturePrefix: params.signaturePrefix ?? defaults.signaturePrefix ?? null,
        deduplicationWindowMinutes: params.deduplicationWindowMinutes || defaults.deduplicationWindowMinutes!
      }
    });

    await auditService.log({
      action: 'integration.created',
      userId,
      resourceType: 'integration',
      resourceId: integration.id,
      severity: 'HIGH',
      metadata: {
        name: integration.name,
        type: integration.type
      }
    });

    // Return integration with secret (one-time only)
    return {
      ...this.sanitize(integration),
      webhookSecret  // Include secret on creation only
    };
  }

  /**
   * Lists all integrations (secrets redacted).
   */
  async list() {
    const integrations = await prisma.integration.findMany({
      orderBy: { createdAt: 'desc' },
      include: {
        _count: {
          select: { alerts: true, webhookDeliveries: true }
        }
      }
    });

    return integrations.map(int => ({
      ...this.sanitize(int),
      alertCount: int._count.alerts,
      webhookCount: int._count.webhookDeliveries
    }));
  }

  /**
   * Gets a single integration by ID (secret redacted).
   */
  async getById(id: string) {
    const integration = await prisma.integration.findUnique({
      where: { id },
      include: {
        _count: {
          select: { alerts: true, webhookDeliveries: true }
        }
      }
    });

    if (!integration) return null;

    return {
      ...this.sanitize(integration),
      alertCount: integration._count.alerts,
      webhookCount: integration._count.webhookDeliveries
    };
  }

  /**
   * Gets a single integration by name (secret redacted).
   */
  async getByName(name: string) {
    const integration = await prisma.integration.findUnique({
      where: { name }
    });

    if (!integration) return null;

    return this.sanitize(integration);
  }

  /**
   * Updates integration configuration (cannot change secret).
   */
  async update(id: string, params: UpdateIntegrationParams, userId: string) {
    const existing = await prisma.integration.findUnique({ where: { id } });
    if (!existing) return null;

    const integration = await prisma.integration.update({
      where: { id },
      data: {
        name: params.name,
        signatureHeader: params.signatureHeader,
        signatureAlgorithm: params.signatureAlgorithm,
        signatureFormat: params.signatureFormat,
        signaturePrefix: params.signaturePrefix,
        deduplicationWindowMinutes: params.deduplicationWindowMinutes,
        isActive: params.isActive
      }
    });

    await auditService.log({
      action: 'integration.updated',
      userId,
      resourceType: 'integration',
      resourceId: integration.id,
      severity: 'INFO',
      metadata: {
        name: integration.name,
        changes: params
      }
    });

    return this.sanitize(integration);
  }

  /**
   * Rotates the webhook secret for an integration.
   * Returns the new secret ONCE.
   */
  async rotateSecret(id: string, userId: string) {
    const existing = await prisma.integration.findUnique({ where: { id } });
    if (!existing) return null;

    const newSecret = crypto.randomBytes(32).toString('hex');

    const integration = await prisma.integration.update({
      where: { id },
      data: { webhookSecret: newSecret }
    });

    await auditService.log({
      action: 'integration.secret_rotated',
      userId,
      resourceType: 'integration',
      resourceId: integration.id,
      severity: 'HIGH',
      metadata: { name: integration.name }
    });

    return {
      ...this.sanitize(integration),
      webhookSecret: newSecret  // Include new secret on rotation
    };
  }

  /**
   * Deletes an integration (hard delete).
   * WARNING: This will orphan related alerts and webhook deliveries.
   */
  async delete(id: string, userId: string) {
    const existing = await prisma.integration.findUnique({ where: { id } });
    if (!existing) return false;

    await prisma.integration.delete({ where: { id } });

    await auditService.log({
      action: 'integration.deleted',
      userId,
      resourceType: 'integration',
      resourceId: id,
      severity: 'HIGH',
      metadata: { name: existing.name }
    });

    return true;
  }

  /**
   * Removes webhook secret from integration object.
   */
  private sanitize(integration: any) {
    const { webhookSecret, ...rest } = integration;
    return {
      ...rest,
      // Show first 8 chars of secret for identification
      secretPrefix: webhookSecret.substring(0, 8) + '...'
    };
  }
}

export const integrationService = new IntegrationService();
```
  </action>
  <verify>File exists at src/services/integration.service.ts with integrationService export</verify>
  <done>Integration service created with CRUD operations, secure secret generation, type-specific defaults, and secret rotation</done>
</task>

<task type="auto">
  <name>Task 2: Create integration routes</name>
  <files>src/routes/integration.routes.ts</files>
  <action>
Create REST API routes for integration management.

Key implementation details:
1. All routes require platform admin (per API key pattern from Phase 1)
2. POST returns webhook secret once (must be saved immediately)
3. GET list/single never expose full secret
4. PUT/PATCH for updates
5. POST /rotate-secret for secret rotation
6. DELETE for removal

```typescript
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import { integrationService } from '../services/integration.service.js';
import { requireAuth, requirePlatformAdmin } from '../middleware/auth.js';
import { formatValidationError, createProblemDetails } from '../utils/problem-details.js';

export const integrationRouter = Router();

// All integration routes require platform admin
integrationRouter.use(requireAuth);
integrationRouter.use(requirePlatformAdmin);

// Validation schemas
const createIntegrationSchema = z.object({
  name: z.string().min(1).max(100).regex(/^[a-z0-9-]+$/, 'Name must be lowercase alphanumeric with dashes'),
  type: z.enum(['datadog', 'newrelic', 'pagerduty', 'generic']),
  signatureHeader: z.string().max(100).optional(),
  signatureAlgorithm: z.enum(['sha256', 'sha512']).optional(),
  signatureFormat: z.enum(['hex', 'base64']).optional(),
  signaturePrefix: z.string().max(50).optional(),
  deduplicationWindowMinutes: z.number().int().min(1).max(1440).optional()
});

const updateIntegrationSchema = z.object({
  name: z.string().min(1).max(100).regex(/^[a-z0-9-]+$/).optional(),
  signatureHeader: z.string().max(100).optional(),
  signatureAlgorithm: z.enum(['sha256', 'sha512']).optional(),
  signatureFormat: z.enum(['hex', 'base64']).optional(),
  signaturePrefix: z.string().max(50).optional(),
  deduplicationWindowMinutes: z.number().int().min(1).max(1440).optional(),
  isActive: z.boolean().optional()
});

/**
 * POST /api/integrations
 * Creates a new integration. Returns webhook secret ONCE.
 */
integrationRouter.post('/', async (req: Request, res: Response): Promise<void> => {
  const result = createIntegrationSchema.safeParse(req.body);

  if (!result.success) {
    res.status(400).json(formatValidationError(result.error, req.path));
    return;
  }

  try {
    const integration = await integrationService.create(result.data, req.user!.id);

    res.status(201).json({
      ...integration,
      webhook_url: `/webhooks/alerts/${integration.name}`,
      warning: 'Save the webhookSecret now - it cannot be retrieved again'
    });
  } catch (error: any) {
    if (error.code === 'P2002') {
      res.status(409).json(createProblemDetails(
        'duplicate-integration',
        'Integration name already exists',
        409,
        { detail: 'Choose a different integration name' }
      ));
      return;
    }
    throw error;
  }
});

/**
 * GET /api/integrations
 * Lists all integrations (secrets redacted).
 */
integrationRouter.get('/', async (_req: Request, res: Response): Promise<void> => {
  const integrations = await integrationService.list();
  res.json({ integrations });
});

/**
 * GET /api/integrations/:id
 * Gets a single integration (secret redacted).
 */
integrationRouter.get('/:id', async (req: Request, res: Response): Promise<void> => {
  const integration = await integrationService.getById(req.params.id);

  if (!integration) {
    res.status(404).json(createProblemDetails(
      'integration-not-found',
      'Integration not found',
      404
    ));
    return;
  }

  res.json(integration);
});

/**
 * PATCH /api/integrations/:id
 * Updates integration configuration.
 */
integrationRouter.patch('/:id', async (req: Request, res: Response): Promise<void> => {
  const result = updateIntegrationSchema.safeParse(req.body);

  if (!result.success) {
    res.status(400).json(formatValidationError(result.error, req.path));
    return;
  }

  try {
    const integration = await integrationService.update(
      req.params.id,
      result.data,
      req.user!.id
    );

    if (!integration) {
      res.status(404).json(createProblemDetails(
        'integration-not-found',
        'Integration not found',
        404
      ));
      return;
    }

    res.json(integration);
  } catch (error: any) {
    if (error.code === 'P2002') {
      res.status(409).json(createProblemDetails(
        'duplicate-integration',
        'Integration name already exists',
        409
      ));
      return;
    }
    throw error;
  }
});

/**
 * POST /api/integrations/:id/rotate-secret
 * Rotates webhook secret. Returns new secret ONCE.
 */
integrationRouter.post('/:id/rotate-secret', async (req: Request, res: Response): Promise<void> => {
  const result = await integrationService.rotateSecret(req.params.id, req.user!.id);

  if (!result) {
    res.status(404).json(createProblemDetails(
      'integration-not-found',
      'Integration not found',
      404
    ));
    return;
  }

  res.json({
    ...result,
    warning: 'Save the new webhookSecret now - it cannot be retrieved again'
  });
});

/**
 * DELETE /api/integrations/:id
 * Deletes an integration.
 */
integrationRouter.delete('/:id', async (req: Request, res: Response): Promise<void> => {
  const deleted = await integrationService.delete(req.params.id, req.user!.id);

  if (!deleted) {
    res.status(404).json(createProblemDetails(
      'integration-not-found',
      'Integration not found',
      404
    ));
    return;
  }

  res.status(204).send();
});
```
  </action>
  <verify>File exists at src/routes/integration.routes.ts with integrationRouter export</verify>
  <done>Integration routes created with full CRUD, validation, secret rotation, and platform admin authorization</done>
</task>

<task type="auto">
  <name>Task 3: Mount integration routes in app</name>
  <files>src/index.ts</files>
  <action>
Add integration routes to the Express application.

Add import at top with other route imports:
```typescript
import { integrationRouter } from './routes/integration.routes.js';
```

Add route mounting after existing API routes (around line 94):
```typescript
app.use('/api/integrations', integrationRouter);
```

This follows the established pattern for authenticated API routes in the project.
  </action>
  <verify>src/index.ts contains import for integrationRouter and app.use statement</verify>
  <done>Integration routes mounted at /api/integrations</done>
</task>

</tasks>

<verification>
- All files exist in expected locations
- `npm run build` succeeds (TypeScript compiles)
- `npm test` passes (no regressions)
- Routes accessible at /api/integrations (require auth)
</verification>

<success_criteria>
- Integration CRUD operations work (create, list, get, update, delete)
- Webhook secrets generated securely (32 bytes, hex encoded)
- Secrets only returned on create and rotate (never on list/get)
- Type-specific defaults applied (DataDog, New Relic, etc.)
- All operations require platform admin role
- All operations logged to audit trail
- Secret rotation generates new secret and logs
</success_criteria>

<output>
After completion, create `.planning/phases/02-alert-ingestion-webhooks/02-05-SUMMARY.md`
</output>

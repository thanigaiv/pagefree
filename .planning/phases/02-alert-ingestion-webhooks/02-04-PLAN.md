---
phase: 02-alert-ingestion-webhooks
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/webhooks/schemas/alert.schema.ts
  - src/utils/problem-details.ts
autonomous: true

must_haves:
  truths:
    - "Alert schema validates required fields (title, severity, timestamp)"
    - "Schema allows unknown fields (passthrough mode)"
    - "Timestamps coerced to Date objects (ISO-8601 or Unix)"
    - "Severity normalized to uppercase enum values"
    - "Error responses use RFC 7807 Problem Details format"
  artifacts:
    - path: "src/webhooks/schemas/alert.schema.ts"
      provides: "Zod schemas for alert webhook validation"
      exports: ["alertWebhookSchema", "normalizeAlertPayload"]
    - path: "src/utils/problem-details.ts"
      provides: "RFC 7807 Problem Details formatter"
      exports: ["ProblemDetails", "formatValidationError", "createProblemDetails"]
  key_links:
    - from: "src/webhooks/schemas/alert.schema.ts"
      to: "zod"
      via: "import z from zod"
      pattern: "import.*z.*from.*zod"
---

<objective>
Create flexible Zod schemas for alert webhook validation and RFC 7807 Problem Details error formatting.

Purpose: Validate webhook payloads while being flexible enough to handle different monitoring tools. Strict on required fields (title, severity, timestamp), permissive on extras. Standard error format helps integrators debug issues.

Output: Reusable validation schemas and error formatting utilities.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-alert-ingestion-webhooks/02-RESEARCH.md (Pattern 5, Schema validation, RFC 7807)
@prisma/schema.prisma (AlertSeverity enum)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RFC 7807 Problem Details utility</name>
  <files>src/utils/problem-details.ts</files>
  <action>
Create utilities for generating RFC 7807 Problem Details error responses.

Key implementation details:
1. Define ProblemDetails interface matching RFC 7807
2. Create factory function for common error types
3. Create formatter for Zod validation errors
4. Include field-level validation details in extension fields

```typescript
import { ZodError, ZodIssue } from 'zod';

/**
 * RFC 7807 Problem Details interface.
 * https://www.rfc-editor.org/rfc/rfc7807
 */
export interface ProblemDetails {
  type: string;         // URI identifying error type
  title: string;        // Human-readable summary
  status: number;       // HTTP status code
  detail?: string;      // Specific explanation
  instance?: string;    // URI identifying this occurrence
  // Extension fields
  [key: string]: any;
}

export interface ValidationError {
  field: string;
  code: string;
  message: string;
  received?: any;
}

const BASE_TYPE_URI = 'https://api.oncall.com/errors';

/**
 * Creates a Problem Details response.
 */
export function createProblemDetails(
  type: string,
  title: string,
  status: number,
  options: {
    detail?: string;
    instance?: string;
    extensions?: Record<string, any>;
  } = {}
): ProblemDetails {
  const problem: ProblemDetails = {
    type: `${BASE_TYPE_URI}/${type}`,
    title,
    status
  };

  if (options.detail) problem.detail = options.detail;
  if (options.instance) problem.instance = options.instance;

  // Add extension fields
  if (options.extensions) {
    Object.assign(problem, options.extensions);
  }

  return problem;
}

/**
 * Formats a Zod validation error into Problem Details.
 */
export function formatValidationError(
  error: ZodError,
  instance?: string
): ProblemDetails {
  const validationErrors: ValidationError[] = error.issues.map(formatZodIssue);

  return createProblemDetails(
    'validation-failed',
    'Webhook payload validation failed',
    400,
    {
      detail: 'One or more required fields are missing or invalid',
      instance,
      extensions: {
        validation_errors: validationErrors
      }
    }
  );
}

/**
 * Formats a single Zod issue into a validation error.
 */
function formatZodIssue(issue: ZodIssue): ValidationError {
  const error: ValidationError = {
    field: issue.path.join('.') || '(root)',
    code: issue.code,
    message: issue.message
  };

  // Include received value for type errors (helpful for debugging)
  if ('received' in issue && issue.received !== undefined) {
    error.received = issue.received;
  }

  return error;
}

// Pre-defined error factories for common webhook errors

export const webhookErrors = {
  missingSignature: (header: string, instance?: string) =>
    createProblemDetails('missing-signature', 'Missing signature header', 401, {
      detail: `${header} header is required`,
      instance
    }),

  invalidSignature: (instance?: string) =>
    createProblemDetails('invalid-signature', 'Invalid signature', 401, {
      detail: 'Webhook signature verification failed',
      instance
    }),

  integrationNotFound: (instance?: string) =>
    createProblemDetails('integration-not-found', 'Integration not found', 404, {
      detail: 'The specified integration does not exist or is inactive',
      instance
    }),

  processingFailed: (instance?: string) =>
    createProblemDetails('processing-failed', 'Internal processing error', 500, {
      detail: 'An unexpected error occurred while processing the webhook',
      instance
    }),

  rateLimited: (retryAfter: number, instance?: string) =>
    createProblemDetails('rate-limited', 'Rate limit exceeded', 429, {
      detail: `Too many requests. Please retry after ${retryAfter} seconds.`,
      instance,
      extensions: {
        retry_after: retryAfter
      }
    })
};
```
  </action>
  <verify>File exists at src/utils/problem-details.ts with ProblemDetails, formatValidationError, createProblemDetails, webhookErrors exports</verify>
  <done>RFC 7807 Problem Details utility created with validation error formatting and common error factories</done>
</task>

<task type="auto">
  <name>Task 2: Create alert webhook Zod schema</name>
  <files>src/webhooks/schemas/alert.schema.ts</files>
  <action>
Create Zod schemas for validating and normalizing alert webhook payloads.

Key implementation details:
1. Required fields: title, severity, timestamp
2. Optional fields: description, source, external_id, metadata
3. Use passthrough() to allow unknown fields (stored in raw payload)
4. Coerce timestamps from ISO-8601 strings or Unix timestamps
5. Normalize severity to uppercase enum values
6. Provide normalization function for creating Alert records

```typescript
import { z } from 'zod';
import { AlertSeverity } from '@prisma/client';

/**
 * Coerces various timestamp formats to Date.
 * Handles ISO-8601 strings and Unix timestamps (seconds or milliseconds).
 */
const timestampSchema = z.union([
  z.string().datetime(),           // ISO-8601 with timezone
  z.string().regex(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/), // ISO without timezone
  z.number()                       // Unix timestamp
]).transform((val): Date => {
  if (typeof val === 'number') {
    // Determine if seconds or milliseconds (timestamps after 2001 in ms are > 1e12)
    const ms = val > 1e11 ? val : val * 1000;
    return new Date(ms);
  }
  return new Date(val);
});

/**
 * Normalizes severity strings to AlertSeverity enum values.
 * Case-insensitive, maps common aliases.
 */
const severitySchema = z.string().transform((val): AlertSeverity => {
  const normalized = val.toUpperCase().trim();

  // Map common aliases
  const aliases: Record<string, AlertSeverity> = {
    'CRITICAL': AlertSeverity.CRITICAL,
    'EMERGENCY': AlertSeverity.CRITICAL,
    'P1': AlertSeverity.CRITICAL,
    'SEV1': AlertSeverity.CRITICAL,
    'HIGH': AlertSeverity.HIGH,
    'ERROR': AlertSeverity.HIGH,
    'P2': AlertSeverity.HIGH,
    'SEV2': AlertSeverity.HIGH,
    'MEDIUM': AlertSeverity.MEDIUM,
    'WARNING': AlertSeverity.MEDIUM,
    'WARN': AlertSeverity.MEDIUM,
    'P3': AlertSeverity.MEDIUM,
    'SEV3': AlertSeverity.MEDIUM,
    'LOW': AlertSeverity.LOW,
    'NOTICE': AlertSeverity.LOW,
    'P4': AlertSeverity.LOW,
    'SEV4': AlertSeverity.LOW,
    'INFO': AlertSeverity.INFO,
    'INFORMATIONAL': AlertSeverity.INFO,
    'DEBUG': AlertSeverity.INFO,
    'P5': AlertSeverity.INFO,
    'SEV5': AlertSeverity.INFO
  };

  const mapped = aliases[normalized];
  if (!mapped) {
    // Default to MEDIUM for unknown severities (lenient parsing)
    return AlertSeverity.MEDIUM;
  }

  return mapped;
});

/**
 * Base alert webhook schema with required fields.
 * Uses passthrough() to allow unknown fields.
 */
export const alertWebhookSchema = z.object({
  // Required fields
  title: z.string().min(1, 'Title is required').max(500),
  severity: severitySchema,
  timestamp: timestampSchema,

  // Optional but extracted fields
  description: z.string().max(5000).optional().nullable(),
  source: z.string().max(200).optional().nullable(),
  external_id: z.string().max(200).optional().nullable(),
  // Also accept camelCase variants
  externalId: z.string().max(200).optional().nullable(),

  // Flexible metadata
  metadata: z.record(z.any()).optional().nullable(),

  // Common alternate field names (mapped during normalization)
  message: z.string().max(5000).optional().nullable(),  // -> description
  body: z.string().max(5000).optional().nullable(),     // -> description
  alert_id: z.string().max(200).optional().nullable(), // -> external_id
  id: z.string().max(200).optional().nullable(),       // -> external_id
  triggered_at: timestampSchema.optional().nullable(), // -> timestamp
  triggeredAt: timestampSchema.optional().nullable(),  // -> timestamp
  event_time: timestampSchema.optional().nullable(),   // -> timestamp
  eventTime: timestampSchema.optional().nullable(),    // -> timestamp

}).passthrough();  // Allow unknown fields

export type AlertWebhookInput = z.input<typeof alertWebhookSchema>;
export type AlertWebhookParsed = z.output<typeof alertWebhookSchema>;

/**
 * Normalized alert data ready for database insertion.
 */
export interface NormalizedAlert {
  title: string;
  description: string | null;
  severity: AlertSeverity;
  triggeredAt: Date;
  source: string | null;
  externalId: string | null;
  metadata: Record<string, any>;
}

/**
 * Normalizes parsed webhook payload to Alert model fields.
 * Handles field name variations and provides defaults.
 */
export function normalizeAlertPayload(
  parsed: AlertWebhookParsed,
  integrationName: string
): NormalizedAlert {
  return {
    title: parsed.title,

    // Prefer description, fall back to message/body
    description: parsed.description || parsed.message || parsed.body || null,

    severity: parsed.severity,

    // Prefer timestamp, fall back to triggered_at variants
    triggeredAt: parsed.timestamp ||
                 parsed.triggered_at ||
                 parsed.triggeredAt ||
                 parsed.event_time ||
                 parsed.eventTime ||
                 new Date(),

    // Source defaults to integration name
    source: parsed.source || integrationName,

    // Prefer external_id, fall back to externalId, alert_id, id
    externalId: parsed.external_id ||
                parsed.externalId ||
                parsed.alert_id ||
                parsed.id ||
                null,

    // Preserve any extra fields in metadata
    metadata: parsed.metadata || {}
  };
}

/**
 * Validates payload and returns result with normalized data or error.
 */
export function validateAlertPayload(
  payload: unknown,
  integrationName: string
): { success: true; data: NormalizedAlert } | { success: false; error: z.ZodError } {
  const result = alertWebhookSchema.safeParse(payload);

  if (!result.success) {
    return { success: false, error: result.error };
  }

  return {
    success: true,
    data: normalizeAlertPayload(result.data, integrationName)
  };
}
```

Note: The schema is intentionally lenient - it maps common field name variations (snake_case/camelCase, aliases like "message"/"description") to support different monitoring tool formats without custom per-tool schemas.
  </action>
  <verify>File exists at src/webhooks/schemas/alert.schema.ts with alertWebhookSchema, normalizeAlertPayload, validateAlertPayload exports. TypeScript compiles.</verify>
  <done>Alert webhook schema created with timestamp coercion, severity normalization, field name mapping, and passthrough for unknown fields</done>
</task>

</tasks>

<verification>
- All files exist in expected locations
- `npm run build` succeeds (TypeScript compiles)
- `npm test` passes (no regressions)
- Exports: ProblemDetails, formatValidationError, alertWebhookSchema, normalizeAlertPayload, validateAlertPayload
</verification>

<success_criteria>
- Required fields validated: title (non-empty), severity (mapped to enum), timestamp (coerced to Date)
- Unknown fields passed through (not rejected)
- Timestamps handle ISO-8601 and Unix (seconds/milliseconds)
- Severity aliases mapped (P1->CRITICAL, WARNING->MEDIUM, etc.)
- RFC 7807 errors include field-level validation_errors array
- Normalization handles common field name variations
</success_criteria>

<output>
After completion, create `.planning/phases/02-alert-ingestion-webhooks/02-04-SUMMARY.md`
</output>

---
phase: 02-alert-ingestion-webhooks
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/webhooks/middleware/raw-body-capture.ts
  - src/webhooks/middleware/signature-verification.ts
  - src/utils/hmac-verifier.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Raw request body captured before JSON parsing for signature verification"
    - "Signature verification uses timing-safe comparison (crypto.timingSafeEqual)"
    - "Signature middleware is factory-based (configurable per integration)"
    - "Invalid signatures return 401 with audit log entry"
  artifacts:
    - path: "src/webhooks/middleware/raw-body-capture.ts"
      provides: "Express middleware to capture raw body"
      exports: ["rawBodyCapture"]
    - path: "src/webhooks/middleware/signature-verification.ts"
      provides: "Factory for per-integration signature verification"
      exports: ["createSignatureVerifier"]
    - path: "src/utils/hmac-verifier.ts"
      provides: "HMAC verification utility"
      exports: ["verifyHmacSignature"]
  key_links:
    - from: "src/webhooks/middleware/signature-verification.ts"
      to: "src/utils/hmac-verifier.ts"
      via: "import verifyHmacSignature"
      pattern: "import.*verifyHmacSignature.*hmac-verifier"
    - from: "src/webhooks/middleware/signature-verification.ts"
      to: "src/services/audit.service.ts"
      via: "import auditService for logging failures"
      pattern: "import.*auditService"
---

<objective>
Implement raw body capture middleware and generic signature verification for webhook security.

Purpose: Enable HMAC signature verification for all alert webhooks - raw body must be captured before JSON parsing (parsing normalizes whitespace/order), and signature verification must use timing-safe comparison to prevent timing attacks.

Output: Reusable middleware for webhook endpoints with configurable signature validation.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-alert-ingestion-webhooks/02-RESEARCH.md (Pattern 1, Pattern 2, Code Examples)
@src/webhooks/okta.ts (existing HMAC pattern)
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create raw body capture middleware</name>
  <files>src/webhooks/middleware/raw-body-capture.ts</files>
  <action>
Create a new middleware that captures raw request body before JSON parsing.

Key implementation details:
1. Use express.json with `verify` callback to capture raw buffer
2. Store raw body as string on `req.rawBody` property
3. Set body limit to 1MB (reasonable for monitoring tool payloads)
4. Handle encoding properly (default utf8)

```typescript
import { Router } from 'express';
import express from 'express';

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      rawBody?: string;
    }
  }
}

/**
 * Creates middleware that captures raw request body before JSON parsing.
 * Required for HMAC signature verification (parsing normalizes whitespace/order).
 *
 * @param limit - Body size limit (default: 1mb)
 * @returns Express middleware
 */
export function rawBodyCapture(limit: string = '1mb') {
  return express.json({
    limit,
    verify: (req: any, _res, buf, encoding) => {
      req.rawBody = buf.toString((encoding as BufferEncoding) || 'utf8');
    }
  });
}
```

Note: This middleware replaces express.json() for webhook routes - it both parses JSON AND captures raw body.
  </action>
  <verify>File exists at src/webhooks/middleware/raw-body-capture.ts with rawBodyCapture export</verify>
  <done>rawBodyCapture middleware created with verify callback that stores raw body on request</done>
</task>

<task type="auto">
  <name>Task 2: Create HMAC verification utility</name>
  <files>src/utils/hmac-verifier.ts</files>
  <action>
Create a utility for timing-safe HMAC signature verification.

Key implementation details:
1. Use crypto.createHmac with configurable algorithm (sha256 default)
2. Use crypto.timingSafeEqual for constant-time comparison
3. Handle signature prefixes (e.g., "sha256=")
4. Support both hex and base64 signature formats
5. Return boolean (no exceptions for invalid signatures)

```typescript
import crypto from 'crypto';

export interface HmacVerifyOptions {
  algorithm?: 'sha256' | 'sha512';
  format?: 'hex' | 'base64';
  prefix?: string;  // e.g., "sha256="
}

/**
 * Verifies HMAC signature using timing-safe comparison.
 *
 * @param payload - Raw request body (string)
 * @param signature - Signature from header
 * @param secret - Webhook secret
 * @param options - Algorithm, format, and prefix configuration
 * @returns true if signature is valid
 */
export function verifyHmacSignature(
  payload: string,
  signature: string,
  secret: string,
  options: HmacVerifyOptions = {}
): boolean {
  const {
    algorithm = 'sha256',
    format = 'hex',
    prefix = ''
  } = options;

  // Compute expected signature
  const hmac = crypto.createHmac(algorithm, secret);
  hmac.update(payload);
  const expectedSignature = hmac.digest(format);

  // Remove prefix if present (e.g., "sha256=abc123" -> "abc123")
  const receivedSignature = prefix && signature.startsWith(prefix)
    ? signature.slice(prefix.length)
    : signature;

  try {
    // Use timing-safe comparison to prevent timing attacks
    return crypto.timingSafeEqual(
      Buffer.from(receivedSignature, format === 'base64' ? 'base64' : 'hex'),
      Buffer.from(expectedSignature, format === 'base64' ? 'base64' : 'hex')
    );
  } catch {
    // timingSafeEqual throws if buffers have different lengths
    // This happens with malformed signatures - return false, don't throw
    return false;
  }
}
```
  </action>
  <verify>File exists at src/utils/hmac-verifier.ts with verifyHmacSignature export. TypeScript compiles without errors.</verify>
  <done>verifyHmacSignature utility created with timing-safe comparison, configurable algorithm/format/prefix</done>
</task>

<task type="auto">
  <name>Task 3: Create signature verification middleware factory</name>
  <files>src/webhooks/middleware/signature-verification.ts</files>
  <action>
Create a factory function that returns signature verification middleware for a specific integration.

Key implementation details:
1. Load integration config from database by integration name/ID
2. Extract signature from configured header
3. Call verifyHmacSignature with integration's secret and options
4. Return RFC 7807 Problem Details on failure (401 status)
5. Log signature failures to audit service with HIGH severity
6. Call next() on success

```typescript
import { Request, Response, NextFunction } from 'express';
import { prisma } from '../../config/database.js';
import { verifyHmacSignature } from '../../utils/hmac-verifier.js';
import { auditService } from '../../services/audit.service.js';

export interface SignatureVerifierOptions {
  integrationId?: string;      // Lookup by ID
  integrationName?: string;    // Lookup by name
}

/**
 * Creates middleware that verifies webhook signature for a specific integration.
 * Requires rawBodyCapture middleware to run first.
 *
 * @param options - Integration identifier (id or name)
 * @returns Express middleware
 */
export function createSignatureVerifier(options: SignatureVerifierOptions) {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    // Ensure rawBody was captured
    if (!req.rawBody) {
      res.status(500).json({
        type: 'https://api.oncall.com/errors/configuration-error',
        title: 'Raw body not captured',
        status: 500,
        detail: 'rawBodyCapture middleware must run before signature verification'
      });
      return;
    }

    // Load integration config
    const integration = await prisma.integration.findFirst({
      where: options.integrationId
        ? { id: options.integrationId, isActive: true }
        : { name: options.integrationName, isActive: true }
    });

    if (!integration) {
      res.status(404).json({
        type: 'https://api.oncall.com/errors/integration-not-found',
        title: 'Integration not found',
        status: 404,
        detail: 'The specified integration does not exist or is inactive'
      });
      return;
    }

    // Extract signature from configured header
    const signatureHeader = integration.signatureHeader.toLowerCase();
    const signature = req.headers[signatureHeader] as string;

    if (!signature) {
      await auditService.log({
        action: 'webhook.signature_missing',
        severity: 'HIGH',
        metadata: {
          integration: integration.name,
          expectedHeader: integration.signatureHeader,
          path: req.path
        }
      });

      res.status(401).json({
        type: 'https://api.oncall.com/errors/missing-signature',
        title: 'Missing signature header',
        status: 401,
        detail: `${integration.signatureHeader} header is required`,
        instance: req.path
      });
      return;
    }

    // Verify signature
    const isValid = verifyHmacSignature(
      req.rawBody,
      signature,
      integration.webhookSecret,
      {
        algorithm: integration.signatureAlgorithm as 'sha256' | 'sha512',
        format: integration.signatureFormat as 'hex' | 'base64',
        prefix: integration.signaturePrefix || undefined
      }
    );

    if (!isValid) {
      await auditService.log({
        action: 'webhook.signature_invalid',
        severity: 'HIGH',
        metadata: {
          integration: integration.name,
          path: req.path,
          // Don't log the actual signature (security)
        }
      });

      res.status(401).json({
        type: 'https://api.oncall.com/errors/invalid-signature',
        title: 'Invalid signature',
        status: 401,
        detail: 'Webhook signature verification failed',
        instance: req.path
      });
      return;
    }

    // Attach integration to request for downstream handlers
    (req as any).integration = integration;
    next();
  };
}

/**
 * Creates middleware that verifies signature using integration name from URL param.
 * Use this for routes like /webhooks/:integrationName
 */
export function createDynamicSignatureVerifier() {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const integrationName = req.params.integrationName || req.params.integration;

    if (!integrationName) {
      res.status(400).json({
        type: 'https://api.oncall.com/errors/missing-integration',
        title: 'Missing integration parameter',
        status: 400,
        detail: 'Integration name must be provided in URL'
      });
      return;
    }

    // Delegate to the standard verifier
    const verifier = createSignatureVerifier({ integrationName });
    return verifier(req, res, next);
  };
}
```

Note: The middleware attaches the Integration object to `req.integration` for use by downstream handlers (avoids duplicate database lookup).
  </action>
  <verify>File exists at src/webhooks/middleware/signature-verification.ts with createSignatureVerifier and createDynamicSignatureVerifier exports</verify>
  <done>Signature verification middleware factory created with RFC 7807 errors, audit logging, and integration attachment to request</done>
</task>

</tasks>

<verification>
- All files exist in expected locations
- `npm run build` succeeds (TypeScript compiles)
- `npm test` passes (no regressions)
- Exports are correct: rawBodyCapture, verifyHmacSignature, createSignatureVerifier, createDynamicSignatureVerifier
</verification>

<success_criteria>
- Raw body captured before JSON parsing via verify callback
- HMAC verification uses crypto.timingSafeEqual (timing-safe)
- Signature middleware supports configurable header, algorithm, format, prefix
- Invalid signatures return 401 with RFC 7807 Problem Details
- Signature failures logged to audit service with HIGH severity
- Integration object attached to request for downstream use
</success_criteria>

<output>
After completion, create `.planning/phases/02-alert-ingestion-webhooks/02-02-SUMMARY.md`
</output>

---
phase: 07-external-integrations
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/integration.service.ts
  - src/routes/integration.routes.ts
  - src/queues/test-resolve.queue.ts
  - src/workers/test-resolve.worker.ts
  - src/workers/index.ts
autonomous: true

must_haves:
  truths:
    - "Admin can test webhook integration and see validation results"
    - "Test alerts auto-resolve after 5 minutes"
    - "Admin can view recent webhook delivery attempts"
    - "Integration health stats show last webhook time and error count"
  artifacts:
    - path: "src/queues/test-resolve.queue.ts"
      provides: "Auto-resolve job scheduling"
      exports: ["testResolveQueue", "scheduleAutoResolve"]
    - path: "src/workers/test-resolve.worker.ts"
      provides: "Auto-resolve worker"
      exports: ["testResolveWorker"]
    - path: "src/routes/integration.routes.ts"
      provides: "Test and deliveries endpoints"
      contains: "POST.*:id/test"
  key_links:
    - from: "src/services/integration.service.ts"
      to: "src/queues/test-resolve.queue.ts"
      via: "scheduleAutoResolve()"
      pattern: "scheduleAutoResolve"
    - from: "src/routes/integration.routes.ts"
      to: "src/services/integration.service.ts"
      via: "testWebhook()"
      pattern: "integrationService\\.testWebhook"
---

<objective>
Add test webhook functionality, webhook delivery logs endpoint, and integration health statistics.

Purpose: Enable admins to verify integrations work correctly before receiving real alerts, view recent webhook attempts for debugging, and monitor integration health.

Output: POST /integrations/:id/test endpoint with auto-resolve scheduling, GET /integrations/:id/deliveries endpoint, enhanced list/getById with health stats.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-CONTEXT.md
@.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-RESEARCH.md

# Existing patterns
@src/services/integration.service.ts
@src/routes/integration.routes.ts
@src/queues/escalation.queue.ts
@src/workers/escalation.worker.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auto-resolve queue and worker</name>
  <files>src/queues/test-resolve.queue.ts, src/workers/test-resolve.worker.ts, src/workers/index.ts</files>
  <action>
1. Create src/queues/test-resolve.queue.ts following escalation.queue.ts pattern:

```typescript
import { Queue } from 'bullmq';
import { getRedisConnectionOptions } from '../config/redis.js';
import { logger } from '../config/logger.js';

export interface TestResolveJobData {
  incidentId: string;
  reason: string;
}

export const testResolveQueue = new Queue<TestResolveJobData>('test-resolve', {
  connection: getRedisConnectionOptions(),
  defaultJobOptions: {
    removeOnComplete: true,
    removeOnFail: true, // Test jobs can be cleaned up
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 5000
    }
  }
});

export async function scheduleAutoResolve(
  incidentId: string,
  delayMs: number = 5 * 60 * 1000 // 5 minutes default
): Promise<string> {
  const jobId = `auto-resolve:${incidentId}`;

  await testResolveQueue.add(
    'auto-resolve',
    {
      incidentId,
      reason: 'Test alert auto-resolved after 5 minutes'
    },
    {
      jobId,
      delay: delayMs
    }
  );

  logger.info({ incidentId, delayMs, jobId }, 'Scheduled auto-resolve job');
  return jobId;
}
```

2. Create src/workers/test-resolve.worker.ts:

```typescript
import { Worker, Job } from 'bullmq';
import { getRedisConnectionOptions } from '../config/redis.js';
import { logger } from '../config/logger.js';
import { incidentService } from '../services/incident.service.js';
import type { TestResolveJobData } from '../queues/test-resolve.queue.js';

export const testResolveWorker = new Worker<TestResolveJobData>(
  'test-resolve',
  async (job: Job<TestResolveJobData>) => {
    const { incidentId, reason } = job.data;

    logger.info({ incidentId, jobId: job.id }, 'Processing auto-resolve job');

    // Get incident - it might have been manually resolved already
    const incident = await incidentService.getById(incidentId);

    if (!incident) {
      logger.warn({ incidentId }, 'Incident not found for auto-resolve');
      return;
    }

    // Only resolve if still OPEN or ACKNOWLEDGED
    if (incident.status === 'RESOLVED' || incident.status === 'CLOSED') {
      logger.info({ incidentId, status: incident.status }, 'Incident already resolved/closed');
      return;
    }

    // Resolve using system user ID
    await incidentService.resolve(
      incidentId,
      'system', // System user for auto-resolve
      { resolutionNote: reason }
    );

    logger.info({ incidentId }, 'Test incident auto-resolved');
  },
  {
    connection: getRedisConnectionOptions(),
    concurrency: 5
  }
);

testResolveWorker.on('failed', (job, err) => {
  logger.error({ jobId: job?.id, error: err }, 'Test resolve job failed');
});
```

3. Update src/workers/index.ts to export new worker:

```typescript
export { escalationWorker } from './escalation.worker.js';
export { notificationWorker } from './notification.worker.js';
export { testResolveWorker } from './test-resolve.worker.js';
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/queues/test-resolve.queue.ts src/workers/test-resolve.worker.ts`
  </verify>
  <done>
Auto-resolve queue and worker exist. Test alerts can be scheduled for automatic resolution after 5 minutes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test webhook and deliveries methods to integration service</name>
  <files>src/services/integration.service.ts</files>
  <action>
Extend IntegrationService with three new methods:

1. `testWebhook(integrationId: string, userId: string)` - Generate mock payload, process through pipeline, schedule auto-resolve:

```typescript
import { scheduleAutoResolve } from '../queues/test-resolve.queue.js';
import { alertService } from './alert.service.js';
import { deduplicationService } from './deduplication.service.js';
import { generateContentFingerprint } from '../utils/content-fingerprint.js';

async testWebhook(integrationId: string, userId: string) {
  const integration = await prisma.integration.findUnique({
    where: { id: integrationId }
  });

  if (!integration) throw new Error('Integration not found');

  // Generate mock payload based on type
  const mockPayload = this.generateMockPayload(integration.type);

  // Create alert with test flag
  const fingerprint = `test-${Date.now()}-${Math.random().toString(36).slice(2)}`;

  const { alert } = await alertService.createWithDelivery(
    {
      title: mockPayload.title,
      description: mockPayload.description,
      severity: mockPayload.severity,
      triggeredAt: new Date(),
      source: integration.name,
      externalId: `test-${Date.now()}`,
      metadata: {
        ...mockPayload.metadata,
        isTest: true,
        provider: integration.type
      },
      integrationId: integration.id
    },
    {
      idempotencyKey: fingerprint,
      contentFingerprint: fingerprint,
      rawPayload: mockPayload.raw,
      headers: { 'x-test-webhook': 'true' },
      statusCode: 201
    }
  );

  // Create incident from alert (like real pipeline)
  const deduplicationFingerprint = generateContentFingerprint({
    title: alert.title,
    source: alert.source,
    severity: alert.severity,
    service: (alert.metadata as any)?.service || alert.source
  });

  const { incident, isDuplicate } = await deduplicationService.deduplicateAndCreateIncident(
    alert.id,
    deduplicationFingerprint,
    alert,
    integration.deduplicationWindowMinutes
  );

  // Schedule auto-resolve (5 minutes) per user decision
  await scheduleAutoResolve(incident.id, 5 * 60 * 1000);

  await auditService.log({
    action: 'integration.test_webhook',
    userId,
    resourceType: 'integration',
    resourceId: integration.id,
    severity: 'INFO',
    metadata: {
      alertId: alert.id,
      incidentId: incident.id,
      autoResolveIn: '5 minutes'
    }
  });

  return {
    success: true,
    alert: {
      id: alert.id,
      title: alert.title,
      severity: alert.severity
    },
    incident: {
      id: incident.id,
      isDuplicate
    },
    validation: {
      severityMapped: `${mockPayload.inputPriority} -> ${alert.severity}`,
      serviceRouted: (alert.metadata as any)?.service || 'default',
      providerDetected: integration.type
    },
    autoResolveIn: '5 minutes'
  };
}

private generateMockPayload(type: string) {
  if (type === 'datadog') {
    return {
      title: '[DataDog] Test Alert - CPU Usage High',
      description: 'Test alert from DataDog integration. CPU usage exceeded 90% threshold.',
      severity: 'HIGH',
      inputPriority: 'P2',
      metadata: {
        provider: 'datadog',
        service: 'test-service',
        priority: 'P2',
        status: 'alert',
        metric: 'system.cpu.user',
        tags: ['env:test', 'service:test-service', 'team:platform']
      },
      raw: {
        alert_id: `dd-test-${Date.now()}`,
        alert_title: 'Test Alert - CPU Usage High',
        alert_status: 'alert',
        alert_priority: 'P2',
        alert_metric: 'system.cpu.user',
        event_msg: 'Test alert from DataDog integration. CPU usage exceeded 90% threshold.',
        tags: ['env:test', 'service:test-service', 'team:platform'],
        date: Math.floor(Date.now() / 1000)
      }
    };
  }

  if (type === 'newrelic') {
    return {
      title: '[New Relic] Test Alert - Error Rate Elevated',
      description: 'Test alert from New Relic integration. Error rate exceeded 5% threshold.',
      severity: 'HIGH',
      inputPriority: 'HIGH',
      metadata: {
        provider: 'newrelic',
        service: 'test-service',
        state: 'open',
        labels: { service: 'test-service', env: 'test' }
      },
      raw: {
        id: `nr-test-${Date.now()}`,
        title: 'Test Alert - Error Rate Elevated',
        priority: 'HIGH',
        state: 'open',
        message: 'Test alert from New Relic integration. Error rate exceeded 5% threshold.',
        timestamp: new Date().toISOString(),
        labels: { service: 'test-service', env: 'test' }
      }
    };
  }

  // Generic type
  return {
    title: 'Test Alert - Generic Integration',
    description: 'Test alert from generic webhook integration.',
    severity: 'MEDIUM',
    inputPriority: 'MEDIUM',
    metadata: {
      provider: 'generic',
      service: 'test-service'
    },
    raw: {
      title: 'Test Alert - Generic Integration',
      severity: 'MEDIUM',
      timestamp: new Date().toISOString(),
      description: 'Test alert from generic webhook integration.'
    }
  };
}
```

2. `getDeliveries(integrationId: string, limit: number = 10)` - Get recent webhook deliveries:

```typescript
async getDeliveries(integrationId: string, limit: number = 10) {
  const deliveries = await prisma.webhookDelivery.findMany({
    where: { integrationId },
    orderBy: { createdAt: 'desc' },
    take: limit,
    select: {
      id: true,
      statusCode: true,
      errorMessage: true,
      createdAt: true,
      alertId: true
    }
  });

  return deliveries;
}
```

3. Update `list()` and `getById()` to include health stats (lastWebhookAt, errorCount in 24h):

```typescript
// In list() query, add:
const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

const integrations = await prisma.integration.findMany({
  orderBy: { createdAt: 'desc' },
  include: {
    _count: {
      select: { alerts: true, webhookDeliveries: true }
    },
    webhookDeliveries: {
      take: 1,
      orderBy: { createdAt: 'desc' },
      select: { createdAt: true }
    }
  }
});

// Count errors separately (24h window)
const errorCounts = await prisma.webhookDelivery.groupBy({
  by: ['integrationId'],
  where: {
    statusCode: { gte: 400 },
    createdAt: { gte: twentyFourHoursAgo }
  },
  _count: true
});

const errorCountMap = Object.fromEntries(
  errorCounts.map(e => [e.integrationId, e._count])
);

return integrations.map(int => ({
  ...this.sanitize(int),
  alertCount: int._count.alerts,
  webhookCount: int._count.webhookDeliveries,
  lastWebhookAt: int.webhookDeliveries[0]?.createdAt || null,
  errorCount: errorCountMap[int.id] || 0
}));
```

Apply similar health stats pattern to getById().
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/services/integration.service.ts`
  </verify>
  <done>
Integration service has testWebhook(), getDeliveries(), and health stats in list/getById.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add test and deliveries API endpoints</name>
  <files>src/routes/integration.routes.ts</files>
  <action>
Add two new endpoints to integration.routes.ts (admin-only like existing routes):

1. `POST /integrations/:id/test` - Test webhook:

```typescript
// Test webhook (create test alert that auto-resolves)
router.post('/:id/test', async (req, res) => {
  try {
    const result = await integrationService.testWebhook(
      req.params.id,
      req.user!.id
    );

    res.json(result);
  } catch (error) {
    if (error instanceof Error && error.message === 'Integration not found') {
      res.status(404).json({
        type: 'not-found',
        title: 'Integration not found',
        status: 404
      });
      return;
    }

    logger.error({ error, integrationId: req.params.id }, 'Test webhook failed');
    res.status(500).json({
      type: 'internal-error',
      title: 'Test webhook failed',
      status: 500,
      detail: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});
```

2. `GET /integrations/:id/deliveries` - Get webhook delivery logs:

```typescript
// Get recent webhook deliveries for integration
router.get('/:id/deliveries', async (req, res) => {
  const limit = Math.min(parseInt(req.query.limit as string) || 10, 100);

  const deliveries = await integrationService.getDeliveries(
    req.params.id,
    limit
  );

  res.json({ deliveries });
});
```

Both endpoints use the existing `requirePlatformAdmin` middleware already applied to the router.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit src/routes/integration.routes.ts`
2. Start server and test endpoints exist (they'll require auth):
   `curl -X POST http://localhost:3000/api/integrations/test-id/test`
   (expect 401 Unauthorized, confirming endpoint exists)
  </verify>
  <done>
API has POST /integrations/:id/test and GET /integrations/:id/deliveries endpoints.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for all modified files
2. Start server: workers initialize including test-resolve worker
3. Test webhook endpoint returns structured result with validation info
4. Deliveries endpoint returns array of recent webhook attempts
5. Integration list includes lastWebhookAt and errorCount fields
</verification>

<success_criteria>
- Test webhook creates alert and incident with isTest metadata flag
- Test alert is scheduled for auto-resolve after 5 minutes
- Validation results show severity mapping and service routing
- Recent deliveries queryable with limit parameter
- Integration health stats (lastWebhookAt, errorCount) in list and getById
</success_criteria>

<output>
After completion, create `.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-02-SUMMARY.md`
</output>

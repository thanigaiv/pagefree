---
phase: 07-external-integrations
plan: 06
type: execute
wave: 3
depends_on: ["07-04", "07-05"]
files_modified:
  - frontend/src/pages/IntegrationsPage.tsx
  - frontend/src/App.tsx
  - tests/integration/integration-api.test.ts
  - tests/unit/normalizers.test.ts
autonomous: false

must_haves:
  truths:
    - "Admin can access integrations page at /integrations"
    - "Integrations page shows all configured integrations as cards"
    - "Admin can enable/disable integrations from UI"
    - "Admin can test webhook and see validation results"
    - "Admin can view recent webhook attempts"
    - "Non-admins cannot access integrations page"
  artifacts:
    - path: "frontend/src/pages/IntegrationsPage.tsx"
      provides: "Integrations admin page"
      min_lines: 50
    - path: "tests/integration/integration-api.test.ts"
      provides: "API integration tests"
      contains: "test.*webhook"
    - path: "tests/unit/normalizers.test.ts"
      provides: "Normalizer unit tests"
      contains: "normalizeDatadogPayload|normalizeNewRelicPayload"
  key_links:
    - from: "frontend/src/pages/IntegrationsPage.tsx"
      to: "useIntegrations hook"
      via: "React hook"
      pattern: "useIntegrations"
    - from: "frontend/src/App.tsx"
      to: "IntegrationsPage"
      via: "route"
      pattern: "path.*integrations"
---

<objective>
Create IntegrationsPage and add test coverage for the phase.

Purpose: Complete the admin UI for managing integrations and verify all phase functionality with tests.

Output: Integrations admin page with cards, test dialogs, and webhook logs; test files covering normalizers and API.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-CONTEXT.md

# Existing patterns
@frontend/src/pages/ProfilePage.tsx
@frontend/src/App.tsx
@tests/integration/webhook.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IntegrationsPage</name>
  <files>frontend/src/pages/IntegrationsPage.tsx, frontend/src/App.tsx</files>
  <action>
1. Create IntegrationsPage following ProfilePage layout pattern:

```typescript
import { Loader2, Settings, ShieldAlert } from 'lucide-react';
import { useIntegrations, useUpdateIntegration } from '@/hooks/useIntegrations';
import { IntegrationCard } from '@/components/IntegrationCard';
import { IntegrationTestDialog } from '@/components/IntegrationTestDialog';
import { WebhookAttempts } from '@/components/WebhookAttempts';
import { useAuth } from '@/hooks/useAuth'; // Assuming auth hook exists
import { Alert, AlertDescription } from '@/components/ui/alert';

export default function IntegrationsPage() {
  const { data: integrations, isLoading, error } = useIntegrations();
  const updateIntegration = useUpdateIntegration();
  const { user } = useAuth();

  // Check admin access per user decision (platform-level settings admin only)
  if (user?.platformRole !== 'PLATFORM_ADMIN') {
    return (
      <div className="container mx-auto py-6 px-4 max-w-4xl">
        <Alert variant="destructive">
          <ShieldAlert className="h-4 w-4" />
          <AlertDescription>
            Only platform administrators can access integration settings.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto py-6 px-4 max-w-4xl">
        <Alert variant="destructive">
          <AlertDescription>
            Failed to load integrations. Please try again.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-6 px-4 max-w-4xl">
      {/* Header */}
      <div className="mb-6">
        <div className="flex items-center gap-2">
          <Settings className="h-6 w-6" />
          <h1 className="text-2xl font-bold">Integrations</h1>
        </div>
        <p className="text-muted-foreground mt-1">
          Configure external monitoring tool integrations
        </p>
      </div>

      {/* Info about webhook URL */}
      <div className="mb-6 p-4 bg-muted rounded-lg">
        <h3 className="font-medium mb-2">Webhook URL Format</h3>
        <code className="text-sm bg-background px-2 py-1 rounded">
          {window.location.origin}/api/webhooks/alerts/:integrationName
        </code>
        <p className="text-sm text-muted-foreground mt-2">
          Replace <code>:integrationName</code> with the integration name (e.g., "datadog-prod")
        </p>
      </div>

      {/* Integration cards per user decision: status cards with health indicators */}
      <div className="space-y-4">
        {integrations?.length === 0 && (
          <div className="text-center py-12 text-muted-foreground">
            <p>No integrations configured yet.</p>
            <p className="text-sm mt-2">
              Create integrations via API: POST /api/integrations
            </p>
          </div>
        )}

        {integrations?.map((integration) => (
          <IntegrationCard
            key={integration.id}
            integration={integration}
            isUpdating={updateIntegration.isPending}
            onToggle={(enabled) => {
              updateIntegration.mutate({
                id: integration.id,
                data: { isActive: enabled }
              });
            }}
            onTest={() => {
              // Test dialog handles its own state
              // This is handled by IntegrationTestDialog trigger
            }}
            onViewLogs={() => {
              // Logs dialog handles its own state
              // This is handled by WebhookAttempts trigger
            }}
          />
        ))}
      </div>

      {/* Instructions section per user decision */}
      <div className="mt-8 space-y-4">
        <h2 className="text-lg font-semibold">Setup Instructions</h2>

        <div className="grid gap-4 md:grid-cols-2">
          {/* DataDog setup */}
          <div className="p-4 border rounded-lg">
            <h3 className="font-medium mb-2">DataDog</h3>
            <ol className="text-sm text-muted-foreground space-y-2 list-decimal list-inside">
              <li>Go to Monitors &rarr; Manage Monitors</li>
              <li>Select a monitor and click "Edit"</li>
              <li>Scroll to "Notify your team"</li>
              <li>Add webhook URL with @webhook-oncall</li>
              <li>Save and trigger a test alert</li>
            </ol>
          </div>

          {/* New Relic setup */}
          <div className="p-4 border rounded-lg">
            <h3 className="font-medium mb-2">New Relic</h3>
            <ol className="text-sm text-muted-foreground space-y-2 list-decimal list-inside">
              <li>Go to Alerts &rarr; Destinations</li>
              <li>Click "Add a destination"</li>
              <li>Select "Webhook" type</li>
              <li>Enter the webhook URL</li>
              <li>Create a condition and trigger test</li>
            </ol>
          </div>
        </div>
      </div>
    </div>
  );
}
```

Note: The IntegrationCard component needs to be updated to include the test and logs dialogs as children. Update the IntegrationCard usage to wrap with dialogs:

```typescript
{integrations?.map((integration) => (
  <div key={integration.id} className="relative">
    <IntegrationCard
      integration={integration}
      isUpdating={updateIntegration.isPending}
      onToggle={(enabled) => {
        updateIntegration.mutate({
          id: integration.id,
          data: { isActive: enabled }
        });
      }}
      onTest={() => {}}  // Handled by dialog
      onViewLogs={() => {}}  // Handled by dialog
    />
    {/* Render dialogs - they manage their own open state via triggers */}
    <div className="absolute top-4 right-16 flex gap-2">
      <IntegrationTestDialog integration={integration} />
      <WebhookAttempts integration={integration} />
    </div>
  </div>
))}
```

Actually, better approach - modify IntegrationCard to accept optional renderActions prop or integrate dialogs directly. For simplicity, update IntegrationCard to use the dialogs:

Update IntegrationCard.tsx to import and use dialogs internally:

```typescript
// In IntegrationCard, replace the action buttons with:
<div className="flex gap-2 pt-2">
  <IntegrationTestDialog
    integration={integration}
    trigger={
      <Button variant="outline" size="sm" disabled={!integration.isActive}>
        Test Webhook
      </Button>
    }
  />
  <WebhookAttempts
    integration={integration}
    trigger={
      <Button variant="ghost" size="sm">
        View Logs
      </Button>
    }
  />
</div>
```

2. Add route to App.tsx:

```typescript
import IntegrationsPage from '@/pages/IntegrationsPage';

// In routes array, add:
{ path: '/integrations', element: <IntegrationsPage /> }
```
  </action>
  <verify>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. App starts: `cd frontend && npm run dev`
3. Navigate to /integrations (as admin)
  </verify>
  <done>
IntegrationsPage shows all integrations as cards with health indicators, enable toggle, test button, and view logs button. Route registered at /integrations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create normalizer unit tests</name>
  <files>tests/unit/normalizers.test.ts</files>
  <action>
Create unit tests for DataDog and New Relic normalizers.

```typescript
import { describe, it, expect } from 'vitest';
import { normalizeDatadogPayload } from '../../src/webhooks/schemas/datadog.schema.js';
import { normalizeNewRelicPayload } from '../../src/webhooks/schemas/newrelic.schema.js';

describe('DataDog Normalizer', () => {
  it('normalizes basic DataDog payload', () => {
    const payload = {
      alert_id: 'dd-12345',
      alert_title: 'High CPU Usage',
      alert_status: 'alert',
      alert_priority: 'P2',
      alert_metric: 'system.cpu.user',
      org_id: 'org-123',
      org_name: 'Test Org',
      event_msg: 'CPU usage is above 90%',
      date: 1704067200, // 2024-01-01 00:00:00 UTC
      tags: ['service:api', 'env:production']
    };

    const result = normalizeDatadogPayload(payload, 'datadog-prod');

    expect(result.title).toBe('[DataDog] High CPU Usage');
    expect(result.description).toBe('CPU usage is above 90%');
    expect(result.severity).toBe('HIGH'); // P2 -> HIGH
    expect(result.source).toBe('datadog-prod');
    expect(result.externalId).toBe('dd-12345');
    expect(result.metadata.service).toBe('api');
    expect(result.metadata.provider).toBe('datadog');
    expect(result.metadata.tags).toEqual(['service:api', 'env:production']);
  });

  it('maps P1 to CRITICAL severity', () => {
    const payload = {
      alert_id: 'dd-1',
      alert_title: 'Critical Alert',
      alert_priority: 'P1',
      alert_status: 'alert',
      date: Date.now() / 1000
    };

    const result = normalizeDatadogPayload(payload, 'test');
    expect(result.severity).toBe('CRITICAL');
  });

  it('defaults unknown severity to MEDIUM', () => {
    const payload = {
      alert_id: 'dd-1',
      alert_title: 'Unknown Priority',
      alert_priority: 'UNKNOWN',
      alert_status: 'alert',
      date: Date.now() / 1000
    };

    const result = normalizeDatadogPayload(payload, 'test');
    expect(result.severity).toBe('MEDIUM');
  });

  it('extracts service from tags', () => {
    const payload = {
      alert_id: 'dd-1',
      alert_title: 'Test',
      alert_priority: 'P3',
      alert_status: 'alert',
      date: Date.now() / 1000,
      tags: ['env:prod', 'service:payment-api', 'team:payments']
    };

    const result = normalizeDatadogPayload(payload, 'test');
    expect(result.metadata.service).toBe('payment-api');
  });

  it('preserves unknown fields in metadata', () => {
    const payload = {
      alert_id: 'dd-1',
      alert_title: 'Test',
      alert_priority: 'P3',
      alert_status: 'alert',
      date: Date.now() / 1000,
      custom_field: 'custom_value',
      another_field: 123
    };

    const result = normalizeDatadogPayload(payload, 'test');
    expect(result.metadata.raw.custom_field).toBe('custom_value');
    expect(result.metadata.raw.another_field).toBe(123);
  });
});

describe('New Relic Normalizer', () => {
  it('normalizes basic New Relic payload', () => {
    const payload = {
      id: 'nr-67890',
      title: 'Error Rate Spike',
      priority: 'CRITICAL',
      state: 'open',
      message: 'Error rate exceeded 5%',
      timestamp: '2024-01-01T00:00:00Z',
      labels: {
        service: 'checkout',
        env: 'production'
      }
    };

    const result = normalizeNewRelicPayload(payload, 'newrelic-prod');

    expect(result.title).toBe('[New Relic] Error Rate Spike');
    expect(result.description).toBe('Error rate exceeded 5%');
    expect(result.severity).toBe('CRITICAL');
    expect(result.source).toBe('newrelic-prod');
    expect(result.externalId).toBe('nr-67890');
    expect(result.metadata.service).toBe('checkout');
    expect(result.metadata.provider).toBe('newrelic');
  });

  it('maps HIGH severity correctly', () => {
    const payload = {
      id: 'nr-1',
      title: 'High Priority Alert',
      priority: 'HIGH',
      timestamp: new Date().toISOString()
    };

    const result = normalizeNewRelicPayload(payload, 'test');
    expect(result.severity).toBe('HIGH');
  });

  it('defaults unknown priority to MEDIUM', () => {
    const payload = {
      id: 'nr-1',
      title: 'Unknown Priority',
      priority: 'UNKNOWN_LEVEL',
      timestamp: new Date().toISOString()
    };

    const result = normalizeNewRelicPayload(payload, 'test');
    expect(result.severity).toBe('MEDIUM');
  });

  it('extracts service from labels', () => {
    const payload = {
      id: 'nr-1',
      title: 'Test',
      priority: 'MEDIUM',
      timestamp: new Date().toISOString(),
      labels: {
        service: 'user-api',
        region: 'us-east-1'
      }
    };

    const result = normalizeNewRelicPayload(payload, 'test');
    expect(result.metadata.service).toBe('user-api');
  });

  it('preserves unknown fields in metadata', () => {
    const payload = {
      id: 'nr-1',
      title: 'Test',
      priority: 'LOW',
      timestamp: new Date().toISOString(),
      condition_id: 'cond-123',
      policy_name: 'Production Policy'
    };

    const result = normalizeNewRelicPayload(payload, 'test');
    expect(result.metadata.raw.condition_id).toBe('cond-123');
    expect(result.metadata.raw.policy_name).toBe('Production Policy');
  });
});
```
  </action>
  <verify>
Run tests: `npm test -- tests/unit/normalizers.test.ts`
  </verify>
  <done>
Unit tests cover DataDog and New Relic normalizers including severity mapping, service extraction, and unknown field preservation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API integration tests</name>
  <files>tests/integration/integration-api.test.ts</files>
  <action>
Create integration tests for the integration API endpoints.

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import { app } from '../../src/app.js';
import { prisma } from '../../src/config/database.js';

describe('Integration API', () => {
  let adminAuthCookie: string;
  let testIntegrationId: string;

  beforeAll(async () => {
    // Create admin session (use break-glass auth pattern from existing tests)
    const authRes = await request(app)
      .post('/auth/emergency')
      .send({
        email: 'admin@test.com',
        code: process.env.TEST_BREAK_GLASS_CODE || 'test-code'
      });

    adminAuthCookie = authRes.headers['set-cookie']?.[0] || '';

    // Create test integration
    const createRes = await request(app)
      .post('/api/integrations')
      .set('Cookie', adminAuthCookie)
      .send({
        name: 'test-datadog',
        type: 'datadog'
      });

    testIntegrationId = createRes.body.id;
  });

  afterAll(async () => {
    // Clean up test integration
    if (testIntegrationId) {
      await prisma.integration.delete({
        where: { id: testIntegrationId }
      }).catch(() => {}); // Ignore if already deleted
    }
  });

  describe('GET /api/integrations', () => {
    it('returns integration list with health stats', async () => {
      const res = await request(app)
        .get('/api/integrations')
        .set('Cookie', adminAuthCookie);

      expect(res.status).toBe(200);
      expect(res.body.integrations).toBeDefined();
      expect(Array.isArray(res.body.integrations)).toBe(true);

      // Check health stats fields exist
      const integration = res.body.integrations.find(
        (i: any) => i.id === testIntegrationId
      );
      expect(integration).toBeDefined();
      expect(integration.alertCount).toBeDefined();
      expect(integration.webhookCount).toBeDefined();
      expect(integration.errorCount).toBeDefined();
      // lastWebhookAt may be null for new integration
      expect('lastWebhookAt' in integration).toBe(true);
    });

    it('requires admin authentication', async () => {
      const res = await request(app)
        .get('/api/integrations');

      expect(res.status).toBe(401);
    });
  });

  describe('PATCH /api/integrations/:id', () => {
    it('toggles integration active status', async () => {
      // Disable
      let res = await request(app)
        .patch(`/api/integrations/${testIntegrationId}`)
        .set('Cookie', adminAuthCookie)
        .send({ isActive: false });

      expect(res.status).toBe(200);
      expect(res.body.isActive).toBe(false);

      // Re-enable
      res = await request(app)
        .patch(`/api/integrations/${testIntegrationId}`)
        .set('Cookie', adminAuthCookie)
        .send({ isActive: true });

      expect(res.status).toBe(200);
      expect(res.body.isActive).toBe(true);
    });
  });

  describe('POST /api/integrations/:id/test', () => {
    it('creates test alert and returns validation results', async () => {
      const res = await request(app)
        .post(`/api/integrations/${testIntegrationId}/test`)
        .set('Cookie', adminAuthCookie);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.alert).toBeDefined();
      expect(res.body.alert.id).toBeDefined();
      expect(res.body.alert.severity).toBeDefined();
      expect(res.body.incident).toBeDefined();
      expect(res.body.validation).toBeDefined();
      expect(res.body.validation.severityMapped).toBeDefined();
      expect(res.body.validation.serviceRouted).toBeDefined();
      expect(res.body.autoResolveIn).toBe('5 minutes');
    });

    it('returns 404 for non-existent integration', async () => {
      const res = await request(app)
        .post('/api/integrations/non-existent-id/test')
        .set('Cookie', adminAuthCookie);

      expect(res.status).toBe(404);
    });
  });

  describe('GET /api/integrations/:id/deliveries', () => {
    it('returns recent webhook deliveries', async () => {
      const res = await request(app)
        .get(`/api/integrations/${testIntegrationId}/deliveries`)
        .set('Cookie', adminAuthCookie);

      expect(res.status).toBe(200);
      expect(res.body.deliveries).toBeDefined();
      expect(Array.isArray(res.body.deliveries)).toBe(true);
    });

    it('respects limit parameter', async () => {
      const res = await request(app)
        .get(`/api/integrations/${testIntegrationId}/deliveries?limit=5`)
        .set('Cookie', adminAuthCookie);

      expect(res.status).toBe(200);
      expect(res.body.deliveries.length).toBeLessThanOrEqual(5);
    });
  });
});

describe('Provider-Specific Webhooks', () => {
  let integrationId: string;
  let webhookSecret: string;
  let adminAuthCookie: string;

  beforeAll(async () => {
    // Auth
    const authRes = await request(app)
      .post('/auth/emergency')
      .send({
        email: 'admin@test.com',
        code: process.env.TEST_BREAK_GLASS_CODE || 'test-code'
      });
    adminAuthCookie = authRes.headers['set-cookie']?.[0] || '';

    // Create DataDog integration
    const createRes = await request(app)
      .post('/api/integrations')
      .set('Cookie', adminAuthCookie)
      .send({
        name: 'webhook-test-dd',
        type: 'datadog'
      });

    integrationId = createRes.body.id;
    webhookSecret = createRes.body.webhookSecret;
  });

  afterAll(async () => {
    if (integrationId) {
      await prisma.integration.delete({
        where: { id: integrationId }
      }).catch(() => {});
    }
  });

  it('processes DataDog webhook with correct normalization', async () => {
    const payload = {
      alert_id: 'dd-webhook-test',
      alert_title: 'Test CPU Alert',
      alert_status: 'alert',
      alert_priority: 'P1',
      alert_metric: 'system.cpu.user',
      org_id: '123',
      org_name: 'Test',
      event_msg: 'CPU critical',
      date: Math.floor(Date.now() / 1000),
      tags: ['service:test-api']
    };

    // Generate signature
    const crypto = await import('crypto');
    const signature = crypto.default
      .createHmac('sha256', webhookSecret)
      .update(JSON.stringify(payload))
      .digest('hex');

    const res = await request(app)
      .post('/webhooks/alerts/webhook-test-dd')
      .set('X-Datadog-Signature', signature)
      .send(payload);

    expect(res.status).toBe(201);
    expect(res.body.alert_id).toBeDefined();
    expect(res.body.severity).toBe('CRITICAL'); // P1 -> CRITICAL
  });
});
```
  </action>
  <verify>
Run tests: `npm test -- tests/integration/integration-api.test.ts`
  </verify>
  <done>
Integration tests cover: listing with health stats, toggle active status, test webhook endpoint, deliveries endpoint, and DataDog webhook normalization.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete External Integrations phase with:
1. Provider-specific normalizers (DataDog, New Relic)
2. Test webhook endpoint with auto-resolve
3. Webhook delivery logs endpoint
4. Integration health statistics
5. /oncall integrations Slack command
6. Provider prefix in Slack messages
7. IntegrationsPage admin UI with cards, test dialog, logs dialog
8. Unit and integration tests
  </what-built>
  <how-to-verify>
1. Start backend: `npm run dev`
2. Start frontend: `cd frontend && npm run dev`
3. Log in as platform admin
4. Navigate to /integrations
5. Verify:
   - Integration cards show with health indicators (last webhook, error count)
   - Can toggle integration enable/disable
   - Click "Test Webhook" - see validation results dialog
   - Click "View Logs" - see recent webhook attempts
6. In Slack (if configured):
   - Run `/oncall integrations` - should show integration status
7. Send a DataDog-style webhook to verify normalization
8. Run tests: `npm test`
  </how-to-verify>
  <resume-signal>Type "approved" if everything works, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. Frontend TypeScript compiles
2. App route /integrations accessible to admins
3. Non-admins see permission error
4. Integration cards display correctly
5. Test dialog shows validation results
6. Logs dialog shows webhook attempts
7. All tests pass
</verification>

<success_criteria>
- /integrations route shows integration cards for admins
- Non-admins redirected or shown permission error
- Enable/disable toggle works
- Test webhook shows severity mapping, service routing, provider detection
- "Auto-resolve in 5 minutes" notice displayed
- View logs shows last 10 webhook deliveries
- Setup instructions for DataDog and New Relic displayed
- Unit tests for normalizers pass
- Integration tests for API pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-06-SUMMARY.md`
</output>

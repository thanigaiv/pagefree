---
phase: 07-external-integrations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/webhooks/schemas/datadog.schema.ts
  - src/webhooks/schemas/newrelic.schema.ts
  - src/webhooks/schemas/index.ts
  - src/webhooks/alert-receiver.ts
autonomous: true

must_haves:
  truths:
    - "DataDog webhooks are normalized to standard alert schema"
    - "New Relic webhooks are normalized to standard alert schema"
    - "Provider type determines which normalizer is used"
    - "Provider-specific fields are preserved in metadata"
    - "Severity mapping follows P1->CRITICAL, P2->HIGH, etc."
  artifacts:
    - path: "src/webhooks/schemas/datadog.schema.ts"
      provides: "DataDog payload normalization"
      exports: ["normalizeDatadogPayload", "datadogWebhookSchema"]
    - path: "src/webhooks/schemas/newrelic.schema.ts"
      provides: "New Relic payload normalization"
      exports: ["normalizeNewRelicPayload", "newrelicWebhookSchema"]
    - path: "src/webhooks/schemas/index.ts"
      provides: "Provider normalizer registry"
      exports: ["getNormalizer"]
  key_links:
    - from: "src/webhooks/alert-receiver.ts"
      to: "src/webhooks/schemas/index.ts"
      via: "getNormalizer(integration.type)"
      pattern: "getNormalizer.*integration\\.type"
    - from: "src/webhooks/schemas/datadog.schema.ts"
      to: "AlertSeverity enum"
      via: "severity mapping"
      pattern: "AlertSeverity\\.(CRITICAL|HIGH|MEDIUM)"
---

<objective>
Create provider-specific payload normalizers for DataDog and New Relic webhooks.

Purpose: Enable the platform to receive and process alerts from specific monitoring tools with correct severity mapping, service routing via tags, and metadata preservation.

Output: DataDog and New Relic schema files, normalizer registry, updated alert receiver that detects provider type and uses appropriate normalizer.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-CONTEXT.md
@.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-RESEARCH.md

# Existing implementation patterns
@src/webhooks/schemas/alert.schema.ts
@src/webhooks/alert-receiver.ts
@src/services/integration.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DataDog payload normalizer</name>
  <files>src/webhooks/schemas/datadog.schema.ts</files>
  <action>
Create DataDog-specific webhook schema and normalizer following the existing alert.schema.ts pattern.

Schema fields (from DataDog webhook format):
- alert_id: string (required) -> externalId
- alert_title: string (required) -> title with "[DataDog]" prefix
- alert_status: string (alert, warning, no data) -> store in metadata
- alert_priority: string (P1-P5) -> map to AlertSeverity
- alert_metric: string -> store in metadata
- org_id, org_name: strings -> store in metadata
- event_msg: string -> description
- tags: string[] (e.g., ["service:api", "env:prod"]) -> extract service tag for routing
- snapshot: string (graph URL) -> store in metadata
- date: number (Unix timestamp) -> triggeredAt
- monitor_id, monitor_name: optional -> store in metadata

Severity mapping per user decision:
- P1 -> CRITICAL
- P2 -> HIGH
- P3 -> MEDIUM
- P4 -> LOW
- P5 -> INFO
- Unknown -> MEDIUM (default fallback)

Service extraction: Find tag starting with "service:" and extract value for metadata.service (used by routing in Phase 4).

Use z.passthrough() to preserve unknown fields in metadata.raw.

Export: datadogWebhookSchema, normalizeDatadogPayload
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/webhooks/schemas/datadog.schema.ts`
  </verify>
  <done>
DataDog webhook payloads can be parsed and normalized to NormalizedAlert with "[DataDog]" title prefix, correct severity mapping, and service tag extraction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create New Relic payload normalizer</name>
  <files>src/webhooks/schemas/newrelic.schema.ts</files>
  <action>
Create New Relic-specific webhook schema and normalizer.

Schema fields (from New Relic webhook format):
- id: string (required) -> externalId
- title: string (required) -> title with "[New Relic]" prefix
- priority: string (CRITICAL, HIGH, MEDIUM, LOW, INFO) -> map to AlertSeverity
- state: string (open, acknowledged, closed) -> store in metadata
- message: string -> description
- timestamp: ISO-8601 string -> triggeredAt
- labels: object (e.g., { service: "api", env: "prod" }) -> extract service for routing
- condition_name, condition_id: optional -> store in metadata
- account_id, account_name: optional -> store in metadata
- policy_name: optional -> store in metadata

Severity mapping (New Relic uses same names):
- CRITICAL -> CRITICAL
- HIGH -> HIGH
- MEDIUM -> MEDIUM
- LOW -> LOW
- INFO -> INFO
- Unknown -> MEDIUM (default fallback)

Service extraction: Read labels.service directly for metadata.service.

Use z.passthrough() to preserve unknown fields in metadata.raw.

Export: newrelicWebhookSchema, normalizeNewRelicPayload
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/webhooks/schemas/newrelic.schema.ts`
  </verify>
  <done>
New Relic webhook payloads can be parsed and normalized to NormalizedAlert with "[New Relic]" title prefix, correct severity mapping, and service label extraction.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create normalizer registry and update alert receiver</name>
  <files>src/webhooks/schemas/index.ts, src/webhooks/alert-receiver.ts</files>
  <action>
1. Create src/webhooks/schemas/index.ts as normalizer registry:

```typescript
import { normalizeAlertPayload } from './alert.schema.js';
import { normalizeDatadogPayload } from './datadog.schema.js';
import { normalizeNewRelicPayload } from './newrelic.schema.js';
import type { NormalizedAlert } from './alert.schema.js';

type ProviderNormalizer = (payload: unknown, integrationName: string) => NormalizedAlert;

const normalizers: Record<string, ProviderNormalizer> = {
  generic: normalizeAlertPayload,
  datadog: normalizeDatadogPayload,
  newrelic: normalizeNewRelicPayload
};

export function getNormalizer(integrationType: string): ProviderNormalizer {
  return normalizers[integrationType] || normalizers.generic;
}

// Re-export types and generic functions for backward compatibility
export { validateAlertPayload, type NormalizedAlert } from './alert.schema.js';
```

2. Update src/webhooks/alert-receiver.ts:

Replace the direct call to validateAlertPayload with provider-aware normalization:

```typescript
// Before: const validation = validateAlertPayload(req.body, integration.name);
// After:
import { getNormalizer, validateAlertPayload } from './schemas/index.js';

// In handler, after duplicate check:
const normalizer = getNormalizer(integration.type);

// For provider-specific types (datadog, newrelic), use direct normalization
// For generic type, use validation + normalization
let normalizedData: NormalizedAlert;

if (integration.type === 'datadog' || integration.type === 'newrelic') {
  try {
    normalizedData = normalizer(req.body, integration.name);
  } catch (error) {
    // Record validation failure
    await alertService.recordDeliveryOnly({...});
    res.status(400).json(formatValidationError(...));
    return;
  }
} else {
  // Generic validation path (existing behavior)
  const validation = validateAlertPayload(req.body, integration.name);
  if (!validation.success) {
    // ... existing error handling
  }
  normalizedData = validation.data;
}
```

The provider-specific normalizers include their own Zod validation, so they throw on invalid payloads. The generic path continues to use the existing validateAlertPayload.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Run existing webhook tests: `npm test -- --grep webhook`
  </verify>
  <done>
Alert receiver detects integration type and routes to appropriate normalizer. DataDog/New Relic integrations use provider-specific schemas, generic integrations use existing validation.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes with no errors
2. Existing alert webhook tests continue to pass (backward compatibility)
3. DataDog normalizer handles sample payload correctly:
   - Input: { alert_id: "test", alert_title: "Test", alert_priority: "P1", date: 1234567890, tags: ["service:api"] }
   - Output: { title: "[DataDog] Test", severity: "CRITICAL", metadata: { service: "api", ... } }
4. New Relic normalizer handles sample payload correctly:
   - Input: { id: "test", title: "Test", priority: "HIGH", timestamp: "2024-01-01T00:00:00Z", labels: { service: "api" } }
   - Output: { title: "[New Relic] Test", severity: "HIGH", metadata: { service: "api", ... } }
</verification>

<success_criteria>
- DataDog webhooks create alerts with "[DataDog]" prefix and correct severity
- New Relic webhooks create alerts with "[New Relic]" prefix and correct severity
- Service tags are extracted to metadata.service for routing
- Provider-specific fields preserved in metadata
- Generic webhooks continue to work (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-01-SUMMARY.md`
</output>

---
phase: 07-external-integrations
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/services/notification/slack-interaction.service.ts
  - src/services/notification/channels/slack.channel.ts
autonomous: true

must_haves:
  truths:
    - "Admin can check integration status from Slack via /oncall integrations"
    - "Slack messages show [DataDog] or [New Relic] prefix in title"
    - "Non-admins see permission error for /oncall integrations"
  artifacts:
    - path: "src/services/notification/slack-interaction.service.ts"
      provides: "Integration status slash command"
      contains: "case 'integrations'"
    - path: "src/services/notification/channels/slack.channel.ts"
      provides: "Provider prefix in Slack messages"
      contains: "\\[DataDog\\]|\\[New Relic\\]"
  key_links:
    - from: "src/services/notification/slack-interaction.service.ts"
      to: "prisma.integration"
      via: "database query"
      pattern: "prisma\\.integration\\.findMany"
---

<objective>
Add Slack integration features: /oncall integrations command and provider name prefix in Slack messages.

Purpose: Enable admins to monitor integration health from Slack without visiting the web UI, and provide clear alert source identification in Slack messages.

Output: `/oncall integrations` command showing integration status, Slack messages prefixed with [DataDog] or [New Relic] based on alert source.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-CONTEXT.md

# Existing Slack implementation
@src/services/notification/slack-interaction.service.ts
@src/services/notification/channels/slack.channel.ts
@src/services/notification/templates/slack.templates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add /oncall integrations slash command</name>
  <files>src/services/notification/slack-interaction.service.ts</files>
  <action>
Extend the processCommand() method in SlackInteractionService to handle the 'integrations' subcommand.

1. Add new case in the switch statement after 'list':

```typescript
case 'integrations':
  await this.handleSlashIntegrations(slackConnection.userId, responseUrl);
  break;
```

2. Implement handleSlashIntegrations method:

```typescript
private async handleSlashIntegrations(
  userId: string,
  responseUrl: string
): Promise<void> {
  // Check if user is platform admin per user decision
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { platformRole: true }
  });

  if (user?.platformRole !== 'PLATFORM_ADMIN') {
    await this.sendSlashResponse(
      responseUrl,
      'ephemeral',
      ':lock: Only platform admins can view integration status'
    );
    return;
  }

  // Fetch integration health stats
  const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);

  const integrations = await prisma.integration.findMany({
    where: { isActive: true },
    include: {
      webhookDeliveries: {
        take: 1,
        orderBy: { createdAt: 'desc' },
        select: { createdAt: true }
      }
    }
  });

  // Get error counts per integration
  const errorCounts = await prisma.webhookDelivery.groupBy({
    by: ['integrationId'],
    where: {
      statusCode: { gte: 400 },
      createdAt: { gte: twentyFourHoursAgo }
    },
    _count: true
  });

  const errorCountMap = Object.fromEntries(
    errorCounts.map(e => [e.integrationId, e._count])
  );

  if (integrations.length === 0) {
    await this.sendSlashResponse(
      responseUrl,
      'ephemeral',
      'No active integrations configured'
    );
    return;
  }

  // Format integration status lines per user's specific idea
  const { formatDistanceToNow } = await import('date-fns');

  const lines = integrations.map(int => {
    const lastWebhook = int.webhookDeliveries[0]?.createdAt;
    const errorCount = errorCountMap[int.id] || 0;

    // Health indicator: warning if errors, check if healthy
    const status = errorCount > 0 ? ':warning:' : ':white_check_mark:';

    // Format last webhook time
    const lastWebhookText = lastWebhook
      ? formatDistanceToNow(lastWebhook, { addSuffix: true })
      : 'never';

    // Format type for display
    const typeDisplay = int.type === 'datadog' ? 'DataDog'
      : int.type === 'newrelic' ? 'New Relic'
      : int.type.charAt(0).toUpperCase() + int.type.slice(1);

    // Build status line per specific idea format
    let line = `${status} *${int.name}* (${typeDisplay}) - Last webhook: ${lastWebhookText}`;
    if (errorCount > 0) {
      line += ` - :x: ${errorCount} error${errorCount === 1 ? '' : 's'} (24h)`;
    }

    return line;
  });

  await this.sendSlashResponse(
    responseUrl,
    'ephemeral',
    `*Active Integrations:*\n${lines.join('\n')}`
  );
}
```

3. Update the default case help text to include integrations command:

```typescript
default:
  await this.sendSlashResponse(responseUrl, 'ephemeral',
    'Usage:\n' +
    '`/oncall ack <id>` - Acknowledge incident\n' +
    '`/oncall resolve <id>` - Resolve incident\n' +
    '`/oncall list` - List your open incidents\n' +
    '`/oncall integrations` - View integration status (admin only)'
  );
```
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/services/notification/slack-interaction.service.ts`
  </verify>
  <done>
/oncall integrations command shows active integrations with health indicators (last webhook time, error count). Non-admins see permission error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add provider prefix to Slack messages</name>
  <files>src/services/notification/channels/slack.channel.ts</files>
  <action>
Update the Slack channel to prefix incident titles with [DataDog] or [New Relic] based on the alert's provider metadata.

In the SlackChannel.send() method (or wherever the Slack message is built), modify the title extraction to include provider prefix.

1. First, read the existing slack.channel.ts implementation to understand the message building pattern.

2. When building the Slack message, check for provider in incident metadata:

```typescript
// Helper function to get provider prefix
private getProviderPrefix(incident: any): string {
  // Check incident's alert metadata for provider
  const alertMetadata = incident.alerts?.[0]?.metadata;
  if (!alertMetadata) return '';

  const provider = alertMetadata.provider;
  if (provider === 'datadog') return '[DataDog] ';
  if (provider === 'newrelic') return '[New Relic] ';

  return '';
}
```

3. In the message building code, prepend the prefix to the title:

```typescript
// Before: const title = incident.title || 'Incident Alert';
// After:
const providerPrefix = this.getProviderPrefix(incident);
const title = providerPrefix + (incident.title || 'Incident Alert');
```

Note: The provider prefix may already be in the title if the normalizer (from 07-01) added it. Check if title already starts with [DataDog] or [New Relic] to avoid double-prefixing:

```typescript
private getProviderPrefix(incident: any): string {
  // Check if title already has prefix (from normalizer)
  const title = incident.title || '';
  if (title.startsWith('[DataDog]') || title.startsWith('[New Relic]')) {
    return ''; // Already prefixed by normalizer
  }

  // Fallback: check metadata
  const alertMetadata = incident.alerts?.[0]?.metadata;
  if (!alertMetadata?.provider) return '';

  const provider = alertMetadata.provider;
  if (provider === 'datadog') return '[DataDog] ';
  if (provider === 'newrelic') return '[New Relic] ';

  return '';
}
```

4. Apply the same logic to the Slack templates (slack.templates.ts) if titles are built there.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit src/services/notification/channels/slack.channel.ts`
  </verify>
  <done>
Slack messages show [DataDog] or [New Relic] prefix in title for alerts from those providers. Generic alerts show no prefix.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes
2. /oncall integrations command (as admin) returns formatted integration list
3. /oncall integrations command (as non-admin) returns permission error
4. Slack notification for DataDog alert shows "[DataDog]" in title
5. Slack notification for New Relic alert shows "[New Relic]" in title
6. Generic alerts show no prefix (no double-bracketing)
</verification>

<success_criteria>
- /oncall integrations shows all active integrations with name, type, last webhook time
- Error count (24h) displayed if > 0
- Health emoji indicates status (checkmark = healthy, warning = errors)
- Non-admins receive "Only platform admins can view integration status"
- Slack message titles prefixed with provider name for DataDog/New Relic alerts
</success_criteria>

<output>
After completion, create `.planning/phases/07-external-integrations**---datadog,-new-relic,-slack-bidirectional-sync/07-03-SUMMARY.md`
</output>

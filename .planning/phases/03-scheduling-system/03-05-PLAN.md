---
phase: 03-scheduling-system
plan: 05
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/services/oncall.service.ts
  - src/routes/oncall.routes.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can view who is currently on-call for each service (SCHED-10)"
    - "System handles timezones correctly for distributed teams (SCHED-06)"
    - "System evaluates override > layer precedence in correct order"
    - "Rotation position calculated correctly from RRULE occurrences"
  artifacts:
    - path: "src/services/oncall.service.ts"
      provides: "OnCallService with who-is-on-call query"
      exports: ["OnCallService"]
    - path: "src/routes/oncall.routes.ts"
      provides: "On-call query API routes"
      min_lines: 40
  key_links:
    - from: "src/routes/oncall.routes.ts"
      to: "src/services/oncall.service.ts"
      via: "import and method calls"
      pattern: "OnCallService"
    - from: "src/services/oncall.service.ts"
      to: "RRule"
      via: "rrule library for occurrence calculation"
      pattern: "RRule\\.fromString|rule\\.between"
---

<objective>
Create the who-is-on-call query service that evaluates schedules, layers, and overrides to determine current on-call engineer.

Purpose: Enable real-time on-call lookups for alert routing (Phase 4) and user-facing "who is on-call" queries (SCHED-10).

Output: OnCallService with getCurrentOnCall algorithm and REST API endpoint.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scheduling-system/03-RESEARCH.md
@.planning/phases/03-scheduling-system/03-02-SUMMARY.md
@.planning/phases/03-scheduling-system/03-03-SUMMARY.md
@prisma/schema.prisma
@src/services/schedule.service.ts
@src/services/scheduleLayer.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create on-call service with core algorithm</name>
  <files>src/services/oncall.service.ts</files>
  <action>
Create src/services/oncall.service.ts with OnCallService class implementing the who-is-on-call algorithm from research:

1. Import dependencies:
   - PrismaClient
   - RRule from rrule
   - DateTime from luxon
   - User, Schedule, ScheduleLayer, ScheduleOverride types

2. Define result interfaces:
   ```typescript
   export interface OnCallResult {
     user: {
       id: string;
       firstName: string;
       lastName: string;
       email: string;
       phone: string | null;
     };
     source: 'override' | 'layer' | 'schedule';
     layerName?: string;
     overrideReason?: string;
     shiftStart: Date;
     shiftEnd: Date;
     scheduleId: string;
     scheduleName: string;
   }

   export interface OnCallQuery {
     scheduleId?: string;
     teamId?: string;
     at?: Date; // Default: now
   }
   ```

3. Private helper: layerAppliesAt(layer, time) - check if layer restrictions allow this time:
   ```typescript
   private layerAppliesAt(layer: ScheduleLayer, time: DateTime): boolean {
     if (!layer.restrictions) return true;

     const restrictions = layer.restrictions as { daysOfWeek?: string[] };
     if (restrictions.daysOfWeek) {
       const weekdayMap: Record<number, string> = {
         1: 'MO', 2: 'TU', 3: 'WE', 4: 'TH', 5: 'FR', 6: 'SA', 7: 'SU'
       };
       const currentDay = weekdayMap[time.weekday];
       return restrictions.daysOfWeek.includes(currentDay);
     }

     return true;
   }
   ```

4. Private helper: calculateShiftFromRRule(rule, startDate, atTime, userIds, timezone):
   ```typescript
   private calculateShiftFromRRule(
     ruleStr: string,
     startDate: Date,
     atTime: DateTime,
     userIds: string[],
     timezone: string
   ): { userIndex: number; shiftStart: Date; shiftEnd: Date } | null {
     const rule = RRule.fromString(ruleStr);
     const layerStart = DateTime.fromJSDate(startDate, { zone: timezone });

     // Get all occurrences from start until query time
     const occurrences = rule.between(
       layerStart.toJSDate(),
       atTime.toJSDate(),
       true // inclusive
     );

     if (occurrences.length === 0) return null;

     // Current shift is the last occurrence
     const shiftIndex = occurrences.length - 1;
     const userIndex = shiftIndex % userIds.length;

     // Shift start is current occurrence, end is next occurrence
     const shiftStart = occurrences[shiftIndex];
     const nextOccurrence = rule.after(atTime.toJSDate());
     const shiftEnd = nextOccurrence || DateTime.fromJSDate(shiftStart).plus({ weeks: 1 }).toJSDate();

     return { userIndex, shiftStart, shiftEnd };
   }
   ```

5. getCurrentOnCall(query) method implementing the algorithm:
   ```typescript
   async getCurrentOnCall(query: OnCallQuery): Promise<OnCallResult | null> {
     const atTime = query.at ? DateTime.fromJSDate(query.at) : DateTime.now();

     // 1. Load schedule(s) based on query
     const schedules = await this.getSchedules(query);
     if (schedules.length === 0) return null;

     for (const schedule of schedules) {
       const scheduleTime = atTime.setZone(schedule.timezone);

       // 2. Check for active override (highest precedence)
       const override = await this.prisma.scheduleOverride.findFirst({
         where: {
           scheduleId: schedule.id,
           startTime: { lte: scheduleTime.toJSDate() },
           endTime: { gt: scheduleTime.toJSDate() },
         },
         include: {
           user: { select: { id: true, firstName: true, lastName: true, email: true, phone: true } },
         },
       });

       if (override) {
         return {
           user: override.user,
           source: 'override',
           overrideReason: override.reason || undefined,
           shiftStart: override.startTime,
           shiftEnd: override.endTime,
           scheduleId: schedule.id,
           scheduleName: schedule.name,
         };
       }

       // 3. Evaluate layers in priority order
       const layers = await this.prisma.scheduleLayer.findMany({
         where: { scheduleId: schedule.id, isActive: true },
         orderBy: { priority: 'desc' },
       });

       for (const layer of layers) {
         const layerTime = atTime.setZone(layer.timezone);

         // Check restrictions
         if (!this.layerAppliesAt(layer, layerTime)) continue;

         // Calculate from RRULE
         const shift = this.calculateShiftFromRRule(
           layer.recurrenceRule,
           layer.startDate,
           layerTime,
           layer.rotationUserIds,
           layer.timezone
         );

         if (shift) {
           const user = await this.prisma.user.findUnique({
             where: { id: layer.rotationUserIds[shift.userIndex] },
             select: { id: true, firstName: true, lastName: true, email: true, phone: true },
           });

           if (user) {
             return {
               user,
               source: 'layer',
               layerName: layer.name,
               shiftStart: shift.shiftStart,
               shiftEnd: shift.shiftEnd,
               scheduleId: schedule.id,
               scheduleName: schedule.name,
             };
           }
         }
       }

       // 4. Fall back to base schedule if no layers
       if (layers.length === 0 && schedule.rotationUserIds.length > 0) {
         const shift = this.calculateShiftFromRRule(
           schedule.recurrenceRule,
           schedule.startDate,
           scheduleTime,
           schedule.rotationUserIds,
           schedule.timezone
         );

         if (shift) {
           const user = await this.prisma.user.findUnique({
             where: { id: schedule.rotationUserIds[shift.userIndex] },
             select: { id: true, firstName: true, lastName: true, email: true, phone: true },
           });

           if (user) {
             return {
               user,
               source: 'schedule',
               shiftStart: shift.shiftStart,
               shiftEnd: shift.shiftEnd,
               scheduleId: schedule.id,
               scheduleName: schedule.name,
             };
           }
         }
       }
     }

     return null;
   }
   ```

6. getOnCallForTeam(teamId, at?) method:
   - Find all active schedules for team
   - Call getCurrentOnCall for each
   - Return array of OnCallResult
  </action>
  <verify>Run `npm run build` - TypeScript should compile without errors</verify>
  <done>OnCallService created with who-is-on-call algorithm evaluating overrides, layers, and base schedule</done>
</task>

<task type="auto">
  <name>Task 2: Add timezone-aware helpers and edge case handling</name>
  <files>src/services/oncall.service.ts</files>
  <action>
Extend OnCallService with timezone and edge case handling:

1. Add getUpcomingShifts(userId, days) method:
   ```typescript
   async getUpcomingShifts(userId: string, days: number = 30): Promise<Array<{
     scheduleId: string;
     scheduleName: string;
     shiftStart: Date;
     shiftEnd: Date;
   }>> {
     // Find all schedules user is part of (in rotationUserIds)
     const schedules = await this.prisma.schedule.findMany({
       where: {
         isActive: true,
         rotationUserIds: { has: userId },
       },
     });

     // Also check layers
     const layers = await this.prisma.scheduleLayer.findMany({
       where: {
         isActive: true,
         rotationUserIds: { has: userId },
       },
       include: { schedule: true },
     });

     const shifts: Array<{ scheduleId: string; scheduleName: string; shiftStart: Date; shiftEnd: Date }> = [];
     const now = DateTime.now();
     const endWindow = now.plus({ days });

     // Calculate shifts from schedules
     for (const schedule of schedules) {
       const rule = RRule.fromString(schedule.recurrenceRule);
       const occurrences = rule.between(now.toJSDate(), endWindow.toJSDate(), true);

       for (let i = 0; i < occurrences.length; i++) {
         const userIndex = i % schedule.rotationUserIds.length;
         if (schedule.rotationUserIds[userIndex] === userId) {
           const nextOcc = occurrences[i + 1] || rule.after(occurrences[i]);
           shifts.push({
             scheduleId: schedule.id,
             scheduleName: schedule.name,
             shiftStart: occurrences[i],
             shiftEnd: nextOcc || DateTime.fromJSDate(occurrences[i]).plus({ weeks: 1 }).toJSDate(),
           });
         }
       }
     }

     // Calculate shifts from layers
     for (const layer of layers) {
       const rule = RRule.fromString(layer.recurrenceRule);
       const occurrences = rule.between(now.toJSDate(), endWindow.toJSDate(), true);

       for (let i = 0; i < occurrences.length; i++) {
         const userIndex = i % layer.rotationUserIds.length;
         if (layer.rotationUserIds[userIndex] === userId) {
           const nextOcc = occurrences[i + 1] || rule.after(occurrences[i]);
           shifts.push({
             scheduleId: layer.schedule.id,
             scheduleName: layer.schedule.name,
             shiftStart: occurrences[i],
             shiftEnd: nextOcc || DateTime.fromJSDate(occurrences[i]).plus({ weeks: 1 }).toJSDate(),
           });
         }
       }
     }

     // Sort by shiftStart and remove duplicates
     return shifts.sort((a, b) => a.shiftStart.getTime() - b.shiftStart.getTime());
   }
   ```

2. Add getScheduleTimeline(scheduleId, startDate, endDate) method for preview:
   ```typescript
   async getScheduleTimeline(
     scheduleId: string,
     startDate: Date,
     endDate: Date
   ): Promise<Array<{
     userId: string;
     userName: string;
     shiftStart: Date;
     shiftEnd: Date;
     source: 'schedule' | 'layer' | 'override';
   }>> {
     // Load schedule with layers and overrides in date range
     const schedule = await this.prisma.schedule.findUniqueOrThrow({
       where: { id: scheduleId },
       include: {
         layers: { where: { isActive: true }, orderBy: { priority: 'desc' } },
         overrides: {
           where: {
             OR: [
               { startTime: { gte: startDate, lt: endDate } },
               { endTime: { gt: startDate, lte: endDate } },
               { startTime: { lte: startDate }, endTime: { gte: endDate } },
             ],
           },
           include: { user: true },
         },
       },
     });

     // Build timeline (simplified - full implementation would merge overlapping regions)
     const timeline: Array<{
       userId: string;
       userName: string;
       shiftStart: Date;
       shiftEnd: Date;
       source: 'schedule' | 'layer' | 'override';
     }> = [];

     // Add overrides first (they take precedence)
     for (const override of schedule.overrides) {
       timeline.push({
         userId: override.userId,
         userName: `${override.user.firstName} ${override.user.lastName}`,
         shiftStart: override.startTime,
         shiftEnd: override.endTime,
         source: 'override',
       });
     }

     return timeline.sort((a, b) => a.shiftStart.getTime() - b.shiftStart.getTime());
   }
   ```
  </action>
  <verify>Run `npm run build` - TypeScript should compile without errors</verify>
  <done>Timezone-aware shift calculation and timeline preview methods added</done>
</task>

<task type="auto">
  <name>Task 3: Create on-call routes and mount to app</name>
  <files>src/routes/oncall.routes.ts, src/index.ts</files>
  <action>
Create src/routes/oncall.routes.ts with Express router:

1. Define routes:

GET /api/oncall/now
- Auth: requireAuth
- Query params:
  - scheduleId?: string (specific schedule)
  - teamId?: string (all schedules for team)
  - at?: string (ISO datetime, default: now)
- Call OnCallService.getCurrentOnCall(query)
- Return 200 with OnCallResult or 404 if no on-call found

GET /api/teams/:teamId/oncall
- Auth: requireAuth
- Query params:
  - at?: string (ISO datetime, default: now)
- Call OnCallService.getOnCallForTeam(teamId, at)
- Return 200 with array of OnCallResult (one per schedule)

GET /api/schedules/:scheduleId/oncall
- Auth: requireAuth
- Query params:
  - at?: string (ISO datetime, default: now)
- Call OnCallService.getCurrentOnCall({ scheduleId, at })
- Return 200 with OnCallResult or 404 if no on-call found

GET /api/schedules/:scheduleId/timeline
- Auth: requireAuth
- Query params:
  - startDate: string (ISO datetime, required)
  - endDate: string (ISO datetime, required)
- Call OnCallService.getScheduleTimeline(scheduleId, startDate, endDate)
- Return 200 with timeline array

GET /api/users/me/shifts/upcoming
- Auth: requireAuth
- Query params:
  - days?: number (default: 30)
- Call OnCallService.getUpcomingShifts(req.user.id, days)
- Return 200 with upcoming shifts array

Update src/index.ts:
- Import oncall routes
- Mount at /api/oncall and integrate with schedule routes
  </action>
  <verify>Run `npm run build` and start server. Test with curl:
- Create schedule with users in rotation
- GET /api/oncall/now?scheduleId=xxx should return current on-call
- Create override for different user
- GET /api/oncall/now should now return override user
- GET /api/users/me/shifts/upcoming should return user's shifts
</verify>
  <done>On-call query routes created and mounted</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - TypeScript compiles without errors
2. Run `npm run dev` and test endpoints:
   - Create schedule with 3 users in weekly rotation
   - GET /api/oncall/now?scheduleId=xxx returns user based on current week
   - GET with at= parameter returns correct user for that time
   - Create override - on-call returns override user during override period
   - Create weekend-only layer - verify layer applies on weekends
   - GET /api/schedules/:id/timeline shows schedule preview
   - GET /api/users/me/shifts/upcoming shows user's shifts
3. Verify timezone handling:
   - Schedule in America/New_York
   - Query at= time in UTC - should convert correctly
   - Verify rotation advances at handoff time in schedule's timezone
4. Verify precedence:
   - Override always wins over layer
   - Higher priority layer wins over lower priority
</verification>

<success_criteria>
- OnCallService implements who-is-on-call algorithm
- Override > Layer > Schedule precedence order correct
- Layer restrictions (day-of-week) evaluated correctly
- Rotation position calculated from RRULE occurrences
- Timezone conversion handled via Luxon
- API returns on-call user with shift details
- Timeline preview available for schedule visualization
- Users can see their upcoming shifts
</success_criteria>

<output>
After completion, create `.planning/phases/03-scheduling-system/03-05-SUMMARY.md`
</output>

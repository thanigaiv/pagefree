---
phase: 03-scheduling-system
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/types/schedule.ts
  - src/services/scheduleLayer.service.ts
  - src/routes/scheduleLayer.routes.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can add schedule layer with priority for precedence control"
    - "User can configure layer restrictions (weekend-only, weekday-only)"
    - "Higher priority layers override lower priority layers"
    - "Each layer has its own rotation pattern and user list"
  artifacts:
    - path: "src/services/scheduleLayer.service.ts"
      provides: "ScheduleLayerService with layer management"
      exports: ["ScheduleLayerService"]
    - path: "src/routes/scheduleLayer.routes.ts"
      provides: "Layer API routes nested under schedules"
      min_lines: 50
  key_links:
    - from: "src/routes/scheduleLayer.routes.ts"
      to: "src/services/scheduleLayer.service.ts"
      via: "import and method calls"
      pattern: "ScheduleLayerService"
    - from: "src/services/scheduleLayer.service.ts"
      to: "prisma.scheduleLayer"
      via: "Prisma client queries"
      pattern: "prisma\\.scheduleLayer\\.(create|update|find)"
---

<objective>
Add schedule layer management to support multi-layer schedules with priority precedence and time-based restrictions (PagerDuty pattern).

Purpose: Enable complex coverage patterns like primary/backup rotations, weekend-specific coverage, and holiday schedules through layered approach.

Output: ScheduleLayerService and API routes for managing layers with restrictions and priority ordering.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scheduling-system/03-RESEARCH.md
@.planning/phases/03-scheduling-system/03-01-SUMMARY.md
@prisma/schema.prisma
@src/types/schedule.ts
@src/services/schedule.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add layer types and validation schemas</name>
  <files>src/types/schedule.ts</files>
  <action>
Extend src/types/schedule.ts with layer-related types:

1. Add restriction types:
   ```typescript
   export const DayOfWeek = z.enum(['MO', 'TU', 'WE', 'TH', 'FR', 'SA', 'SU']);
   export type DayOfWeek = z.infer<typeof DayOfWeek>;

   export const LayerRestrictionsSchema = z.object({
     daysOfWeek: z.array(DayOfWeek).optional(),
     // Future: startHour, endHour for time-of-day restrictions
   }).optional();

   export type LayerRestrictions = z.infer<typeof LayerRestrictionsSchema>;
   ```

2. Add layer input schemas:
   ```typescript
   export const CreateLayerInputSchema = z.object({
     scheduleId: z.string().cuid(),
     name: z.string().min(1).max(50),
     priority: z.number().int().min(1).max(100),
     timezone: z.string().refine(
       (tz) => IANAZone.isValidZone(tz),
       { message: 'Invalid IANA timezone' }
     ),
     startDate: z.string().datetime(),
     endDate: z.string().datetime().optional(),
     handoffTime: z.string().regex(/^([01]\d|2[0-3]):([0-5]\d)$/),
     rotationType: z.enum(['daily', 'weekly', 'custom']),
     rotationIntervalDays: z.number().int().min(1).max(365).optional(),
     rotationUserIds: z.array(z.string().cuid()).min(1),
     restrictions: LayerRestrictionsSchema,
   });

   export const UpdateLayerInputSchema = CreateLayerInputSchema
     .omit({ scheduleId: true })
     .partial();
   ```

3. Export TypeScript types:
   ```typescript
   export type CreateLayerInput = z.infer<typeof CreateLayerInputSchema>;
   export type UpdateLayerInput = z.infer<typeof UpdateLayerInputSchema>;
   ```

4. Add interface for layer with schedule:
   ```typescript
   export interface LayerWithSchedule {
     id: string;
     scheduleId: string;
     name: string;
     priority: number;
     timezone: string;
     startDate: Date;
     endDate: Date | null;
     handoffTime: string;
     recurrenceRule: string;
     rotationUserIds: string[];
     restrictions: LayerRestrictions | null;
     isActive: boolean;
     schedule?: {
       id: string;
       name: string;
       teamId: string;
     };
   }
   ```
  </action>
  <verify>Run `npm run build` - TypeScript should compile without errors</verify>
  <done>Layer types added with restriction schemas and validation</done>
</task>

<task type="auto">
  <name>Task 2: Create schedule layer service</name>
  <files>src/services/scheduleLayer.service.ts</files>
  <action>
Create src/services/scheduleLayer.service.ts with ScheduleLayerService class:

1. Import dependencies:
   - PrismaClient, RRule, DateTime from standard libs
   - Types from schedule types
   - AuditService for logging

2. Private helper: generateRRule(input) - same logic as schedule service:
   ```typescript
   private generateRRule(input: {
     rotationType: 'daily' | 'weekly' | 'custom';
     rotationIntervalDays?: number;
     startDate: Date;
     timezone: string;
     handoffTime: string;
   }): string
   ```

3. create(input, userId) method:
   - Validate timezone
   - Load parent schedule to verify it exists and get teamId
   - Validate all rotationUserIds are members of schedule's team
   - Check for priority conflicts (warn if same priority exists)
   - Generate RRULE from rotation settings
   - Create layer with:
     - All input fields
     - Generated recurrenceRule
     - restrictions stored as JSON
   - Audit log: schedule.layer.created
   - Return layer

4. findBySchedule(scheduleId) method:
   - Find all layers for a schedule
   - Order by priority DESC (highest first)
   - Filter by isActive = true

5. findById(id) method:
   - Find layer with schedule included
   - Return null if not found

6. update(id, input, userId) method:
   - If rotation settings changed, regenerate RRULE
   - Update layer in database
   - Audit log: schedule.layer.updated
   - Return updated layer

7. delete(id, userId) method:
   - Load layer with schedule for audit context
   - Hard delete layer
   - Audit log: schedule.layer.deleted

8. reorderPriorities(scheduleId, layerIds, userId) method:
   - Reorder layers by updating priorities
   - layerIds array is in desired order (first = highest priority)
   - Update each layer with new priority (100, 90, 80, etc.)
   - Audit log: schedule.layers.reordered
  </action>
  <verify>Run `npm run build` - TypeScript should compile without errors</verify>
  <done>ScheduleLayerService created with CRUD and priority management</done>
</task>

<task type="auto">
  <name>Task 3: Create layer routes and mount to app</name>
  <files>src/routes/scheduleLayer.routes.ts, src/index.ts</files>
  <action>
Create src/routes/scheduleLayer.routes.ts with Express router:

1. Define routes nested under schedules:

POST /api/schedules/:scheduleId/layers
- Auth: requireAuth
- Body validation: CreateLayerInputSchema
- Permission: Must be team admin of schedule's team
- Set scheduleId from params
- Call ScheduleLayerService.create(input, req.user.id)
- Return 201 with created layer

GET /api/schedules/:scheduleId/layers
- Auth: requireAuth
- Call ScheduleLayerService.findBySchedule(scheduleId)
- Return 200 with layers array (ordered by priority DESC)

GET /api/schedules/:scheduleId/layers/:layerId
- Auth: requireAuth
- Call ScheduleLayerService.findById(layerId)
- Verify layer.scheduleId matches params
- Return 404 if not found
- Return 200 with layer

PATCH /api/schedules/:scheduleId/layers/:layerId
- Auth: requireAuth
- Body validation: UpdateLayerInputSchema
- Permission: Must be team admin of schedule's team
- Call ScheduleLayerService.update(layerId, input, req.user.id)
- Return 200 with updated layer

DELETE /api/schedules/:scheduleId/layers/:layerId
- Auth: requireAuth
- Permission: Must be team admin or platform admin
- Call ScheduleLayerService.delete(layerId, req.user.id)
- Return 204 No Content

POST /api/schedules/:scheduleId/layers/reorder
- Auth: requireAuth
- Body: { layerIds: string[] } - ordered array
- Permission: Must be team admin
- Call ScheduleLayerService.reorderPriorities(scheduleId, layerIds, req.user.id)
- Return 200 with reordered layers

Update src/index.ts:
- Import schedule layer routes
- Mount at /api/schedules (routes handle nested paths)
  </action>
  <verify>Run `npm run build` and start server. Test with curl:
- Create schedule first
- POST /api/schedules/:id/layers with primary layer
- POST /api/schedules/:id/layers with backup layer (lower priority)
- GET /api/schedules/:id/layers should show both ordered by priority
</verify>
  <done>Schedule layer routes created and mounted with RBAC enforcement</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - TypeScript compiles without errors
2. Run `npm run dev` and test endpoints:
   - Create schedule first
   - POST layer "Primary" with priority 100, weekday restrictions
   - POST layer "Weekend" with priority 90, weekend restrictions [SA, SU]
   - GET layers returns both ordered by priority (Primary first)
   - PATCH layer to change restrictions
   - POST reorder to swap priorities
   - DELETE layer removes it
3. Verify restrictions stored as JSON:
   - { "daysOfWeek": ["MO", "TU", "WE", "TH", "FR"] } for weekday
   - { "daysOfWeek": ["SA", "SU"] } for weekend
4. Verify audit logs created for layer operations
</verification>

<success_criteria>
- Layer types with restrictions schema exist
- ScheduleLayerService handles layer CRUD
- Layers support priority ordering (higher = takes precedence)
- Layers support day-of-week restrictions
- API routes enforce RBAC (team admin required)
- Layers can be reordered via /reorder endpoint
</success_criteria>

<output>
After completion, create `.planning/phases/03-scheduling-system/03-03-SUMMARY.md`
</output>

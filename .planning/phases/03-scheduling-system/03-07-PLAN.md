---
phase: 03-scheduling-system
plan: 07
type: tdd
wave: 5
depends_on: ["03-05", "03-06"]
files_modified:
  - src/tests/schedule.test.ts
  - src/tests/oncall.test.ts
  - src/tests/fixtures/dst.ts
autonomous: true

must_haves:
  truths:
    - "System handles DST spring-forward without schedule gaps (SCHED-07)"
    - "System handles DST fall-back without wrong assignments (SCHED-07)"
    - "Tests cover 2025 US DST dates (March 9, November 2)"
    - "Tests verify timezone conversion across distributed teams (SCHED-06)"
  artifacts:
    - path: "src/tests/schedule.test.ts"
      provides: "Schedule CRUD integration tests"
      min_lines: 100
    - path: "src/tests/oncall.test.ts"
      provides: "On-call query tests including DST scenarios"
      min_lines: 150
    - path: "src/tests/fixtures/dst.ts"
      provides: "DST test fixtures and helper functions"
      min_lines: 40
  key_links:
    - from: "src/tests/oncall.test.ts"
      to: "src/services/oncall.service.ts"
      via: "import and service calls"
      pattern: "OnCallService|getCurrentOnCall"
    - from: "src/tests/fixtures/dst.ts"
      to: "luxon"
      via: "DateTime for DST date creation"
      pattern: "DateTime\\.fromISO"
---

<objective>
Create comprehensive test suite for scheduling system with specific focus on DST edge cases that are the #1 pitfall identified in research.

Purpose: Verify correct behavior during DST transitions (spring-forward invalid times, fall-back ambiguous times) and timezone handling across distributed teams (SCHED-06, SCHED-07).

Output: Test fixtures for DST dates, schedule CRUD tests, and on-call query tests covering all edge cases.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scheduling-system/03-RESEARCH.md
@.planning/phases/03-scheduling-system/03-05-SUMMARY.md
@src/tests/setup.ts
@src/services/schedule.service.ts
@src/services/oncall.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DST test fixtures</name>
  <files>src/tests/fixtures/dst.ts</files>
  <action>
Create src/tests/fixtures/dst.ts with DST-specific test helpers:

```typescript
import { DateTime } from 'luxon';

/**
 * DST Test Fixtures
 *
 * US DST 2025:
 * - Spring forward: March 9, 2025 at 2:00 AM -> 3:00 AM
 * - Fall back: November 2, 2025 at 2:00 AM -> 1:00 AM
 *
 * EU DST 2025:
 * - Spring forward: March 30, 2025 at 2:00 AM -> 3:00 AM
 * - Fall back: October 26, 2025 at 3:00 AM -> 2:00 AM
 */

export const DST_DATES = {
  // US (America/New_York)
  US_SPRING_FORWARD_2025: '2025-03-09',
  US_FALL_BACK_2025: '2025-11-02',

  // EU (Europe/London)
  EU_SPRING_FORWARD_2025: '2025-03-30',
  EU_FALL_BACK_2025: '2025-10-26',
} as const;

/**
 * Create a DateTime just before DST spring forward transition
 * In America/New_York, 1:59 AM on March 9 is the last valid time before 3:00 AM
 */
export function getBeforeSpringForward(timezone: string = 'America/New_York'): DateTime {
  const date = timezone.includes('Europe') ? DST_DATES.EU_SPRING_FORWARD_2025 : DST_DATES.US_SPRING_FORWARD_2025;
  return DateTime.fromISO(`${date}T01:59:00`, { zone: timezone });
}

/**
 * Create a DateTime during the "invalid" hour of spring forward
 * This time (2:30 AM) doesn't exist - Luxon will adjust it forward
 */
export function getInvalidSpringForwardTime(timezone: string = 'America/New_York'): DateTime {
  const date = timezone.includes('Europe') ? DST_DATES.EU_SPRING_FORWARD_2025 : DST_DATES.US_SPRING_FORWARD_2025;
  // Note: Luxon automatically adjusts this to 3:30 AM
  return DateTime.fromISO(`${date}T02:30:00`, { zone: timezone });
}

/**
 * Create a DateTime just after DST spring forward transition
 */
export function getAfterSpringForward(timezone: string = 'America/New_York'): DateTime {
  const date = timezone.includes('Europe') ? DST_DATES.EU_SPRING_FORWARD_2025 : DST_DATES.US_SPRING_FORWARD_2025;
  return DateTime.fromISO(`${date}T03:01:00`, { zone: timezone });
}

/**
 * Create a DateTime during the "ambiguous" hour of fall back
 * 1:30 AM occurs twice - once in DST, once in standard time
 */
export function getAmbiguousFallBackTime(timezone: string = 'America/New_York'): DateTime {
  const date = timezone.includes('Europe') ? DST_DATES.EU_FALL_BACK_2025 : DST_DATES.US_FALL_BACK_2025;
  return DateTime.fromISO(`${date}T01:30:00`, { zone: timezone });
}

/**
 * Create a DateTime just before DST fall back transition
 */
export function getBeforeFallBack(timezone: string = 'America/New_York'): DateTime {
  const date = timezone.includes('Europe') ? DST_DATES.EU_FALL_BACK_2025 : DST_DATES.US_FALL_BACK_2025;
  // 1:59 AM in DST (first occurrence)
  return DateTime.fromISO(`${date}T01:59:00`, { zone: timezone });
}

/**
 * Create a DateTime just after DST fall back transition
 */
export function getAfterFallBack(timezone: string = 'America/New_York'): DateTime {
  const date = timezone.includes('Europe') ? DST_DATES.EU_FALL_BACK_2025 : DST_DATES.US_FALL_BACK_2025;
  // 2:01 AM in standard time
  return DateTime.fromISO(`${date}T02:01:00`, { zone: timezone });
}

/**
 * Create schedule test data spanning DST transition
 */
export function createDSTSpanningScheduleData(timezone: string = 'America/New_York') {
  const springDate = timezone.includes('Europe')
    ? DST_DATES.EU_SPRING_FORWARD_2025
    : DST_DATES.US_SPRING_FORWARD_2025;

  return {
    startDate: DateTime.fromISO(`${springDate}T00:00:00`, { zone: timezone })
      .minus({ days: 7 })
      .toISO()!,
    handoffTime: '09:00', // 9 AM handoff - safe time
    timezone,
  };
}

/**
 * Verify two DateTimes represent the same instant
 */
export function sameInstant(a: DateTime, b: DateTime): boolean {
  return a.toUTC().toMillis() === b.toUTC().toMillis();
}
```
  </action>
  <verify>Run `npm run build` - TypeScript should compile without errors</verify>
  <done>DST test fixtures created with helpers for spring-forward and fall-back scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Create schedule CRUD integration tests</name>
  <files>src/tests/schedule.test.ts</files>
  <action>
Create src/tests/schedule.test.ts with comprehensive schedule tests:

```typescript
import { describe, it, expect, beforeAll, beforeEach, afterAll } from 'vitest';
import { prisma } from '../config/database';
import { ScheduleService } from '../services/schedule.service';
import { ScheduleLayerService } from '../services/scheduleLayer.service';
import { ScheduleOverrideService } from '../services/scheduleOverride.service';
import { DateTime } from 'luxon';
import { cleanupTestData, createTestUser, createTestTeam, getAuthenticatedAgent } from './setup';

describe('Schedule System', () => {
  let scheduleService: ScheduleService;
  let layerService: ScheduleLayerService;
  let overrideService: ScheduleOverrideService;
  let testUser: any;
  let testTeam: any;
  let adminUser: any;

  beforeAll(async () => {
    scheduleService = new ScheduleService();
    layerService = new ScheduleLayerService();
    overrideService = new ScheduleOverrideService();
  });

  beforeEach(async () => {
    await cleanupTestData();
    adminUser = await createTestUser({ platformRole: 'PLATFORM_ADMIN' });
    testTeam = await createTestTeam({ name: 'Test Team' });
    testUser = await createTestUser({ email: 'responder@test.com' });

    // Add user to team
    await prisma.teamMember.create({
      data: {
        teamId: testTeam.id,
        userId: testUser.id,
        role: 'RESPONDER',
      },
    });
  });

  afterAll(async () => {
    await cleanupTestData();
  });

  describe('Schedule CRUD', () => {
    it('creates daily rotation schedule with valid RRULE', async () => {
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'Daily On-Call',
        timezone: 'America/New_York',
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'daily',
        rotationUserIds: [testUser.id],
      }, adminUser.id);

      expect(schedule).toBeDefined();
      expect(schedule.recurrenceRule).toContain('FREQ=DAILY');
      expect(schedule.recurrenceRule).toContain('INTERVAL=1');
    });

    it('creates weekly rotation schedule with valid RRULE', async () => {
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'Weekly On-Call',
        timezone: 'America/New_York',
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'weekly',
        rotationUserIds: [testUser.id],
      }, adminUser.id);

      expect(schedule.recurrenceRule).toContain('FREQ=WEEKLY');
    });

    it('creates custom rotation schedule with specified interval', async () => {
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: '2-Week On-Call',
        timezone: 'America/New_York',
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'custom',
        rotationIntervalDays: 14,
        rotationUserIds: [testUser.id],
      }, adminUser.id);

      expect(schedule.recurrenceRule).toContain('INTERVAL=14');
    });

    it('rejects invalid IANA timezone', async () => {
      await expect(scheduleService.create({
        teamId: testTeam.id,
        name: 'Bad Timezone',
        timezone: 'EST', // Invalid - should use America/New_York
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'daily',
        rotationUserIds: [testUser.id],
      }, adminUser.id)).rejects.toThrow(/timezone/i);
    });

    it('rejects user not in team', async () => {
      const outsideUser = await createTestUser({ email: 'outside@test.com' });

      await expect(scheduleService.create({
        teamId: testTeam.id,
        name: 'Bad Rotation',
        timezone: 'America/New_York',
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'daily',
        rotationUserIds: [outsideUser.id], // Not a team member
      }, adminUser.id)).rejects.toThrow(/team member/i);
    });
  });

  describe('Schedule Layers', () => {
    let schedule: any;

    beforeEach(async () => {
      schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'Layered Schedule',
        timezone: 'America/New_York',
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'weekly',
        rotationUserIds: [testUser.id],
      }, adminUser.id);
    });

    it('creates layer with priority', async () => {
      const layer = await layerService.create({
        scheduleId: schedule.id,
        name: 'Primary',
        priority: 100,
        timezone: 'America/New_York',
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'weekly',
        rotationUserIds: [testUser.id],
      }, adminUser.id);

      expect(layer.priority).toBe(100);
    });

    it('creates layer with weekend restrictions', async () => {
      const layer = await layerService.create({
        scheduleId: schedule.id,
        name: 'Weekend',
        priority: 90,
        timezone: 'America/New_York',
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'weekly',
        rotationUserIds: [testUser.id],
        restrictions: { daysOfWeek: ['SA', 'SU'] },
      }, adminUser.id);

      expect(layer.restrictions).toEqual({ daysOfWeek: ['SA', 'SU'] });
    });
  });

  describe('Schedule Overrides', () => {
    let schedule: any;
    let coverUser: any;

    beforeEach(async () => {
      schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'Override Test',
        timezone: 'America/New_York',
        startDate: DateTime.now().toISO()!,
        handoffTime: '09:00',
        rotationType: 'weekly',
        rotationUserIds: [testUser.id],
      }, adminUser.id);

      coverUser = await createTestUser({ email: 'cover@test.com' });
      await prisma.teamMember.create({
        data: {
          teamId: testTeam.id,
          userId: coverUser.id,
          role: 'RESPONDER',
        },
      });
    });

    it('creates override for time range', async () => {
      const startTime = DateTime.now().plus({ days: 1 }).toISO()!;
      const endTime = DateTime.now().plus({ days: 2 }).toISO()!;

      const override = await overrideService.createOverride({
        scheduleId: schedule.id,
        userId: coverUser.id,
        startTime,
        endTime,
        reason: 'Vacation coverage',
      }, adminUser.id);

      expect(override.userId).toBe(coverUser.id);
      expect(override.overrideType).toBe('manual');
    });

    it('rejects overlapping overrides', async () => {
      const startTime = DateTime.now().plus({ days: 1 }).toISO()!;
      const endTime = DateTime.now().plus({ days: 2 }).toISO()!;

      await overrideService.createOverride({
        scheduleId: schedule.id,
        userId: coverUser.id,
        startTime,
        endTime,
      }, adminUser.id);

      // Try to create overlapping override
      await expect(overrideService.createOverride({
        scheduleId: schedule.id,
        userId: testUser.id,
        startTime: DateTime.now().plus({ days: 1, hours: 12 }).toISO()!, // Overlaps
        endTime: DateTime.now().plus({ days: 3 }).toISO()!,
      }, adminUser.id)).rejects.toThrow(/conflict|overlap/i);
    });

    it('creates shift swap with both users', async () => {
      const startTime = DateTime.now().plus({ days: 1 }).toISO()!;
      const endTime = DateTime.now().plus({ days: 2 }).toISO()!;

      const swap = await overrideService.createSwap({
        scheduleId: schedule.id,
        originalUserId: testUser.id,
        newUserId: coverUser.id,
        startTime,
        endTime,
        reason: 'Shift swap',
      }, adminUser.id);

      expect(swap.originalUserId).toBe(testUser.id);
      expect(swap.userId).toBe(coverUser.id);
      expect(swap.overrideType).toBe('swap');
    });
  });
});
```
  </action>
  <verify>Run `npm test src/tests/schedule.test.ts` - tests should pass</verify>
  <done>Schedule CRUD integration tests created covering rotations, layers, and overrides</done>
</task>

<task type="auto">
  <name>Task 3: Create on-call query tests with DST scenarios</name>
  <files>src/tests/oncall.test.ts</files>
  <action>
Create src/tests/oncall.test.ts with on-call query tests including DST edge cases:

```typescript
import { describe, it, expect, beforeAll, beforeEach, afterAll } from 'vitest';
import { prisma } from '../config/database';
import { ScheduleService } from '../services/schedule.service';
import { OnCallService } from '../services/oncall.service';
import { ScheduleOverrideService } from '../services/scheduleOverride.service';
import { DateTime } from 'luxon';
import {
  DST_DATES,
  getBeforeSpringForward,
  getAfterSpringForward,
  getInvalidSpringForwardTime,
  getAmbiguousFallBackTime,
  createDSTSpanningScheduleData,
} from './fixtures/dst';
import { cleanupTestData, createTestUser, createTestTeam } from './setup';

describe('On-Call Service', () => {
  let onCallService: OnCallService;
  let scheduleService: ScheduleService;
  let overrideService: ScheduleOverrideService;
  let testTeam: any;
  let users: any[];
  let adminUser: any;

  beforeAll(async () => {
    onCallService = new OnCallService();
    scheduleService = new ScheduleService();
    overrideService = new ScheduleOverrideService();
  });

  beforeEach(async () => {
    await cleanupTestData();
    adminUser = await createTestUser({ platformRole: 'PLATFORM_ADMIN' });
    testTeam = await createTestTeam({ name: 'On-Call Team' });

    // Create 3 users for rotation testing
    users = await Promise.all([
      createTestUser({ email: 'user1@test.com', firstName: 'Alice' }),
      createTestUser({ email: 'user2@test.com', firstName: 'Bob' }),
      createTestUser({ email: 'user3@test.com', firstName: 'Charlie' }),
    ]);

    // Add all users to team
    for (const user of users) {
      await prisma.teamMember.create({
        data: {
          teamId: testTeam.id,
          userId: user.id,
          role: 'RESPONDER',
        },
      });
    }
  });

  afterAll(async () => {
    await cleanupTestData();
  });

  describe('Basic On-Call Queries', () => {
    it('returns current on-call from schedule', async () => {
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'Basic Schedule',
        timezone: 'America/New_York',
        startDate: DateTime.now().minus({ weeks: 1 }).toISO()!,
        handoffTime: '09:00',
        rotationType: 'weekly',
        rotationUserIds: users.map(u => u.id),
      }, adminUser.id);

      const result = await onCallService.getCurrentOnCall({ scheduleId: schedule.id });

      expect(result).toBeDefined();
      expect(result!.user).toBeDefined();
      expect(result!.source).toBe('schedule');
    });

    it('override takes precedence over schedule', async () => {
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'Override Test',
        timezone: 'America/New_York',
        startDate: DateTime.now().minus({ weeks: 1 }).toISO()!,
        handoffTime: '09:00',
        rotationType: 'weekly',
        rotationUserIds: [users[0].id],
      }, adminUser.id);

      // Create override for different user covering now
      await overrideService.createOverride({
        scheduleId: schedule.id,
        userId: users[1].id,
        startTime: DateTime.now().minus({ hours: 1 }).toISO()!,
        endTime: DateTime.now().plus({ hours: 1 }).toISO()!,
        reason: 'Test override',
      }, adminUser.id);

      const result = await onCallService.getCurrentOnCall({ scheduleId: schedule.id });

      expect(result!.source).toBe('override');
      expect(result!.user.id).toBe(users[1].id);
    });

    it('returns correct user based on rotation position', async () => {
      // Create schedule that started 2 weeks ago with weekly rotation
      const startDate = DateTime.now().minus({ weeks: 2 });

      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'Rotation Test',
        timezone: 'UTC',
        startDate: startDate.toISO()!,
        handoffTime: '00:00',
        rotationType: 'weekly',
        rotationUserIds: users.map(u => u.id), // Alice, Bob, Charlie
      }, adminUser.id);

      // Week 0: Alice, Week 1: Bob, Week 2: Charlie
      // We're now in week 2
      const result = await onCallService.getCurrentOnCall({ scheduleId: schedule.id });

      expect(result!.user.id).toBe(users[2].id); // Charlie
    });
  });

  describe('DST Spring Forward (March 9, 2025)', () => {
    it('handles query at 2:30 AM which does not exist', async () => {
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'DST Spring Forward Test',
        timezone: 'America/New_York',
        ...createDSTSpanningScheduleData('America/New_York'),
        rotationType: 'daily',
        rotationUserIds: users.map(u => u.id),
      }, adminUser.id);

      // Query at 2:30 AM on March 9 - this time doesn't exist
      // Luxon will adjust to 3:30 AM automatically
      const invalidTime = getInvalidSpringForwardTime('America/New_York');

      const result = await onCallService.getCurrentOnCall({
        scheduleId: schedule.id,
        at: invalidTime.toJSDate(),
      });

      // Should still return a valid on-call user
      expect(result).toBeDefined();
      expect(result!.user).toBeDefined();
    });

    it('handles handoff scheduled at 2:00 AM during spring forward', async () => {
      // Schedule with 2 AM handoff - this time doesn't exist on March 9
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: '2AM Handoff DST Test',
        timezone: 'America/New_York',
        startDate: DateTime.fromISO(`${DST_DATES.US_SPRING_FORWARD_2025}T00:00:00`, {
          zone: 'America/New_York'
        }).minus({ days: 7 }).toISO()!,
        handoffTime: '02:00', // This time doesn't exist on DST day
        rotationType: 'daily',
        rotationUserIds: users.map(u => u.id),
      }, adminUser.id);

      // Query just before 2 AM
      const beforeResult = await onCallService.getCurrentOnCall({
        scheduleId: schedule.id,
        at: getBeforeSpringForward('America/New_York').toJSDate(),
      });

      // Query just after 3 AM
      const afterResult = await onCallService.getCurrentOnCall({
        scheduleId: schedule.id,
        at: getAfterSpringForward('America/New_York').toJSDate(),
      });

      // Both should return valid users (may or may not be same depending on handoff)
      expect(beforeResult).toBeDefined();
      expect(afterResult).toBeDefined();
    });
  });

  describe('DST Fall Back (November 2, 2025)', () => {
    it('handles query at ambiguous 1:30 AM', async () => {
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'DST Fall Back Test',
        timezone: 'America/New_York',
        startDate: DateTime.fromISO(`${DST_DATES.US_FALL_BACK_2025}T00:00:00`, {
          zone: 'America/New_York'
        }).minus({ days: 7 }).toISO()!,
        handoffTime: '09:00',
        rotationType: 'daily',
        rotationUserIds: users.map(u => u.id),
      }, adminUser.id);

      // Query at 1:30 AM which occurs twice
      const ambiguousTime = getAmbiguousFallBackTime('America/New_York');

      const result = await onCallService.getCurrentOnCall({
        scheduleId: schedule.id,
        at: ambiguousTime.toJSDate(),
      });

      // Should return consistent result
      expect(result).toBeDefined();
      expect(result!.user).toBeDefined();
    });
  });

  describe('Timezone Handling', () => {
    it('handles distributed team across timezones', async () => {
      // Schedule in NYC timezone
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'NYC Schedule',
        timezone: 'America/New_York',
        startDate: DateTime.now().minus({ weeks: 1 }).toISO()!,
        handoffTime: '09:00', // 9 AM NYC
        rotationType: 'daily',
        rotationUserIds: users.map(u => u.id),
      }, adminUser.id);

      // Query at 9 AM NYC time
      const nycMorning = DateTime.now().setZone('America/New_York').set({ hour: 9, minute: 0 });

      // Query at same instant from London perspective
      const londonTime = nycMorning.setZone('Europe/London');

      const nycResult = await onCallService.getCurrentOnCall({
        scheduleId: schedule.id,
        at: nycMorning.toJSDate(),
      });

      const londonResult = await onCallService.getCurrentOnCall({
        scheduleId: schedule.id,
        at: londonTime.toJSDate(),
      });

      // Same instant should return same user regardless of query timezone
      expect(nycResult!.user.id).toBe(londonResult!.user.id);
    });

    it('stores and queries in UTC correctly', async () => {
      const schedule = await scheduleService.create({
        teamId: testTeam.id,
        name: 'UTC Test',
        timezone: 'America/Los_Angeles', // PST/PDT
        startDate: DateTime.now().minus({ weeks: 1 }).toISO()!,
        handoffTime: '09:00',
        rotationType: 'weekly',
        rotationUserIds: users.map(u => u.id),
      }, adminUser.id);

      // Verify database stores UTC
      const dbSchedule = await prisma.schedule.findUnique({
        where: { id: schedule.id },
      });

      // startDate should be stored as UTC in database
      expect(dbSchedule!.startDate).toBeInstanceOf(Date);

      // Query should work regardless
      const result = await onCallService.getCurrentOnCall({ scheduleId: schedule.id });
      expect(result).toBeDefined();
    });
  });

  describe('Edge Cases', () => {
    it('handles empty schedule gracefully', async () => {
      const result = await onCallService.getCurrentOnCall({
        scheduleId: 'nonexistent-id',
      });

      expect(result).toBeNull();
    });

    it('returns null when no schedule matches team', async () => {
      const result = await onCallService.getOnCallForTeam('nonexistent-team-id');

      expect(result).toEqual([]);
    });
  });
});
```
  </action>
  <verify>Run `npm test src/tests/oncall.test.ts` - tests should pass</verify>
  <done>On-call query tests created with DST edge cases for spring-forward and fall-back scenarios</done>
</task>

</tasks>

<verification>
1. Run `npm test` - all tests should pass
2. Verify DST test fixtures create correct dates:
   - getInvalidSpringForwardTime returns 3:30 AM (adjusted from 2:30 AM)
   - getAmbiguousFallBackTime returns valid DateTime
3. Verify schedule tests cover:
   - Daily, weekly, custom rotations
   - Invalid timezone rejection
   - Non-team-member rejection
   - Layer creation with restrictions
   - Override conflict detection
   - Shift swap creation
4. Verify on-call tests cover:
   - Basic schedule query
   - Override precedence
   - Rotation position calculation
   - DST spring-forward handling
   - DST fall-back handling
   - Cross-timezone queries
</verification>

<success_criteria>
- DST test fixtures provide helpers for all scenarios
- Schedule CRUD tests pass for all rotation types
- Layer and override tests verify business logic
- On-call tests demonstrate correct DST handling
- Tests verify timezone conversion works across distributed teams
- All tests pass: `npm test` exits with 0
</success_criteria>

<output>
After completion, create `.planning/phases/03-scheduling-system/03-07-SUMMARY.md`
</output>

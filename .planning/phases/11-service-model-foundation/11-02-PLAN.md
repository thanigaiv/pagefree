---
phase: 11-service-model-foundation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - frontend/src/types/service.ts
  - frontend/src/hooks/useServices.ts
  - frontend/src/pages/ServicesPage.tsx
  - frontend/src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can browse service directory from the UI"
    - "User can filter services by team, status, or search term"
    - "User can create a new service via dialog"
    - "User can edit service metadata via dialog"
    - "User can change service status (archive/deprecate) via UI"
  artifacts:
    - path: "frontend/src/types/service.ts"
      provides: "TypeScript types for Service frontend"
      exports: ["Service", "ServiceStatus", "CreateServiceInput", "UpdateServiceInput"]
    - path: "frontend/src/hooks/useServices.ts"
      provides: "React Query hooks for Service CRUD"
      exports: ["useServices", "useService", "useCreateService", "useUpdateService", "useUpdateServiceStatus"]
    - path: "frontend/src/pages/ServicesPage.tsx"
      provides: "Service directory page with filtering and CRUD dialogs"
      min_lines: 200
  key_links:
    - from: "frontend/src/pages/ServicesPage.tsx"
      to: "frontend/src/hooks/useServices.ts"
      via: "Hook imports and calls"
      pattern: "use(Services|CreateService|UpdateService)"
    - from: "frontend/src/hooks/useServices.ts"
      to: "/api/services"
      via: "apiFetch calls"
      pattern: "apiFetch.*'/services"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/pages/ServicesPage.tsx"
      via: "Route registration"
      pattern: "Route.*services.*ServicesPage"
---

<objective>
Create the Service directory frontend with full CRUD capabilities, enabling users to browse, search, filter, create, edit, and manage service lifecycle states through a consistent UI.

Purpose: Provides the user interface for service management, completing the Service Model Foundation feature.

Output: React Query hooks, TypeScript types, and ServicesPage component with filtering and CRUD dialogs.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-service-model-foundation/11-RESEARCH.md
@.planning/phases/11-service-model-foundation/11-01-SUMMARY.md

# Existing patterns to follow
@frontend/src/hooks/usePostmortems.ts
@frontend/src/hooks/useTeams.ts
@frontend/src/pages/TeamsAdminPage.tsx
@frontend/src/types/postmortem.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Service frontend types and React Query hooks</name>
  <files>frontend/src/types/service.ts, frontend/src/hooks/useServices.ts</files>
  <action>
1. Create frontend/src/types/service.ts:

```typescript
// Service status enum matching backend
export type ServiceStatus = 'ACTIVE' | 'DEPRECATED' | 'ARCHIVED';

// Service with related entities
export interface Service {
  id: string;
  name: string;
  description: string | null;
  routingKey: string;
  teamId: string;
  team: {
    id: string;
    name: string;
  };
  escalationPolicyId: string | null;
  escalationPolicy: {
    id: string;
    name: string;
  } | null;
  status: ServiceStatus;
  tags: string[];
  createdAt: string;
  updatedAt: string;
}

// Input types for mutations
export interface CreateServiceInput {
  name: string;
  description?: string;
  routingKey: string;
  teamId: string;
  escalationPolicyId?: string;
  tags?: string[];
}

export interface UpdateServiceInput {
  name?: string;
  description?: string;
  tags?: string[];
  escalationPolicyId?: string | null;
}

export interface UpdateServiceStatusInput {
  status: ServiceStatus;
}

// API response types
export interface ServiceListResponse {
  services: Service[];
  total: number;
}

export interface ServiceResponse {
  service: Service;
}
```

2. Create frontend/src/hooks/useServices.ts following usePostmortems.ts pattern:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { apiFetch } from '@/lib/api';
import type {
  Service,
  ServiceStatus,
  CreateServiceInput,
  UpdateServiceInput,
  UpdateServiceStatusInput,
  ServiceListResponse,
  ServiceResponse
} from '@/types/service';

// =============================================================================
// QUERY HOOKS
// =============================================================================

/**
 * Fetch services with optional filters (SVC-04)
 */
export function useServices(params?: {
  teamId?: string;
  status?: ServiceStatus;
  search?: string;
}) {
  return useQuery({
    queryKey: ['services', params],
    queryFn: async () => {
      const query = new URLSearchParams();
      if (params?.teamId) query.set('teamId', params.teamId);
      if (params?.status) query.set('status', params.status);
      if (params?.search) query.set('search', params.search);
      const queryString = query.toString();
      const response = await apiFetch<ServiceListResponse>(
        `/services${queryString ? `?${queryString}` : ''}`
      );
      return response;
    }
  });
}

/**
 * Fetch a single service by ID
 */
export function useService(id: string | undefined) {
  return useQuery({
    queryKey: ['service', id],
    queryFn: async () => {
      const response = await apiFetch<ServiceResponse>(`/services/${id}`);
      return response.service;
    },
    enabled: !!id
  });
}

// =============================================================================
// MUTATION HOOKS
// =============================================================================

/**
 * Create a new service (SVC-01)
 */
export function useCreateService() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreateServiceInput) =>
      apiFetch<ServiceResponse>('/services', {
        method: 'POST',
        body: JSON.stringify(data)
      }).then(res => res.service),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['services'] });
    }
  });
}

/**
 * Update service metadata (SVC-02)
 */
export function useUpdateService() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateServiceInput }) =>
      apiFetch<ServiceResponse>(`/services/${id}`, {
        method: 'PATCH',
        body: JSON.stringify(data)
      }).then(res => res.service),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['service', id] });
      queryClient.invalidateQueries({ queryKey: ['services'] });
    }
  });
}

/**
 * Update service status (SVC-03: archive/deprecate)
 */
export function useUpdateServiceStatus() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateServiceStatusInput }) =>
      apiFetch<ServiceResponse>(`/services/${id}/status`, {
        method: 'PATCH',
        body: JSON.stringify(data)
      }).then(res => res.service),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['service', id] });
      queryClient.invalidateQueries({ queryKey: ['services'] });
    }
  });
}

// =============================================================================
// RE-EXPORTS FOR CONVENIENCE
// =============================================================================

export type {
  Service,
  ServiceStatus,
  CreateServiceInput,
  UpdateServiceInput,
  UpdateServiceStatusInput
} from '@/types/service';
```
  </action>
  <verify>
Run: `cd frontend && npx tsc --noEmit`
Verify: No TypeScript errors in service.ts or useServices.ts
  </verify>
  <done>
Frontend types defined for Service. React Query hooks created: useServices (list with filters), useService (single), useCreateService, useUpdateService, useUpdateServiceStatus.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ServicesPage component with filtering and CRUD dialogs</name>
  <files>frontend/src/pages/ServicesPage.tsx</files>
  <action>
Create frontend/src/pages/ServicesPage.tsx following TeamsAdminPage.tsx pattern:

```typescript
import { useState } from 'react';
import { useServices, useCreateService, useUpdateService, useUpdateServiceStatus } from '@/hooks/useServices';
import { useTeams } from '@/hooks/useTeams';
import type { Service, ServiceStatus, CreateServiceInput, UpdateServiceInput } from '@/types/service';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Server, Plus, MoreVertical, Edit, Archive, AlertTriangle, RotateCcw, Loader2, Search } from 'lucide-react';
import { toast } from 'sonner';

const STATUS_OPTIONS: { value: ServiceStatus | 'ALL'; label: string }[] = [
  { value: 'ALL', label: 'All Statuses' },
  { value: 'ACTIVE', label: 'Active' },
  { value: 'DEPRECATED', label: 'Deprecated' },
  { value: 'ARCHIVED', label: 'Archived' },
];

const STATUS_BADGE_VARIANT: Record<ServiceStatus, 'default' | 'secondary' | 'destructive' | 'outline'> = {
  ACTIVE: 'default',
  DEPRECATED: 'secondary',
  ARCHIVED: 'outline',
};

export default function ServicesPage() {
  const { data: teamsData } = useTeams();
  const teams = teamsData?.teams || [];

  // Filter state
  const [search, setSearch] = useState('');
  const [statusFilter, setStatusFilter] = useState<ServiceStatus | 'ALL'>('ACTIVE');
  const [teamFilter, setTeamFilter] = useState<string>('ALL');

  // Query with filters
  const { data, isLoading, error } = useServices({
    search: search || undefined,
    status: statusFilter === 'ALL' ? undefined : statusFilter,
    teamId: teamFilter === 'ALL' ? undefined : teamFilter,
  });

  // Mutations
  const createMutation = useCreateService();
  const updateMutation = useUpdateService();
  const statusMutation = useUpdateServiceStatus();

  // Dialog state
  const [isCreateOpen, setIsCreateOpen] = useState(false);
  const [isEditOpen, setIsEditOpen] = useState(false);
  const [isStatusOpen, setIsStatusOpen] = useState(false);
  const [selectedService, setSelectedService] = useState<Service | null>(null);
  const [pendingStatus, setPendingStatus] = useState<ServiceStatus | null>(null);

  // Form state
  const [formData, setFormData] = useState<CreateServiceInput>({
    name: '',
    description: '',
    routingKey: '',
    teamId: '',
    tags: [],
  });
  const [tagsInput, setTagsInput] = useState('');

  const resetForm = () => {
    setFormData({ name: '', description: '', routingKey: '', teamId: '', tags: [] });
    setTagsInput('');
  };

  const handleCreate = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.name.trim()) {
      toast.error('Service name is required');
      return;
    }
    if (!formData.routingKey.trim()) {
      toast.error('Routing key is required');
      return;
    }
    if (!formData.teamId) {
      toast.error('Owning team is required');
      return;
    }

    try {
      const tags = tagsInput.split(',').map(t => t.trim()).filter(Boolean);
      await createMutation.mutateAsync({
        ...formData,
        tags: tags.length > 0 ? tags : undefined,
      });
      toast.success('Service created successfully');
      setIsCreateOpen(false);
      resetForm();
    } catch (error: any) {
      if (error?.message?.includes('Routing key already exists')) {
        toast.error('Routing key already exists');
      } else {
        toast.error(error?.message || 'Failed to create service');
      }
    }
  };

  const handleEdit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!selectedService) return;

    try {
      const tags = tagsInput.split(',').map(t => t.trim()).filter(Boolean);
      await updateMutation.mutateAsync({
        id: selectedService.id,
        data: {
          name: formData.name,
          description: formData.description || undefined,
          tags: tags.length > 0 ? tags : [],
        },
      });
      toast.success('Service updated successfully');
      setIsEditOpen(false);
      setSelectedService(null);
      resetForm();
    } catch (error: any) {
      toast.error(error?.message || 'Failed to update service');
    }
  };

  const handleStatusChange = async () => {
    if (!selectedService || !pendingStatus) return;

    try {
      await statusMutation.mutateAsync({
        id: selectedService.id,
        data: { status: pendingStatus },
      });
      const action = pendingStatus === 'ARCHIVED' ? 'archived' :
                     pendingStatus === 'DEPRECATED' ? 'deprecated' : 'reactivated';
      toast.success(`Service ${action} successfully`);
      setIsStatusOpen(false);
      setSelectedService(null);
      setPendingStatus(null);
    } catch (error: any) {
      toast.error(error?.message || 'Failed to update service status');
    }
  };

  const openEditDialog = (service: Service) => {
    setSelectedService(service);
    setFormData({
      name: service.name,
      description: service.description || '',
      routingKey: service.routingKey,
      teamId: service.teamId,
      tags: service.tags,
    });
    setTagsInput(service.tags.join(', '));
    setIsEditOpen(true);
  };

  const openStatusDialog = (service: Service, status: ServiceStatus) => {
    setSelectedService(service);
    setPendingStatus(status);
    setIsStatusOpen(true);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto p-6">
        <div className="text-red-500">Error loading services</div>
      </div>
    );
  }

  const services = data?.services || [];

  return (
    <div className="container mx-auto p-6 max-w-6xl">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div>
          <h1 className="text-2xl font-bold">Service Directory</h1>
          <p className="text-muted-foreground mt-1">
            Manage technical services and their routing
          </p>
        </div>
        <Button onClick={() => setIsCreateOpen(true)}>
          <Plus className="mr-2 h-4 w-4" /> Create Service
        </Button>
      </div>

      {/* Filters */}
      <div className="flex flex-col sm:flex-row gap-4 mb-6">
        <div className="relative flex-1 max-w-sm">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search services..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="pl-9"
          />
        </div>
        <Select value={statusFilter} onValueChange={(v) => setStatusFilter(v as ServiceStatus | 'ALL')}>
          <SelectTrigger className="w-[160px]">
            <SelectValue placeholder="Status" />
          </SelectTrigger>
          <SelectContent>
            {STATUS_OPTIONS.map(opt => (
              <SelectItem key={opt.value} value={opt.value}>{opt.label}</SelectItem>
            ))}
          </SelectContent>
        </Select>
        <Select value={teamFilter} onValueChange={setTeamFilter}>
          <SelectTrigger className="w-[200px]">
            <SelectValue placeholder="Team" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="ALL">All Teams</SelectItem>
            {teams.map(team => (
              <SelectItem key={team.id} value={team.id}>{team.name}</SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Service Grid */}
      {services.length === 0 ? (
        <Card>
          <CardContent className="flex flex-col items-center justify-center py-12">
            <Server className="h-12 w-12 text-muted-foreground mb-4" />
            <h3 className="text-lg font-medium mb-2">No services found</h3>
            <p className="text-muted-foreground text-center mb-4">
              {search || statusFilter !== 'ACTIVE' || teamFilter !== 'ALL'
                ? 'Try adjusting your filters'
                : 'Create your first service to get started'}
            </p>
            {!search && statusFilter === 'ACTIVE' && teamFilter === 'ALL' && (
              <Button onClick={() => setIsCreateOpen(true)}>
                <Plus className="mr-2 h-4 w-4" /> Create Service
              </Button>
            )}
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {services.map(service => (
            <Card key={service.id} className={service.status === 'ARCHIVED' ? 'opacity-60' : ''}>
              <CardHeader className="pb-2">
                <div className="flex items-start justify-between">
                  <div className="flex-1 min-w-0">
                    <CardTitle className="text-lg truncate">{service.name}</CardTitle>
                    <CardDescription className="truncate">
                      {service.team.name}
                    </CardDescription>
                  </div>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="icon" className="h-8 w-8">
                        <MoreVertical className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem onClick={() => openEditDialog(service)}>
                        <Edit className="mr-2 h-4 w-4" /> Edit
                      </DropdownMenuItem>
                      <DropdownMenuSeparator />
                      {service.status === 'ACTIVE' && (
                        <>
                          <DropdownMenuItem onClick={() => openStatusDialog(service, 'DEPRECATED')}>
                            <AlertTriangle className="mr-2 h-4 w-4" /> Deprecate
                          </DropdownMenuItem>
                          <DropdownMenuItem
                            onClick={() => openStatusDialog(service, 'ARCHIVED')}
                            className="text-destructive"
                          >
                            <Archive className="mr-2 h-4 w-4" /> Archive
                          </DropdownMenuItem>
                        </>
                      )}
                      {service.status === 'DEPRECATED' && (
                        <>
                          <DropdownMenuItem onClick={() => openStatusDialog(service, 'ACTIVE')}>
                            <RotateCcw className="mr-2 h-4 w-4" /> Reactivate
                          </DropdownMenuItem>
                          <DropdownMenuItem
                            onClick={() => openStatusDialog(service, 'ARCHIVED')}
                            className="text-destructive"
                          >
                            <Archive className="mr-2 h-4 w-4" /> Archive
                          </DropdownMenuItem>
                        </>
                      )}
                      {service.status === 'ARCHIVED' && (
                        <DropdownMenuItem onClick={() => openStatusDialog(service, 'ACTIVE')}>
                          <RotateCcw className="mr-2 h-4 w-4" /> Reactivate
                        </DropdownMenuItem>
                      )}
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-2">
                  <div className="flex items-center gap-2">
                    <Badge variant={STATUS_BADGE_VARIANT[service.status]}>
                      {service.status}
                    </Badge>
                    {service.escalationPolicy && (
                      <Badge variant="outline" className="truncate max-w-[120px]">
                        {service.escalationPolicy.name}
                      </Badge>
                    )}
                  </div>
                  <p className="text-sm text-muted-foreground line-clamp-2">
                    {service.description || 'No description'}
                  </p>
                  <p className="text-xs font-mono text-muted-foreground truncate">
                    {service.routingKey}
                  </p>
                  {service.tags.length > 0 && (
                    <div className="flex flex-wrap gap-1">
                      {service.tags.slice(0, 3).map(tag => (
                        <Badge key={tag} variant="secondary" className="text-xs">
                          {tag}
                        </Badge>
                      ))}
                      {service.tags.length > 3 && (
                        <Badge variant="secondary" className="text-xs">
                          +{service.tags.length - 3}
                        </Badge>
                      )}
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      {/* Create Dialog */}
      <Dialog open={isCreateOpen} onOpenChange={setIsCreateOpen}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>Create Service</DialogTitle>
            <DialogDescription>
              Add a new technical service to the directory
            </DialogDescription>
          </DialogHeader>
          <form onSubmit={handleCreate} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="name">Name *</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                placeholder="Payment Gateway"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="routingKey">Routing Key *</Label>
              <Input
                id="routingKey"
                value={formData.routingKey}
                onChange={(e) => setFormData({ ...formData, routingKey: e.target.value })}
                placeholder="payment-gateway"
                className="font-mono"
              />
              <p className="text-xs text-muted-foreground">
                Alphanumeric, hyphens, and underscores only
              </p>
            </div>
            <div className="space-y-2">
              <Label htmlFor="teamId">Owning Team *</Label>
              <Select
                value={formData.teamId}
                onValueChange={(v) => setFormData({ ...formData, teamId: v })}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Select team" />
                </SelectTrigger>
                <SelectContent>
                  {teams.map(team => (
                    <SelectItem key={team.id} value={team.id}>{team.name}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={formData.description || ''}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                placeholder="Handles all payment processing..."
                rows={3}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="tags">Tags</Label>
              <Input
                id="tags"
                value={tagsInput}
                onChange={(e) => setTagsInput(e.target.value)}
                placeholder="payments, critical, tier-1"
              />
              <p className="text-xs text-muted-foreground">
                Comma-separated tags
              </p>
            </div>
            <div className="flex justify-end gap-2 pt-4">
              <Button type="button" variant="outline" onClick={() => { setIsCreateOpen(false); resetForm(); }}>
                Cancel
              </Button>
              <Button type="submit" disabled={createMutation.isPending}>
                {createMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Create
              </Button>
            </div>
          </form>
        </DialogContent>
      </Dialog>

      {/* Edit Dialog */}
      <Dialog open={isEditOpen} onOpenChange={setIsEditOpen}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>Edit Service</DialogTitle>
            <DialogDescription>
              Update service metadata
            </DialogDescription>
          </DialogHeader>
          <form onSubmit={handleEdit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="edit-name">Name *</Label>
              <Input
                id="edit-name"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
              />
            </div>
            <div className="space-y-2">
              <Label>Routing Key</Label>
              <Input
                value={selectedService?.routingKey || ''}
                disabled
                className="font-mono opacity-50"
              />
              <p className="text-xs text-muted-foreground">
                Routing key cannot be changed after creation
              </p>
            </div>
            <div className="space-y-2">
              <Label htmlFor="edit-description">Description</Label>
              <Textarea
                id="edit-description"
                value={formData.description || ''}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                rows={3}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="edit-tags">Tags</Label>
              <Input
                id="edit-tags"
                value={tagsInput}
                onChange={(e) => setTagsInput(e.target.value)}
                placeholder="payments, critical, tier-1"
              />
            </div>
            <div className="flex justify-end gap-2 pt-4">
              <Button type="button" variant="outline" onClick={() => { setIsEditOpen(false); setSelectedService(null); resetForm(); }}>
                Cancel
              </Button>
              <Button type="submit" disabled={updateMutation.isPending}>
                {updateMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Save
              </Button>
            </div>
          </form>
        </DialogContent>
      </Dialog>

      {/* Status Change Confirmation Dialog */}
      <AlertDialog open={isStatusOpen} onOpenChange={setIsStatusOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>
              {pendingStatus === 'ARCHIVED' && 'Archive Service'}
              {pendingStatus === 'DEPRECATED' && 'Deprecate Service'}
              {pendingStatus === 'ACTIVE' && 'Reactivate Service'}
            </AlertDialogTitle>
            <AlertDialogDescription>
              {pendingStatus === 'ARCHIVED' && (
                <>
                  Are you sure you want to archive <strong>{selectedService?.name}</strong>?
                  Archived services are hidden from default views but can be reactivated later.
                </>
              )}
              {pendingStatus === 'DEPRECATED' && (
                <>
                  Are you sure you want to deprecate <strong>{selectedService?.name}</strong>?
                  Deprecated services remain visible but indicate planned removal.
                </>
              )}
              {pendingStatus === 'ACTIVE' && (
                <>
                  Reactivate <strong>{selectedService?.name}</strong>?
                  The service will be restored to active status.
                </>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => { setSelectedService(null); setPendingStatus(null); }}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleStatusChange}
              className={pendingStatus === 'ARCHIVED' ? 'bg-destructive hover:bg-destructive/90' : ''}
            >
              {statusMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              {pendingStatus === 'ARCHIVED' && 'Archive'}
              {pendingStatus === 'DEPRECATED' && 'Deprecate'}
              {pendingStatus === 'ACTIVE' && 'Reactivate'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```
  </action>
  <verify>
Run: `cd frontend && npx tsc --noEmit`
Verify: No TypeScript errors in ServicesPage.tsx
  </verify>
  <done>
ServicesPage component created with: search/filter bar (search, status, team filters), service cards grid showing name/team/status/routing key/tags, create dialog with required fields (name, routingKey, teamId), edit dialog for metadata updates, status change confirmation dialog for archive/deprecate/reactivate.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register ServicesPage route in App.tsx</name>
  <files>frontend/src/App.tsx</files>
  <action>
Update frontend/src/App.tsx to add the services route:

1. Add import at top with other page imports (around line 19):
```typescript
import ServicesPage from './pages/ServicesPage';
```

2. Add route inside the MobileLayout Routes block, in the admin routes section (around line 48, after escalation-policies route):
```typescript
<Route path="/admin/services" element={<ServicesPage />} />
```

The route should be placed alongside other admin routes for consistency.
  </action>
  <verify>
Run: `cd frontend && npm run build`
Verify: Build succeeds, no errors

Manual verification: Navigate to /admin/services in browser
  </verify>
  <done>
Services route registered at /admin/services in App.tsx. ServicesPage component accessible from the admin section.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compiles:
   - `cd frontend && npx tsc --noEmit` succeeds

2. Frontend builds:
   - `cd frontend && npm run build` succeeds

3. Page accessible:
   - Navigate to /admin/services in browser
   - Page loads without errors
   - Can see filter controls and empty state or service cards

4. CRUD works:
   - Create service with required fields succeeds
   - Edit service metadata succeeds
   - Status changes (deprecate/archive/reactivate) succeed
   - Filters work (search, status, team)
</verification>

<success_criteria>
- ServicesPage accessible at /admin/services route
- Service directory shows services with team, status, routing key, and tags
- Search filter filters by service name (case insensitive)
- Status filter shows ACTIVE by default, can filter to DEPRECATED, ARCHIVED, or ALL
- Team filter limits results to services owned by selected team
- Create dialog enforces required fields (name, routingKey, teamId) and shows clear error messages
- Edit dialog allows updating name, description, and tags (routing key disabled)
- Status change dialogs confirm action before proceeding
- Loading and empty states displayed appropriately
- Toast notifications show success/error feedback
</success_criteria>

<output>
After completion, create `.planning/phases/11-service-model-foundation/11-02-SUMMARY.md`
</output>

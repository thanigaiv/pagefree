---
phase: 11-service-model-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/types/service.ts
  - src/services/service.service.ts
  - src/routes/service.routes.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Service model exists in database with all required fields"
    - "Services can be created with required team ownership"
    - "Services can be listed, filtered, and searched"
    - "Service metadata can be updated after creation"
    - "Services can be archived or deprecated via status change"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Service model and ServiceStatus enum"
      contains: "model Service"
    - path: "src/types/service.ts"
      provides: "TypeScript interfaces for Service CRUD"
      exports: ["Service", "ServiceWithTeam", "CreateServiceInput", "UpdateServiceInput"]
    - path: "src/services/service.service.ts"
      provides: "Business logic for Service CRUD with audit logging"
      exports: ["serviceService"]
    - path: "src/routes/service.routes.ts"
      provides: "REST endpoints for Service management"
      exports: ["serviceRouter"]
  key_links:
    - from: "src/routes/service.routes.ts"
      to: "src/services/service.service.ts"
      via: "serviceService method calls"
      pattern: "serviceService\\.(create|list|get|update|updateStatus)"
    - from: "src/services/service.service.ts"
      to: "prisma/schema.prisma"
      via: "Prisma client queries"
      pattern: "prisma\\.service\\.(create|findMany|findUnique|update)"
    - from: "src/index.ts"
      to: "src/routes/service.routes.ts"
      via: "Express router registration"
      pattern: "app\\.use\\('/api/services'"
---

<objective>
Create the Service model backend with complete CRUD operations, enabling service management with team ownership, lifecycle states, and optional escalation policy overrides.

Purpose: Foundation for service-based alert routing (Phase 13). Services represent technical components that teams own and receive alerts for.

Output: Prisma schema, TypeScript types, service layer, and REST API for Service CRUD operations.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-service-model-foundation/11-RESEARCH.md

# Existing patterns to follow
@prisma/schema.prisma
@src/services/team.service.ts
@src/routes/team.routes.ts
@src/types/team.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Service model and ServiceStatus enum to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add ServiceStatus enum and Service model to schema.prisma following existing patterns.

1. Add enum after existing enums (before User model):
```prisma
enum ServiceStatus {
  ACTIVE       // Normal operating state
  DEPRECATED   // Soft notice: will be removed
  ARCHIVED     // Inactive, hidden from default views
}
```

2. Add Service model after Team models section (before Notification models):
```prisma
// ============================================================================
// SERVICE MODEL (Phase 11)
// ============================================================================

model Service {
  id                  String        @id @default(cuid())
  name                String
  description         String?
  routingKey          String        @unique  // For alert routing (Phase 13)

  // Ownership (required per SVC-05)
  teamId              String
  team                Team          @relation(fields: [teamId], references: [id])

  // Optional escalation override (SVC-06)
  escalationPolicyId  String?
  escalationPolicy    EscalationPolicy? @relation(fields: [escalationPolicyId], references: [id])

  // Lifecycle (SVC-03)
  status              ServiceStatus @default(ACTIVE)

  // Metadata (SVC-02)
  tags                String[]      @default([])

  createdAt           DateTime      @default(now()) @db.Timestamptz
  updatedAt           DateTime      @updatedAt @db.Timestamptz

  @@index([teamId])
  @@index([status])
  @@index([routingKey])
  @@index([name])
}
```

3. Add relation to Team model (add to existing relations):
```prisma
services           Service[]
```

4. Add relation to EscalationPolicy model (add to existing relations):
```prisma
services  Service[]
```

Run `npx prisma db push` after changes.
  </action>
  <verify>
Run: `npx prisma db push --skip-generate && npx prisma generate`
Verify: No errors, Prisma client regenerated with Service type
  </verify>
  <done>
Service model and ServiceStatus enum exist in schema.prisma. Database schema updated. Prisma client includes Service type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Service types and service layer</name>
  <files>src/types/service.ts, src/services/service.service.ts</files>
  <action>
1. Create src/types/service.ts with TypeScript interfaces:

```typescript
import { ServiceStatus } from '@prisma/client';

// Base Service type matching Prisma model
export interface Service {
  id: string;
  name: string;
  description: string | null;
  routingKey: string;
  teamId: string;
  escalationPolicyId: string | null;
  status: ServiceStatus;
  tags: string[];
  createdAt: Date;
  updatedAt: Date;
}

// Service with related entities included
export interface ServiceWithTeam extends Service {
  team: {
    id: string;
    name: string;
  };
  escalationPolicy: {
    id: string;
    name: string;
  } | null;
}

// Input for creating a service
export interface CreateServiceInput {
  name: string;
  description?: string;
  routingKey: string;
  teamId: string;  // Required per SVC-05
  escalationPolicyId?: string;
  tags?: string[];
}

// Input for updating service metadata
export interface UpdateServiceInput {
  name?: string;
  description?: string;
  tags?: string[];
  escalationPolicyId?: string | null;  // null to remove override
}

// Input for listing/filtering services
export interface ListServicesParams {
  teamId?: string;
  status?: ServiceStatus;
  search?: string;
  limit?: number;
  offset?: number;
}
```

2. Create src/services/service.service.ts following team.service.ts pattern:

```typescript
import { prisma } from '../config/database.js';
import { auditService } from './audit.service.js';
import { ServiceStatus, Prisma } from '@prisma/client';
import type {
  CreateServiceInput,
  UpdateServiceInput,
  ListServicesParams,
  ServiceWithTeam
} from '../types/service.js';

export class ServiceService {
  // Create new service (SVC-01, SVC-05)
  async create(input: CreateServiceInput, userId: string): Promise<ServiceWithTeam> {
    const service = await prisma.service.create({
      data: {
        name: input.name,
        description: input.description,
        routingKey: input.routingKey,
        teamId: input.teamId,
        escalationPolicyId: input.escalationPolicyId,
        tags: input.tags || [],
      },
      include: {
        team: { select: { id: true, name: true } },
        escalationPolicy: { select: { id: true, name: true } }
      }
    });

    await auditService.log({
      action: 'service.created',
      userId,
      teamId: input.teamId,
      resourceType: 'service',
      resourceId: service.id,
      metadata: { name: service.name, routingKey: service.routingKey }
    });

    return service as ServiceWithTeam;
  }

  // Get service by ID
  async get(serviceId: string): Promise<ServiceWithTeam | null> {
    const service = await prisma.service.findUnique({
      where: { id: serviceId },
      include: {
        team: { select: { id: true, name: true } },
        escalationPolicy: { select: { id: true, name: true } }
      }
    });

    return service as ServiceWithTeam | null;
  }

  // Get service by routing key (for Phase 13 alert routing)
  async getByRoutingKey(routingKey: string): Promise<ServiceWithTeam | null> {
    const service = await prisma.service.findUnique({
      where: { routingKey },
      include: {
        team: { select: { id: true, name: true } },
        escalationPolicy: { select: { id: true, name: true } }
      }
    });

    return service as ServiceWithTeam | null;
  }

  // List services with filtering (SVC-04)
  async list(params: ListServicesParams) {
    const where: Prisma.ServiceWhereInput = {};

    // Filter by team
    if (params.teamId) {
      where.teamId = params.teamId;
    }

    // Filter by status (default shows all if not specified by route)
    if (params.status) {
      where.status = params.status;
    }

    // Search by name (case insensitive)
    if (params.search) {
      where.name = { contains: params.search, mode: 'insensitive' };
    }

    // Only include services from active teams
    where.team = { isActive: true };

    const [services, total] = await Promise.all([
      prisma.service.findMany({
        where,
        include: {
          team: { select: { id: true, name: true } },
          escalationPolicy: { select: { id: true, name: true } }
        },
        skip: params.offset || 0,
        take: params.limit || 50,
        orderBy: { name: 'asc' }
      }),
      prisma.service.count({ where })
    ]);

    return { services: services as ServiceWithTeam[], total };
  }

  // Update service metadata (SVC-02)
  async update(serviceId: string, input: UpdateServiceInput, userId: string): Promise<ServiceWithTeam | null> {
    const existing = await prisma.service.findUnique({
      where: { id: serviceId },
      select: { teamId: true }
    });
    if (!existing) return null;

    const service = await prisma.service.update({
      where: { id: serviceId },
      data: {
        name: input.name,
        description: input.description,
        tags: input.tags,
        escalationPolicyId: input.escalationPolicyId,
      },
      include: {
        team: { select: { id: true, name: true } },
        escalationPolicy: { select: { id: true, name: true } }
      }
    });

    await auditService.log({
      action: 'service.updated',
      userId,
      teamId: existing.teamId,
      resourceType: 'service',
      resourceId: service.id,
      metadata: {
        changes: Object.keys(input).filter(k => input[k as keyof UpdateServiceInput] !== undefined)
      }
    });

    return service as ServiceWithTeam;
  }

  // Update service status (SVC-03: archive or deprecate)
  async updateStatus(serviceId: string, status: ServiceStatus, userId: string): Promise<ServiceWithTeam | null> {
    const existing = await prisma.service.findUnique({
      where: { id: serviceId },
      select: { teamId: true, status: true }
    });
    if (!existing) return null;

    const service = await prisma.service.update({
      where: { id: serviceId },
      data: { status },
      include: {
        team: { select: { id: true, name: true } },
        escalationPolicy: { select: { id: true, name: true } }
      }
    });

    await auditService.log({
      action: `service.status_changed`,
      userId,
      teamId: existing.teamId,
      resourceType: 'service',
      resourceId: service.id,
      severity: status === 'ARCHIVED' ? 'HIGH' : 'INFO',
      metadata: {
        previousStatus: existing.status,
        newStatus: status
      }
    });

    return service as ServiceWithTeam;
  }
}

export const serviceService = new ServiceService();
```
  </action>
  <verify>
Run: `npx tsc --noEmit`
Verify: No TypeScript errors in service.ts or service.service.ts
  </verify>
  <done>
TypeScript interfaces defined for Service CRUD. ServiceService class created with create, get, getByRoutingKey, list, update, and updateStatus methods. All methods include audit logging.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create REST routes and register in Express app</name>
  <files>src/routes/service.routes.ts, src/index.ts</files>
  <action>
1. Create src/routes/service.routes.ts following team.routes.ts pattern:

```typescript
import { Router } from 'express';
import { z } from 'zod';
import { requireAuth, requirePlatformAdmin, requireTeamRole } from '../middleware/auth.js';
import { serviceService } from '../services/service.service.js';
import { ServiceStatus } from '@prisma/client';

export const serviceRouter = Router();

// All service routes require authentication
serviceRouter.use(requireAuth);

// GET /api/services - List services with optional filters (SVC-04)
const ListServicesSchema = z.object({
  teamId: z.string().optional(),
  status: z.enum(['ACTIVE', 'DEPRECATED', 'ARCHIVED']).optional(),
  search: z.string().optional(),
  limit: z.coerce.number().min(1).max(100).default(50),
  offset: z.coerce.number().min(0).default(0)
});

serviceRouter.get('/', async (req, res) => {
  try {
    const params = ListServicesSchema.parse(req.query);
    const result = await serviceService.list(params);
    return res.json(result);
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: 'Invalid query parameters', details: error.errors });
    }
    console.error('Failed to list services:', error);
    return res.status(500).json({ error: 'Failed to list services' });
  }
});

// GET /api/services/:serviceId - Get service details
serviceRouter.get('/:serviceId', async (req, res) => {
  try {
    const service = await serviceService.get(req.params.serviceId);
    if (!service) {
      return res.status(404).json({ error: 'Service not found' });
    }
    return res.json({ service });
  } catch (error) {
    console.error('Failed to get service:', error);
    return res.status(500).json({ error: 'Failed to get service' });
  }
});

// POST /api/services - Create service (platform admin only for now)
// SVC-01: name, description, routing key, owning team
// SVC-05: teamId is required
const CreateServiceSchema = z.object({
  name: z.string().min(2).max(100),
  description: z.string().max(500).optional(),
  routingKey: z.string().min(1).max(100).regex(/^[a-zA-Z0-9_-]+$/,
    'Routing key must contain only alphanumeric characters, underscores, and hyphens'),
  teamId: z.string().min(1, 'Owning team is required'),  // SVC-05
  escalationPolicyId: z.string().optional(),
  tags: z.array(z.string().max(50)).max(20).optional()
});

serviceRouter.post('/', requirePlatformAdmin, async (req, res) => {
  try {
    const input = CreateServiceSchema.parse(req.body);
    const service = await serviceService.create(input, (req.user as any).id);
    return res.status(201).json({ service });
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: 'Invalid service data', details: error.errors });
    }
    // Handle unique constraint violation (duplicate routing key)
    if (error.code === 'P2002' && error.meta?.target?.includes('routingKey')) {
      return res.status(409).json({ error: 'Routing key already exists' });
    }
    console.error('Failed to create service:', error);
    return res.status(500).json({ error: 'Failed to create service' });
  }
});

// PATCH /api/services/:serviceId - Update service metadata (SVC-02)
// Team admin of owning team or platform admin
const UpdateServiceSchema = z.object({
  name: z.string().min(2).max(100).optional(),
  description: z.string().max(500).optional(),
  tags: z.array(z.string().max(50)).max(20).optional(),
  escalationPolicyId: z.string().nullable().optional()  // null to remove override
});

serviceRouter.patch('/:serviceId', async (req, res) => {
  try {
    // Get service to check team ownership
    const existing = await serviceService.get(req.params.serviceId);
    if (!existing) {
      return res.status(404).json({ error: 'Service not found' });
    }

    // Check authorization: platform admin or team admin of owning team
    const user = req.user as any;
    const isPlatformAdmin = user.platformRole === 'PLATFORM_ADMIN';
    const isTeamAdmin = user.teamMembers?.some(
      (m: any) => m.teamId === existing.teamId && m.role === 'TEAM_ADMIN'
    );

    if (!isPlatformAdmin && !isTeamAdmin) {
      return res.status(403).json({ error: 'Not authorized to update this service' });
    }

    const input = UpdateServiceSchema.parse(req.body);
    const service = await serviceService.update(req.params.serviceId, input, user.id);
    return res.json({ service });
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: 'Invalid service data', details: error.errors });
    }
    console.error('Failed to update service:', error);
    return res.status(500).json({ error: 'Failed to update service' });
  }
});

// PATCH /api/services/:serviceId/status - Update service status (SVC-03)
// Archive or deprecate a service
const UpdateStatusSchema = z.object({
  status: z.enum(['ACTIVE', 'DEPRECATED', 'ARCHIVED'])
});

serviceRouter.patch('/:serviceId/status', async (req, res) => {
  try {
    // Get service to check team ownership
    const existing = await serviceService.get(req.params.serviceId);
    if (!existing) {
      return res.status(404).json({ error: 'Service not found' });
    }

    // Check authorization: platform admin or team admin of owning team
    const user = req.user as any;
    const isPlatformAdmin = user.platformRole === 'PLATFORM_ADMIN';
    const isTeamAdmin = user.teamMembers?.some(
      (m: any) => m.teamId === existing.teamId && m.role === 'TEAM_ADMIN'
    );

    if (!isPlatformAdmin && !isTeamAdmin) {
      return res.status(403).json({ error: 'Not authorized to update this service' });
    }

    const { status } = UpdateStatusSchema.parse(req.body);
    const service = await serviceService.updateStatus(
      req.params.serviceId,
      status as ServiceStatus,
      user.id
    );
    return res.json({ service });
  } catch (error: any) {
    if (error.name === 'ZodError') {
      return res.status(400).json({ error: 'Invalid status', details: error.errors });
    }
    console.error('Failed to update service status:', error);
    return res.status(500).json({ error: 'Failed to update service status' });
  }
});
```

2. Register router in src/index.ts:

Add import at top with other route imports (around line 46):
```typescript
import { serviceRouter } from './routes/service.routes.js';
```

Add route registration after postmortem router (around line 162):
```typescript
app.use('/api/services', serviceRouter);
```
  </action>
  <verify>
Run: `npm run build`
Verify: Build succeeds with no errors

Run: `curl -s http://localhost:3001/api/services -H "Cookie: ..." | jq .`
(Manual test after starting server - will be tested in Plan 02)
  </verify>
  <done>
REST routes created for Service CRUD: GET /api/services (list with filters), GET /api/services/:id, POST /api/services, PATCH /api/services/:id (metadata), PATCH /api/services/:id/status. Router registered in Express app at /api/services.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Database schema updated:
   - `npx prisma db push` succeeds
   - Service model visible in Prisma Studio (`npx prisma studio`)

2. TypeScript compiles:
   - `npm run build` succeeds with no errors

3. API endpoints accessible:
   - Server starts without errors
   - Routes registered at /api/services

4. Audit logging works:
   - Service operations create audit events
</verification>

<success_criteria>
- Service model exists in database with all fields (name, description, routingKey, teamId, escalationPolicyId, status, tags)
- ServiceStatus enum has ACTIVE, DEPRECATED, ARCHIVED values
- serviceService provides CRUD operations with audit logging
- REST API endpoints return proper responses (201 on create, 400 on validation error, 404 on not found)
- teamId is required for service creation (SVC-05)
- Routing key uniqueness enforced (409 on duplicate)
</success_criteria>

<output>
After completion, create `.planning/phases/11-service-model-foundation/11-01-SUMMARY.md`
</output>

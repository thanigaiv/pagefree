---
phase: 17-partner-status-pages
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/partner/partner.service.ts
  - src/partner/partnerAccess.service.ts
  - src/types/partner.ts
autonomous: true

must_haves:
  truths:
    - "PartnerUser model exists in database with email, name, isActive, createdBy fields"
    - "PartnerStatusPageAccess model exists for many-to-many partner-statuspage relation"
    - "PartnerSession model exists with separate table from internal Session"
    - "PartnerMagicToken model exists for magic link authentication"
    - "Partner service can create, deactivate, and list partner users"
    - "Partner access service can assign and revoke status page access"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "PartnerUser, PartnerStatusPageAccess, PartnerSession, PartnerMagicToken models"
      contains: "model PartnerUser"
    - path: "src/partner/partner.service.ts"
      provides: "Partner CRUD operations"
      exports: ["partnerService"]
    - path: "src/partner/partnerAccess.service.ts"
      provides: "Status page access assignment"
      exports: ["partnerAccessService"]
    - path: "src/types/partner.ts"
      provides: "TypeScript types for partner operations"
      exports: ["PartnerUser", "CreatePartnerInput", "PartnerAccessGrant"]
  key_links:
    - from: "src/partner/partner.service.ts"
      to: "prisma.partnerUser"
      via: "Prisma client operations"
      pattern: "prisma\\.partnerUser\\.(create|findUnique|update)"
    - from: "src/partner/partnerAccess.service.ts"
      to: "prisma.partnerStatusPageAccess"
      via: "Prisma client operations"
      pattern: "prisma\\.partnerStatusPageAccess\\.(create|delete)"
---

<objective>
Create database models and service layer for partner users and status page access assignments.

Purpose: Establish the data foundation for partner authentication and access control. Partners are separate from internal users with their own models, session table, and access grants.

Output: Prisma schema with 4 new models, partner service for CRUD, access service for assignments, TypeScript types.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-partner-status-pages/17-RESEARCH.md
@prisma/schema.prisma
@src/services/audit.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Partner models to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add four new models to the Prisma schema after the existing Postmortem models section:

1. **PartnerUser** model:
   - id: String @id @default(cuid())
   - email: String @unique
   - name: String
   - isActive: Boolean @default(true)
   - createdById: String (relation to User who created)
   - createdBy: User @relation("PartnerCreatedBy", fields: [createdById], references: [id])
   - createdAt: DateTime @default(now()) @db.Timestamptz
   - updatedAt: DateTime @updatedAt @db.Timestamptz
   - Relations: statusPageAccess PartnerStatusPageAccess[], sessions PartnerSession[], magicTokens PartnerMagicToken[]
   - Indexes: @@index([email]), @@index([isActive])

2. **PartnerStatusPageAccess** model (join table):
   - id: String @id @default(cuid())
   - partnerUserId: String (relation to PartnerUser, onDelete: Cascade)
   - statusPageId: String (relation to StatusPage, onDelete: Cascade)
   - grantedById: String (who granted access)
   - grantedAt: DateTime @default(now()) @db.Timestamptz
   - @@unique([partnerUserId, statusPageId])
   - Indexes: @@index([partnerUserId]), @@index([statusPageId])

3. **PartnerSession** model (for connect-pg-simple):
   - sid: String @id
   - sess: Json
   - expire: DateTime @db.Timestamptz
   - @@index([expire])

4. **PartnerMagicToken** model:
   - id: String @id @default(cuid())
   - tokenHash: String @unique (SHA-256 hash, never plaintext)
   - partnerUserId: String (relation to PartnerUser, onDelete: Cascade)
   - used: Boolean @default(false)
   - usedAt: DateTime? @db.Timestamptz
   - expiresAt: DateTime @db.Timestamptz
   - createdAt: DateTime @default(now()) @db.Timestamptz
   - Indexes: @@index([tokenHash]), @@index([expiresAt])

Also add reverse relation to StatusPage model:
- partnerAccess: PartnerStatusPageAccess[]

Also add reverse relation to User model:
- partnersCreated: PartnerUser[] @relation("PartnerCreatedBy")

Run `npx prisma db push` to apply changes.
  </action>
  <verify>
Run `npx prisma db push` successfully. Then verify with `npx prisma studio` or direct SQL that tables exist:
- PartnerUser, PartnerStatusPageAccess, PartnerSession, PartnerMagicToken
  </verify>
  <done>
Four new tables exist in database with correct columns and relations. Prisma client types are generated.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create partner types and service</name>
  <files>src/types/partner.ts, src/partner/partner.service.ts</files>
  <action>
Create `src/types/partner.ts` with TypeScript types:
```typescript
export interface CreatePartnerInput {
  email: string;
  name: string;
}

export interface UpdatePartnerInput {
  name?: string;
  isActive?: boolean;
}

export interface PartnerWithAccess {
  id: string;
  email: string;
  name: string;
  isActive: boolean;
  createdAt: Date;
  statusPageAccess: Array<{
    statusPageId: string;
    statusPage: { id: string; name: string; slug: string };
    grantedAt: Date;
  }>;
}
```

Create `src/partner/partner.service.ts`:
- Constructor takes PrismaClient
- `create(input: CreatePartnerInput, createdById: string)`: Creates partner, logs audit event (partner.created)
- `getById(id: string)`: Returns partner with status page access
- `getByEmail(email: string)`: Returns partner by email (for auth lookup)
- `list(options?: { isActive?: boolean })`: Lists partners with access info
- `update(id: string, input: UpdatePartnerInput, updatedById: string)`: Updates partner, logs audit (partner.updated or partner.deactivated)
- `deactivate(id: string, deactivatedById: string)`: Sets isActive=false, logs audit (partner.deactivated)

Use auditService for logging with action prefix "partner." and resourceType "PartnerUser".

Export singleton: `export const partnerService = new PartnerService(prisma);`
  </action>
  <verify>
TypeScript compiles without errors. Create a simple test:
```bash
npx ts-node -e "import { partnerService } from './src/partner/partner.service.js'; console.log('Service loaded');"
```
  </verify>
  <done>
Partner service can create, read, update, and deactivate partner users with audit logging.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create partner access service</name>
  <files>src/partner/partnerAccess.service.ts</files>
  <action>
Create `src/partner/partnerAccess.service.ts`:
- Constructor takes PrismaClient
- `grantAccess(partnerUserId: string, statusPageId: string, grantedById: string)`:
  - Creates PartnerStatusPageAccess record
  - Logs audit event (partner.access.granted) with metadata: { partnerUserId, statusPageId }
  - Returns the access record with partner and status page details

- `revokeAccess(partnerUserId: string, statusPageId: string, revokedById: string)`:
  - Deletes PartnerStatusPageAccess record
  - Logs audit event (partner.access.revoked) with metadata
  - Returns true if deleted, false if not found

- `listByPartner(partnerUserId: string)`:
  - Returns all status pages a partner has access to

- `listByStatusPage(statusPageId: string)`:
  - Returns all partners who have access to a status page

- `hasAccess(partnerUserId: string, statusPageId: string)`:
  - Returns boolean for access check (used by middleware)

Export singleton: `export const partnerAccessService = new PartnerAccessService(prisma);`
  </action>
  <verify>
TypeScript compiles. Test import:
```bash
npx ts-node -e "import { partnerAccessService } from './src/partner/partnerAccess.service.js'; console.log('Service loaded');"
```
  </verify>
  <done>
Partner access service can grant, revoke, list, and check status page access with audit logging.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma db push` succeeds
2. `npm run build` compiles without errors
3. All four new Prisma models accessible via prisma client
4. Partner service methods work (create, list, deactivate)
5. Access service methods work (grant, revoke, hasAccess)
</verification>

<success_criteria>
- Database has PartnerUser, PartnerStatusPageAccess, PartnerSession, PartnerMagicToken tables
- Partner service can CRUD partner users with audit logging
- Access service can manage status page assignments with audit logging
- TypeScript types exported for use in other files
- No overlap with internal User/Session models (complete separation)
</success_criteria>

<output>
After completion, create `.planning/phases/17-partner-status-pages/17-01-SUMMARY.md`
</output>

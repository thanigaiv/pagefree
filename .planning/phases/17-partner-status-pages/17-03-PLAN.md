---
phase: 17-partner-status-pages
plan: 03
type: execute
wave: 3
depends_on: ["17-02"]
files_modified:
  - src/partner/partner.routes.ts
  - src/partner/access.middleware.ts
  - src/routes/admin.routes.ts
  - frontend/src/pages/admin/PartnersPage.tsx
  - frontend/src/pages/partner/PartnerDashboardPage.tsx
  - frontend/src/pages/partner/PartnerStatusPageView.tsx
autonomous: false

must_haves:
  truths:
    - "Partner can only view status pages they have been assigned to"
    - "Partner sees component status, active incidents, maintenance windows, and incident history"
    - "Partner CANNOT subscribe to updates (subscribe button hidden/disabled)"
    - "Partner CANNOT view internal incidents (only StatusIncident records)"
    - "Partner CANNOT access admin functions (routes return 403)"
    - "All partner status page access logged to audit (partner.access.statusPage)"
    - "Denied access attempts logged to audit (partner.access.denied)"
    - "Admins can create partner accounts via admin UI"
    - "Admins can assign/revoke status page access via admin UI"
    - "Admins can view partner access audit logs"
  artifacts:
    - path: "src/partner/access.middleware.ts"
      provides: "Partner access control middleware"
      exports: ["requirePartnerAccess"]
    - path: "src/partner/partner.routes.ts"
      provides: "Partner status page read-only endpoints"
      contains: "/status-pages/:statusPageId"
    - path: "src/routes/admin.routes.ts"
      provides: "Admin routes for partner management"
      contains: "/admin/partners"
    - path: "frontend/src/pages/admin/PartnersPage.tsx"
      provides: "Admin UI for partner management"
    - path: "frontend/src/pages/partner/PartnerDashboardPage.tsx"
      provides: "Partner dashboard listing assigned status pages"
    - path: "frontend/src/pages/partner/PartnerStatusPageView.tsx"
      provides: "Partner read-only status page view"
  key_links:
    - from: "src/partner/partner.routes.ts"
      to: "src/partner/access.middleware.ts"
      via: "requirePartnerAccess middleware"
      pattern: "requirePartnerAccess"
    - from: "frontend/src/pages/partner/PartnerStatusPageView.tsx"
      to: "/api/partner/status-pages/:statusPageId"
      via: "fetch API"
      pattern: "fetch.*api/partner/status-pages"
    - from: "src/routes/admin.routes.ts"
      to: "src/partner/partner.service.ts"
      via: "partnerService"
      pattern: "partnerService\\.(create|list)"
---

<objective>
Implement partner status page access control, partner read-only views, and admin management UI.

Purpose: Complete the partner access system (PARTNER-03, PARTNER-04). Partners view only assigned status pages in read-only mode. Admins manage partner accounts and access assignments. All access is audited.

Output: Partner access middleware, partner status page routes, admin partner routes, frontend pages for partners and admin.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-partner-status-pages/17-RESEARCH.md
@.planning/phases/17-partner-status-pages/17-01-SUMMARY.md
@.planning/phases/17-partner-status-pages/17-02-SUMMARY.md
@src/routes/statusPublic.routes.ts
@src/middleware/auth.ts
@frontend/src/pages/StatusPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create partner access middleware and status page routes</name>
  <files>src/partner/access.middleware.ts, src/partner/partner.routes.ts</files>
  <action>
Create `src/partner/access.middleware.ts`:

```typescript
import { Request, Response, NextFunction } from 'express';
import { partnerAccessService } from './partnerAccess.service.js';
import { auditService } from '../services/audit.service.js';

/**
 * Middleware to verify partner has access to the requested status page
 * Must be used after loadPartnerUser and requirePartnerAuth
 */
export async function requirePartnerAccess(req: Request, res: Response, next: NextFunction): Promise<void> {
  const partner = (req as any).partnerUser;
  const { statusPageId } = req.params;

  if (!partner) {
    res.status(401).json({ error: 'Partner authentication required' });
    return;
  }

  if (!statusPageId) {
    res.status(400).json({ error: 'Status page ID required' });
    return;
  }

  const hasAccess = await partnerAccessService.hasAccess(partner.id, statusPageId);

  if (!hasAccess) {
    // Log access denial
    await auditService.log({
      action: 'partner.access.denied',
      resourceType: 'StatusPage',
      resourceId: statusPageId,
      metadata: {
        partnerEmail: partner.email,
        partnerId: partner.id,
        reason: 'no_access_grant'
      },
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
      severity: 'WARN'
    });

    res.status(403).json({ error: 'Access denied to this status page' });
    return;
  }

  next();
}
```

Update `src/partner/partner.routes.ts` to add status page viewing endpoints:

Add imports at top:
```typescript
import { requirePartnerAccess } from './access.middleware.js';
import { statusPageService } from '../services/statusPage.service.js';
import { statusComputationService } from '../services/statusComputation.service.js';
import { statusIncidentService } from '../services/statusIncident.service.js';
import { maintenanceService } from '../services/maintenance.service.js';
```

Add routes after auth routes:

```typescript
// ============================================================================
// PARTNER STATUS PAGE VIEWING (Read-Only)
// ============================================================================

/**
 * GET /api/partner/status-pages
 * List status pages partner has access to
 */
router.get('/status-pages', loadPartnerUser, requirePartnerAuth, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const partner = (req as any).partnerUser;

    // Log access
    await auditService.log({
      action: 'partner.access.statusPage',
      resourceType: 'StatusPage',
      metadata: {
        partnerEmail: partner.email,
        action: 'list'
      },
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
      severity: 'INFO'
    });

    return res.json({
      statusPages: partner.statusPageAccess.map((a: any) => ({
        id: a.statusPage.id,
        name: a.statusPage.name,
        slug: a.statusPage.slug
      }))
    });
  } catch (error) {
    return next(error);
  }
});

/**
 * GET /api/partner/status-pages/:statusPageId
 * Get status page with computed statuses (partner must have access)
 */
router.get('/status-pages/:statusPageId', loadPartnerUser, requirePartnerAuth, requirePartnerAccess, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const partner = (req as any).partnerUser;
    const { statusPageId } = req.params;

    const statusPage = await statusPageService.getById(statusPageId);
    if (!statusPage) {
      return res.status(404).json({ error: 'Status page not found' });
    }

    // Compute status for each component
    const componentsWithStatus = await Promise.all(
      statusPage.components.map(async (component: any) => {
        const status = await statusComputationService.getStatus(component.id);
        return {
          id: component.id,
          name: component.name,
          description: component.description,
          status,
          statusUpdatedAt: component.statusUpdatedAt,
          displayOrder: component.displayOrder
        };
      })
    );

    // Compute overall status
    const overallStatus = statusComputationService.computeOverallStatus(
      componentsWithStatus.map(c => c.status)
    );

    // Log access
    await auditService.log({
      action: 'partner.access.statusPage',
      resourceType: 'StatusPage',
      resourceId: statusPageId,
      metadata: {
        partnerEmail: partner.email,
        partnerId: partner.id,
        statusPageName: statusPage.name
      },
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
      severity: 'INFO'
    });

    return res.json({
      id: statusPage.id,
      name: statusPage.name,
      description: statusPage.description,
      overallStatus,
      components: componentsWithStatus,
      updatedAt: new Date().toISOString()
    });
  } catch (error) {
    return next(error);
  }
});

/**
 * GET /api/partner/status-pages/:statusPageId/incidents
 * Get active incidents (StatusIncident only, not internal Incident)
 */
router.get('/status-pages/:statusPageId/incidents', loadPartnerUser, requirePartnerAuth, requirePartnerAccess, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { statusPageId } = req.params;

    // Get only public status incidents (not internal incidents)
    const incidents = await statusIncidentService.listByStatusPage(statusPageId, {
      includeResolved: false
    });

    return res.json({ incidents });
  } catch (error) {
    return next(error);
  }
});

/**
 * GET /api/partner/status-pages/:statusPageId/maintenance
 * Get upcoming/active maintenance
 */
router.get('/status-pages/:statusPageId/maintenance', loadPartnerUser, requirePartnerAuth, requirePartnerAccess, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { statusPageId } = req.params;

    const maintenance = await maintenanceService.listByStatusPage(statusPageId, {
      upcoming: true
    });

    return res.json({ maintenance });
  } catch (error) {
    return next(error);
  }
});

/**
 * GET /api/partner/status-pages/:statusPageId/history
 * Get incident history (last N days)
 */
router.get('/status-pages/:statusPageId/history', loadPartnerUser, requirePartnerAuth, requirePartnerAccess, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { statusPageId } = req.params;
    const { days } = req.query;

    let daysCount = 7;
    if (days) {
      daysCount = Math.min(Math.max(parseInt(days as string, 10) || 7, 1), 90);
    }

    const history = await statusIncidentService.getHistory(statusPageId, daysCount);

    return res.json({ history });
  } catch (error) {
    return next(error);
  }
});
```

Note: Partner routes do NOT include subscribe endpoint - partners cannot subscribe per PARTNER-03.
  </action>
  <verify>
1. `npm run build` compiles
2. Test access denial:
```bash
# Without auth should return 401
curl http://localhost:3001/api/partner/status-pages
# With invalid status page should return 403 (access denied)
```
  </verify>
  <done>
Partner can view status pages, incidents, maintenance, and history for assigned pages only. Access denied attempts logged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin routes for partner management</name>
  <files>src/routes/admin.routes.ts</files>
  <action>
Create `src/routes/admin.routes.ts` (or add to existing admin routes if they exist):

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { requireAuth, requirePlatformAdmin } from '../middleware/auth.js';
import { partnerService } from '../partner/partner.service.js';
import { partnerAccessService } from '../partner/partnerAccess.service.js';
import { auditService } from '../services/audit.service.js';
import type { AuthenticatedUser } from '../types/auth.js';

const router = Router();

// All admin routes require platform admin
router.use(requireAuth, requirePlatformAdmin);

// ============================================================================
// PARTNER MANAGEMENT
// ============================================================================

const createPartnerSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1).max(100)
});

/**
 * POST /api/admin/partners
 * Create partner account
 */
router.post('/partners', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const input = createPartnerSchema.parse(req.body);
    const user = req.user as AuthenticatedUser;

    const partner = await partnerService.create(input, user.id);

    return res.status(201).json(partner);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: error.errors });
    }
    // Handle unique constraint violation
    if ((error as any).code === 'P2002') {
      return res.status(409).json({ error: 'Partner with this email already exists' });
    }
    return next(error);
  }
});

/**
 * GET /api/admin/partners
 * List all partners
 */
router.get('/partners', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { isActive } = req.query;
    const options: { isActive?: boolean } = {};

    if (isActive === 'true') options.isActive = true;
    if (isActive === 'false') options.isActive = false;

    const partners = await partnerService.list(options);

    return res.json({ partners });
  } catch (error) {
    return next(error);
  }
});

/**
 * GET /api/admin/partners/:partnerId
 * Get partner details with access
 */
router.get('/partners/:partnerId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { partnerId } = req.params;
    const partner = await partnerService.getById(partnerId);

    if (!partner) {
      return res.status(404).json({ error: 'Partner not found' });
    }

    return res.json(partner);
  } catch (error) {
    return next(error);
  }
});

/**
 * PUT /api/admin/partners/:partnerId
 * Update partner
 */
router.put('/partners/:partnerId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { partnerId } = req.params;
    const user = req.user as AuthenticatedUser;
    const { name, isActive } = req.body;

    const partner = await partnerService.update(partnerId, { name, isActive }, user.id);

    return res.json(partner);
  } catch (error) {
    return next(error);
  }
});

/**
 * DELETE /api/admin/partners/:partnerId
 * Deactivate partner (soft delete)
 */
router.delete('/partners/:partnerId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { partnerId } = req.params;
    const user = req.user as AuthenticatedUser;

    await partnerService.deactivate(partnerId, user.id);

    return res.json({ success: true });
  } catch (error) {
    return next(error);
  }
});

// ============================================================================
// PARTNER ACCESS MANAGEMENT
// ============================================================================

/**
 * POST /api/admin/partners/:partnerId/access
 * Grant status page access to partner
 */
router.post('/partners/:partnerId/access', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { partnerId } = req.params;
    const { statusPageId } = req.body;
    const user = req.user as AuthenticatedUser;

    if (!statusPageId) {
      return res.status(400).json({ error: 'statusPageId is required' });
    }

    const access = await partnerAccessService.grantAccess(partnerId, statusPageId, user.id);

    return res.status(201).json(access);
  } catch (error) {
    // Handle unique constraint (already has access)
    if ((error as any).code === 'P2002') {
      return res.status(409).json({ error: 'Partner already has access to this status page' });
    }
    return next(error);
  }
});

/**
 * DELETE /api/admin/partners/:partnerId/access/:statusPageId
 * Revoke status page access from partner
 */
router.delete('/partners/:partnerId/access/:statusPageId', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { partnerId, statusPageId } = req.params;
    const user = req.user as AuthenticatedUser;

    const revoked = await partnerAccessService.revokeAccess(partnerId, statusPageId, user.id);

    if (!revoked) {
      return res.status(404).json({ error: 'Access grant not found' });
    }

    return res.json({ success: true });
  } catch (error) {
    return next(error);
  }
});

// ============================================================================
// PARTNER AUDIT LOGS
// ============================================================================

/**
 * GET /api/admin/partners/audit-logs
 * Get partner-specific audit logs (90-day retention per PARTNER-04)
 */
router.get('/partners/audit-logs', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { partnerId, action, limit, offset } = req.query;

    // Query audit events with partner.* action prefix
    const result = await auditService.query({
      action: action as string || undefined,
      resourceType: partnerId ? 'PartnerUser' : undefined,
      resourceId: partnerId as string || undefined,
      limit: parseInt(limit as string, 10) || 100,
      offset: parseInt(offset as string, 10) || 0,
      // Filter to partner.* actions
      startDate: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) // 90 days back
    });

    // Additional filter for partner.* actions in application layer
    const partnerEvents = result.events.filter(e => e.action.startsWith('partner.'));

    return res.json({
      events: partnerEvents,
      total: partnerEvents.length
    });
  } catch (error) {
    return next(error);
  }
});

export const adminRoutes = router;
```

Mount in `src/app.ts`:
```typescript
import { adminRoutes } from './routes/admin.routes.js';

// Add after other route mounts
app.use('/api/admin', adminRoutes);
```
  </action>
  <verify>
1. `npm run build` compiles
2. Test admin routes require platform admin:
```bash
# Without auth should return 401
curl http://localhost:3001/api/admin/partners
```
  </verify>
  <done>
Admin can create partners, manage access assignments, view partner audit logs. All operations require platform admin role.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create partner frontend pages</name>
  <files>frontend/src/pages/partner/PartnerDashboardPage.tsx, frontend/src/pages/partner/PartnerStatusPageView.tsx, frontend/src/pages/partner/PartnerLoginPage.tsx</files>
  <action>
Create partner frontend pages. First create the directory:
```bash
mkdir -p frontend/src/pages/partner
```

Create `frontend/src/pages/partner/PartnerLoginPage.tsx`:
```typescript
import { useState } from 'react';
import { useSearchParams } from 'react-router-dom';

export function PartnerLoginPage() {
  const [email, setEmail] = useState('');
  const [submitted, setSubmitted] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [searchParams] = useSearchParams();

  const urlError = searchParams.get('error');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    try {
      const response = await fetch('/api/partner/auth/request-login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email })
      });

      if (response.ok) {
        setSubmitted(true);
      } else {
        setError('Failed to send login link. Please try again.');
      }
    } catch {
      setError('Network error. Please try again.');
    }
  };

  if (submitted) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
          <h2 className="text-2xl font-bold text-center text-gray-900">Check your email</h2>
          <p className="text-center text-gray-600">
            If an account exists for {email}, you will receive a login link shortly.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full space-y-8 p-8 bg-white rounded-lg shadow">
        <div>
          <h2 className="text-2xl font-bold text-center text-gray-900">Partner Login</h2>
          <p className="mt-2 text-center text-gray-600">
            Enter your email to receive a login link
          </p>
        </div>

        {urlError === 'invalid_token' && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
            Your login link has expired or is invalid. Please request a new one.
          </div>
        )}

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              Email address
            </label>
            <input
              id="email"
              type="email"
              required
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500"
            />
          </div>

          <button
            type="submit"
            className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Send Login Link
          </button>
        </form>
      </div>
    </div>
  );
}
```

Create `frontend/src/pages/partner/PartnerDashboardPage.tsx`:
```typescript
import { useEffect, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';

interface StatusPageSummary {
  id: string;
  name: string;
  slug: string;
}

interface PartnerUser {
  id: string;
  email: string;
  name: string;
  statusPages: StatusPageSummary[];
}

export function PartnerDashboardPage() {
  const [partner, setPartner] = useState<PartnerUser | null>(null);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    fetch('/api/partner/auth/me', { credentials: 'include' })
      .then(res => {
        if (res.status === 401) {
          navigate('/partner/login');
          return null;
        }
        return res.json();
      })
      .then(data => {
        if (data) setPartner(data);
        setLoading(false);
      })
      .catch(() => {
        navigate('/partner/login');
      });
  }, [navigate]);

  const handleLogout = async () => {
    await fetch('/api/partner/auth/logout', {
      method: 'POST',
      credentials: 'include'
    });
    navigate('/partner/login');
  };

  if (loading) {
    return <div className="p-8 text-center">Loading...</div>;
  }

  if (!partner) {
    return null;
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-xl font-bold text-gray-900">Partner Dashboard</h1>
          <div className="flex items-center gap-4">
            <span className="text-gray-600">{partner.email}</span>
            <button
              onClick={handleLogout}
              className="text-gray-600 hover:text-gray-900"
            >
              Logout
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 py-8">
        <h2 className="text-lg font-semibold text-gray-900 mb-4">Your Status Pages</h2>

        {partner.statusPages.length === 0 ? (
          <div className="bg-white rounded-lg shadow p-8 text-center text-gray-500">
            No status pages assigned. Contact your administrator for access.
          </div>
        ) : (
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {partner.statusPages.map(page => (
              <Link
                key={page.id}
                to={`/partner/status/${page.id}`}
                className="block bg-white rounded-lg shadow p-6 hover:shadow-md transition-shadow"
              >
                <h3 className="text-lg font-medium text-gray-900">{page.name}</h3>
                <p className="text-sm text-gray-500 mt-1">/{page.slug}</p>
              </Link>
            ))}
          </div>
        )}
      </main>
    </div>
  );
}
```

Create `frontend/src/pages/partner/PartnerStatusPageView.tsx`:
```typescript
import { useEffect, useState } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';

interface Component {
  id: string;
  name: string;
  description: string | null;
  status: string;
  displayOrder: number;
}

interface StatusPageData {
  id: string;
  name: string;
  description: string | null;
  overallStatus: string;
  components: Component[];
  updatedAt: string;
}

const STATUS_COLORS: Record<string, string> = {
  OPERATIONAL: 'bg-green-500',
  DEGRADED: 'bg-yellow-500',
  PARTIAL_OUTAGE: 'bg-orange-500',
  MAJOR_OUTAGE: 'bg-red-500',
  UNDER_MAINTENANCE: 'bg-blue-500'
};

const STATUS_LABELS: Record<string, string> = {
  OPERATIONAL: 'Operational',
  DEGRADED: 'Degraded Performance',
  PARTIAL_OUTAGE: 'Partial Outage',
  MAJOR_OUTAGE: 'Major Outage',
  UNDER_MAINTENANCE: 'Under Maintenance'
};

export function PartnerStatusPageView() {
  const { statusPageId } = useParams<{ statusPageId: string }>();
  const [statusPage, setStatusPage] = useState<StatusPageData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    fetch(`/api/partner/status-pages/${statusPageId}`, { credentials: 'include' })
      .then(res => {
        if (res.status === 401) {
          navigate('/partner/login');
          return null;
        }
        if (res.status === 403) {
          setError('You do not have access to this status page.');
          setLoading(false);
          return null;
        }
        if (!res.ok) throw new Error('Failed to load status page');
        return res.json();
      })
      .then(data => {
        if (data) {
          setStatusPage(data);
          setLoading(false);
        }
      })
      .catch(() => {
        setError('Failed to load status page');
        setLoading(false);
      });
  }, [statusPageId, navigate]);

  if (loading) {
    return <div className="p-8 text-center">Loading...</div>;
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gray-50 p-8">
        <div className="max-w-3xl mx-auto">
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
            {error}
          </div>
          <Link to="/partner/dashboard" className="text-blue-600 hover:underline mt-4 inline-block">
            Back to Dashboard
          </Link>
        </div>
      </div>
    );
  }

  if (!statusPage) return null;

  return (
    <div className="min-h-screen bg-gray-50">
      <header className="bg-white shadow">
        <div className="max-w-3xl mx-auto px-4 py-4">
          <Link to="/partner/dashboard" className="text-blue-600 hover:underline text-sm">
            Back to Dashboard
          </Link>
          <h1 className="text-2xl font-bold text-gray-900 mt-2">{statusPage.name}</h1>
          {statusPage.description && (
            <p className="text-gray-600 mt-1">{statusPage.description}</p>
          )}
        </div>
      </header>

      <main className="max-w-3xl mx-auto px-4 py-8">
        {/* Overall Status Banner */}
        <div className={`${STATUS_COLORS[statusPage.overallStatus] || 'bg-gray-500'} rounded-lg p-4 text-white mb-8`}>
          <p className="text-lg font-semibold">
            {STATUS_LABELS[statusPage.overallStatus] || statusPage.overallStatus}
          </p>
          <p className="text-sm opacity-90">
            Last updated: {new Date(statusPage.updatedAt).toLocaleString()}
          </p>
        </div>

        {/* Components */}
        <h2 className="text-lg font-semibold text-gray-900 mb-4">Components</h2>
        <div className="bg-white rounded-lg shadow divide-y">
          {statusPage.components
            .sort((a, b) => a.displayOrder - b.displayOrder)
            .map(component => (
              <div key={component.id} className="p-4 flex justify-between items-center">
                <div>
                  <h3 className="font-medium text-gray-900">{component.name}</h3>
                  {component.description && (
                    <p className="text-sm text-gray-500">{component.description}</p>
                  )}
                </div>
                <div className="flex items-center gap-2">
                  <span className={`w-3 h-3 rounded-full ${STATUS_COLORS[component.status] || 'bg-gray-500'}`} />
                  <span className="text-sm text-gray-600">
                    {STATUS_LABELS[component.status] || component.status}
                  </span>
                </div>
              </div>
            ))}
        </div>

        {/* Note: No subscribe button - partners cannot subscribe per PARTNER-03 */}
      </main>
    </div>
  );
}
```

Add routes to frontend router (likely in App.tsx or routes file):
```typescript
import { PartnerLoginPage } from './pages/partner/PartnerLoginPage';
import { PartnerDashboardPage } from './pages/partner/PartnerDashboardPage';
import { PartnerStatusPageView } from './pages/partner/PartnerStatusPageView';

// Add routes:
<Route path="/partner/login" element={<PartnerLoginPage />} />
<Route path="/partner/dashboard" element={<PartnerDashboardPage />} />
<Route path="/partner/status/:statusPageId" element={<PartnerStatusPageView />} />
```
  </action>
  <verify>
1. `npm run build` in frontend directory compiles
2. Visit /partner/login in browser
3. Login flow works (request -> email -> verify -> dashboard)
4. Status page view shows components (no subscribe button)
  </verify>
  <done>
Partner frontend pages: login (magic link request), dashboard (assigned pages), status page view (read-only, no subscribe).
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify partner access control end-to-end</name>
  <what-built>
Complete partner status page system:
- Partner database models and services
- Partner magic link authentication
- Partner status page viewing (read-only)
- Admin partner management UI
- Comprehensive audit logging
  </what-built>
  <how-to-verify>
1. **Admin creates partner:**
   - Login as platform admin
   - Navigate to admin panel
   - Create partner with email and name
   - Assign partner access to a status page

2. **Partner login flow:**
   - Navigate to /partner/login
   - Enter partner email
   - Check email for magic link
   - Click link within 15 minutes
   - Verify redirect to /partner/dashboard

3. **Partner views status page:**
   - From dashboard, click assigned status page
   - Verify components and status are visible
   - Verify NO subscribe button exists
   - Try accessing unassigned status page (should show 403)

4. **Audit logs:**
   - As admin, check partner audit logs
   - Verify login, access, and denial events are logged
   - Verify logs include IP address and user agent

5. **Session expiry:**
   - Close browser and reopen
   - Session should persist (24 hours)
   - Wait 15+ minutes and try old magic link (should fail)

**Expected outcomes:**
- Partner can only see assigned status pages
- Partner CANNOT subscribe to updates
- All access is logged with full context
  </how-to-verify>
  <resume-signal>Type "approved" to confirm partner access control works correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. Partner access middleware enforces status page assignments
2. Partner routes return only data for assigned status pages
3. Admin can create partners and manage access
4. Frontend shows partner-specific views (no subscribe, no admin)
5. All partner actions logged with IP, user agent, timestamps
6. Access denial attempts logged as WARN severity
</verification>

<success_criteria>
- Partners see only assigned status pages (PARTNER-03)
- Partners see components, incidents, maintenance (PARTNER-03)
- Partners CANNOT subscribe (hidden from UI, route not exposed)
- Partners CANNOT access internal incidents (only StatusIncident)
- Access denied attempts logged (PARTNER-04)
- Admins can create/deactivate partners (PARTNER-01)
- Admins can assign/revoke access (PARTNER-01)
- Partner audit logs viewable by admins (PARTNER-04)
</success_criteria>

<output>
After completion, create `.planning/phases/17-partner-status-pages/17-03-SUMMARY.md`
</output>

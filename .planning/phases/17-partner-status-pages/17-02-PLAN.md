---
phase: 17-partner-status-pages
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/partner/session.ts
  - src/partner/auth.middleware.ts
  - src/partner/auth.service.ts
  - src/partner/partner.routes.ts
  - src/app.ts
autonomous: true

must_haves:
  truths:
    - "Partner session uses separate cookie (partner.sid) from internal session (oncall.sid)"
    - "Partner session stores in separate table (PartnerSession)"
    - "Partner can request magic link via POST /api/partner/auth/request-login"
    - "Magic link token expires in 15 minutes"
    - "Partner session expires after 24 hours"
    - "Magic link verification creates session and redirects to frontend"
    - "All partner auth actions logged to audit (partner.login.requested, partner.login)"
  artifacts:
    - path: "src/partner/session.ts"
      provides: "Partner session middleware"
      exports: ["partnerSessionMiddleware"]
    - path: "src/partner/auth.middleware.ts"
      provides: "Partner authentication middleware"
      exports: ["requirePartnerAuth", "loadPartnerUser"]
    - path: "src/partner/auth.service.ts"
      provides: "Magic link token generation and verification"
      exports: ["partnerAuthService"]
    - path: "src/partner/partner.routes.ts"
      provides: "Partner API routes"
      exports: ["partnerRoutes"]
  key_links:
    - from: "src/partner/partner.routes.ts"
      to: "src/partner/auth.service.ts"
      via: "generateMagicLinkToken and verifyMagicLinkToken"
      pattern: "partnerAuthService\\.(generate|verify)"
    - from: "src/partner/auth.middleware.ts"
      to: "req.session.partnerId"
      via: "Session lookup"
      pattern: "req\\.session\\.partnerId"
    - from: "src/app.ts"
      to: "src/partner/partner.routes.ts"
      via: "Route mounting"
      pattern: "app\\.use.*partnerRoutes"
---

<objective>
Implement partner magic link authentication with parallel session management.

Purpose: Enable passwordless authentication for partners using magic links (PARTNER-02). Partners have completely separate sessions from internal users to prevent cross-contamination.

Output: Partner session middleware, auth service for magic links, auth middleware, partner routes mounted at /api/partner/*.
</objective>

<execution_context>
@/Users/tvellore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tvellore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-partner-status-pages/17-RESEARCH.md
@.planning/phases/17-partner-status-pages/17-01-SUMMARY.md
@src/auth/session.ts
@src/services/notification.service.ts
@src/config/env.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create partner session middleware</name>
  <files>src/partner/session.ts</files>
  <action>
Create `src/partner/session.ts` following the pattern from `src/auth/session.ts`:

```typescript
import session from 'express-session';
import connectPgSimple from 'connect-pg-simple';
import { Pool } from 'pg';
import { env } from '../config/env.js';

const PgSession = connectPgSimple(session);

// Create dedicated pool for partner sessions (separate from internal sessions)
const partnerSessionPool = new Pool({
  connectionString: env.DATABASE_URL
});

export const partnerSessionMiddleware = session({
  store: new PgSession({
    pool: partnerSessionPool,
    tableName: 'PartnerSession',  // Different table from 'Session'
    createTableIfMissing: false   // Table created by Prisma migration
  }),
  secret: env.SESSION_SECRET,     // Can reuse same secret
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000,  // 24 hours per PARTNER-02
    sameSite: 'lax'
  },
  name: 'partner.sid'             // Different cookie name from 'oncall.sid'
});
```

Key differences from internal session:
- Uses PartnerSession table (not Session)
- Cookie named 'partner.sid' (not 'oncall.sid')
- Same 24-hour expiry per requirements
  </action>
  <verify>
TypeScript compiles. Import test:
```bash
npx ts-node -e "import { partnerSessionMiddleware } from './src/partner/session.js'; console.log('Session middleware loaded');"
```
  </verify>
  <done>
Partner session middleware configured with separate cookie and session table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create partner auth service with magic link support</name>
  <files>src/partner/auth.service.ts, src/partner/auth.middleware.ts</files>
  <action>
Create `src/partner/auth.service.ts`:

```typescript
import crypto from 'crypto';
import { prisma } from '../config/database.js';
import { notificationService } from '../services/notification.service.js';
import { auditService } from '../services/audit.service.js';
import { env } from '../config/env.js';

export class PartnerAuthService {
  /**
   * Generate magic link token and send email
   * Token expires in 15 minutes per PARTNER-02
   */
  async requestLogin(email: string, ipAddress?: string, userAgent?: string): Promise<{ sent: boolean }> {
    // Find partner by email
    const partner = await prisma.partnerUser.findUnique({
      where: { email, isActive: true }
    });

    // Security: always return success to not reveal if email exists
    if (!partner) {
      return { sent: true };
    }

    // Generate cryptographically secure token (32 bytes = 256 bits)
    const token = crypto.randomBytes(32).toString('hex');
    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

    // Store hashed token with 15-minute expiry
    await prisma.partnerMagicToken.create({
      data: {
        tokenHash,
        partnerUserId: partner.id,
        expiresAt: new Date(Date.now() + 15 * 60 * 1000)  // 15 minutes
      }
    });

    // Build magic link URL
    const loginUrl = `${env.API_BASE_URL}/api/partner/auth/verify/${token}`;

    // Send email using existing notification service
    await notificationService.sendEmail(
      partner.email,
      'PageFree - Your Status Page Access Link',
      this.buildMagicLinkEmailBody(partner.name, loginUrl)
    );

    // Audit log
    await auditService.log({
      action: 'partner.login.requested',
      resourceType: 'PartnerUser',
      resourceId: partner.id,
      metadata: { email: partner.email },
      ipAddress,
      userAgent,
      severity: 'INFO'
    });

    return { sent: true };
  }

  /**
   * Verify magic link token
   * Returns partner user if valid, null if invalid/expired/used
   */
  async verifyToken(token: string): Promise<{ partner: any; tokenId: string } | null> {
    const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

    const magicToken = await prisma.partnerMagicToken.findUnique({
      where: { tokenHash },
      include: { partnerUser: true }
    });

    if (!magicToken) return null;
    if (magicToken.used) return null;
    if (magicToken.expiresAt < new Date()) return null;
    if (!magicToken.partnerUser.isActive) return null;

    return { partner: magicToken.partnerUser, tokenId: magicToken.id };
  }

  /**
   * Mark token as used after successful verification
   */
  async markTokenUsed(tokenId: string): Promise<void> {
    await prisma.partnerMagicToken.update({
      where: { id: tokenId },
      data: { used: true, usedAt: new Date() }
    });
  }

  private buildMagicLinkEmailBody(partnerName: string, loginUrl: string): string {
    return `
Hello ${partnerName},

Click the link below to access your status page dashboard:

${loginUrl}

This link will expire in 15 minutes. If you didn't request this link, please ignore this email.

-- PageFree
    `.trim();
  }
}

export const partnerAuthService = new PartnerAuthService();
```

Create `src/partner/auth.middleware.ts`:

```typescript
import { Request, Response, NextFunction } from 'express';
import { prisma } from '../config/database.js';

// Extend Express session type for partner
declare module 'express-session' {
  interface SessionData {
    partnerId?: string;
    partnerEmail?: string;
  }
}

/**
 * Load partner user from session if present
 * Attaches to req.partnerUser
 */
export async function loadPartnerUser(req: Request, _res: Response, next: NextFunction): Promise<void> {
  if (req.session?.partnerId) {
    const partner = await prisma.partnerUser.findUnique({
      where: { id: req.session.partnerId },
      include: {
        statusPageAccess: {
          include: {
            statusPage: { select: { id: true, name: true, slug: true } }
          }
        }
      }
    });

    if (partner && partner.isActive) {
      (req as any).partnerUser = partner;
    } else {
      // Partner deactivated, destroy session
      req.session.destroy(() => {});
    }
  }
  next();
}

/**
 * Require partner authentication
 * Returns 401 if not authenticated
 */
export function requirePartnerAuth(req: Request, res: Response, next: NextFunction): void {
  if (!(req as any).partnerUser) {
    res.status(401).json({ error: 'Partner authentication required' });
    return;
  }
  next();
}
```
  </action>
  <verify>
TypeScript compiles. Test imports:
```bash
npx ts-node -e "import { partnerAuthService } from './src/partner/auth.service.js'; console.log('Auth service loaded');"
```
  </verify>
  <done>
Partner auth service generates magic links, verifies tokens, and marks them used. Auth middleware loads partner from session.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create partner routes and mount in app</name>
  <files>src/partner/partner.routes.ts, src/app.ts</files>
  <action>
Create `src/partner/partner.routes.ts`:

```typescript
import { Router, Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { partnerAuthService } from './auth.service.js';
import { loadPartnerUser, requirePartnerAuth } from './auth.middleware.js';
import { auditService } from '../services/audit.service.js';
import { env } from '../config/env.js';

const router = Router();

// Schema for login request
const loginRequestSchema = z.object({
  email: z.string().email()
});

/**
 * POST /api/partner/auth/request-login
 * Request magic link email
 */
router.post('/auth/request-login', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { email } = loginRequestSchema.parse(req.body);

    await partnerAuthService.requestLogin(
      email,
      req.ip,
      req.get('user-agent')
    );

    // Always return success to not reveal if email exists
    return res.json({
      success: true,
      message: 'If this email is registered, you will receive a login link.'
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: 'Invalid email address' });
    }
    return next(error);
  }
});

/**
 * GET /api/partner/auth/verify/:token
 * Verify magic link and create session
 */
router.get('/auth/verify/:token', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { token } = req.params;

    const result = await partnerAuthService.verifyToken(token);

    if (!result) {
      // Redirect to frontend with error
      return res.redirect(`${env.FRONTEND_URL}/partner/login?error=invalid_token`);
    }

    const { partner, tokenId } = result;

    // Mark token as used
    await partnerAuthService.markTokenUsed(tokenId);

    // Create session
    req.session.partnerId = partner.id;
    req.session.partnerEmail = partner.email;

    // Audit log successful login
    await auditService.log({
      action: 'partner.login',
      resourceType: 'PartnerUser',
      resourceId: partner.id,
      metadata: { email: partner.email },
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
      severity: 'INFO'
    });

    // Redirect to partner dashboard
    return res.redirect(`${env.FRONTEND_URL}/partner/dashboard`);
  } catch (error) {
    return next(error);
  }
});

/**
 * GET /api/partner/auth/me
 * Get current partner user (requires auth)
 */
router.get('/auth/me', loadPartnerUser, requirePartnerAuth, async (req: Request, res: Response) => {
  const partner = (req as any).partnerUser;
  return res.json({
    id: partner.id,
    email: partner.email,
    name: partner.name,
    statusPages: partner.statusPageAccess.map((a: any) => ({
      id: a.statusPage.id,
      name: a.statusPage.name,
      slug: a.statusPage.slug
    }))
  });
});

/**
 * POST /api/partner/auth/logout
 * Destroy partner session
 */
router.post('/auth/logout', loadPartnerUser, (req: Request, res: Response) => {
  const partner = (req as any).partnerUser;

  if (partner) {
    auditService.log({
      action: 'partner.logout',
      resourceType: 'PartnerUser',
      resourceId: partner.id,
      metadata: { email: partner.email },
      ipAddress: req.ip,
      userAgent: req.get('user-agent'),
      severity: 'INFO'
    });
  }

  req.session.destroy(() => {
    res.clearCookie('partner.sid');
    res.json({ success: true });
  });
});

export const partnerRoutes = router;
```

Update `src/app.ts` to mount partner routes with partner session middleware:

1. Import at top:
```typescript
import { partnerSessionMiddleware } from './partner/session.js';
import { partnerRoutes } from './partner/partner.routes.js';
```

2. Mount partner routes BEFORE internal routes (order matters for session middleware):
```typescript
// Partner routes with separate session
app.use('/api/partner', partnerSessionMiddleware, partnerRoutes);
```

This ensures partner routes use partner.sid cookie while internal routes use oncall.sid cookie.
  </action>
  <verify>
1. `npm run build` compiles
2. Start server and test endpoints:
```bash
curl -X POST http://localhost:3001/api/partner/auth/request-login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com"}'
# Should return success message
```
  </verify>
  <done>
Partner routes mounted at /api/partner/* with separate session. Magic link flow: request -> email -> verify -> session -> dashboard redirect.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Partner session uses different cookie (partner.sid) than internal (oncall.sid)
3. POST /api/partner/auth/request-login accepts email and returns success
4. GET /api/partner/auth/verify/:token verifies token and creates session
5. GET /api/partner/auth/me returns partner info when authenticated
6. POST /api/partner/auth/logout destroys session
7. Audit logs exist for partner.login.requested, partner.login, partner.logout
</verification>

<success_criteria>
- Partner can request magic link via email (15-minute expiry)
- Magic link verification creates partner session (24-hour expiry)
- Partner session completely separate from internal user session
- All auth events logged to audit system
- Invalid/expired tokens redirect to login with error
</success_criteria>

<output>
After completion, create `.planning/phases/17-partner-status-pages/17-02-SUMMARY.md`
</output>

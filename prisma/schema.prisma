// PageFree Database Schema
// Phase 1: Foundation & User Management

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum PlatformRole {
  PLATFORM_ADMIN // Global admin with complete control
  USER // Regular user
}

enum TeamRole {
  TEAM_ADMIN // Full team control (manage users, configure settings)
  RESPONDER // Can acknowledge and resolve incidents
  OBSERVER // Read-only access
}

enum TagType {
  ORGANIZATIONAL // Engineering, Product, SRE, Security
  TECHNICAL // Backend, Frontend, Mobile, Payments, Auth
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
  SLACK
  TEAMS
  VOICE
}

enum AlertSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
  INFO
}

enum AlertStatus {
  OPEN
  ACKNOWLEDGED
  RESOLVED
  CLOSED
}

// ============================================================================
// USER MODEL
// ============================================================================

model User {
  id                  String       @id @default(cuid())
  oktaId              String?      @unique // Null for break-glass accounts
  email               String       @unique
  firstName           String
  lastName            String
  phone               String?
  isActive            Boolean      @default(true)
  isBreakGlassAccount Boolean      @default(false)
  passwordHash        String? // Only for break-glass accounts
  platformRole        PlatformRole @default(USER)
  emailVerified       Boolean      @default(false)
  phoneVerified       Boolean      @default(false)
  pushEnabled         Boolean      @default(false)
  syncedFromOkta      Boolean      @default(false)
  deactivatedAt       DateTime?    @db.Timestamptz
  createdAt           DateTime     @default(now()) @db.Timestamptz
  updatedAt           DateTime     @updatedAt @db.Timestamptz

  // Relations
  teamMembers                 TeamMember[]
  auditEvents                 AuditEvent[]
  notificationPreferences     NotificationPreference[]
  contactVerifications        ContactVerification[]
  refreshTokens               RefreshToken[]
  devices                     UserDevice[]
  apiKeysCreated              ApiKey[]
  scheduleOverridesAsUser     ScheduleOverride[]       @relation("ScheduleOverrideUser")
  scheduleOverridesAsOriginal ScheduleOverride[]       @relation("ScheduleOverrideOriginalUser")
  scheduleOverridesCreated    ScheduleOverride[]       @relation("ScheduleOverrideCreatedBy")
  calendarSyncs               CalendarSync[]
  incidentsAssigned           Incident[]
  notificationLogs            NotificationLog[]
  slackConnection             SlackConnection?
  teamsConnection             TeamsConnection?
  preferences                 Json? // User preferences (dashboard filters, notifications, etc.)
  workflowsCreated            Workflow[]               @relation("WorkflowCreatedBy")
  workflowVersionsCreated     WorkflowVersion[]
  postmortemsCreated          Postmortem[]             @relation("PostmortemCreatedBy")
  actionItemsAssigned         ActionItem[]

  @@index([email])
  @@index([oktaId])
  @@index([isActive])
}

// ============================================================================
// TEAM MODELS
// ============================================================================

model Team {
  id                   String    @id @default(cuid())
  name                 String    @unique
  description          String?
  isActive             Boolean   @default(true)
  syncedFromOkta       Boolean   @default(false)
  oktaGroupId          String?   @unique
  slackChannel         String?
  notificationDefaults Json? // Team-level notification settings
  escalationDefaults   Json? // Team-level escalation settings
  maintenanceMode      Boolean   @default(false)
  archivedAt           DateTime? @db.Timestamptz
  createdAt            DateTime  @default(now()) @db.Timestamptz
  updatedAt            DateTime  @updatedAt @db.Timestamptz

  // Relations
  members            TeamMember[]
  tags               TeamTag[]
  auditEvents        AuditEvent[]
  schedules          Schedule[]
  escalationPolicies EscalationPolicy[]
  incidents          Incident[]
  workflows          Workflow[]
  statusPages        StatusPage[]
  postmortems        Postmortem[]

  @@index([name])
  @@index([isActive])
  @@index([oktaGroupId])
}

model TeamMember {
  id       String   @id @default(cuid())
  userId   String
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId   String
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  role     TeamRole
  joinedAt DateTime @default(now()) @db.Timestamptz

  @@unique([userId, teamId])
  @@index([userId])
  @@index([teamId])
  @@index([role])
}

model TeamTag {
  id       String  @id @default(cuid())
  teamId   String
  team     Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  tagType  TagType
  tagValue String // e.g., "Engineering", "Backend"

  @@unique([teamId, tagType, tagValue])
  @@index([tagType, tagValue])
  @@index([teamId])
}

// ============================================================================
// NOTIFICATION & CONTACT MODELS
// ============================================================================

model NotificationPreference {
  id        String              @id @default(cuid())
  userId    String
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel   NotificationChannel
  enabled   Boolean             @default(true)
  priority  Int // Order of preference (1 = highest)
  createdAt DateTime            @default(now()) @db.Timestamptz
  updatedAt DateTime            @updatedAt @db.Timestamptz

  @@unique([userId, channel])
  @@index([userId])
  @@index([userId, priority])
}

model ContactVerification {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  method     String // "email", "sms", "push"
  value      String // Email address, phone number, or device token
  code       String // 6-digit verification code
  verified   Boolean   @default(false)
  expiresAt  DateTime  @db.Timestamptz
  verifiedAt DateTime? @db.Timestamptz
  createdAt  DateTime  @default(now()) @db.Timestamptz

  @@index([userId, method])
  @@index([expiresAt])
}

// ============================================================================
// MOBILE & AUTHENTICATION MODELS
// ============================================================================

model RefreshToken {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token      String   @unique // Hashed token
  deviceInfo String // Device information for tracking
  expiresAt  DateTime @db.Timestamptz
  lastUsedAt DateTime @db.Timestamptz
  createdAt  DateTime @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([expiresAt])
}

model UserDevice {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  platform    String // "ios", "android", "web"
  deviceToken String // Push notification token
  deviceName  String? // User-friendly device name
  lastSeenAt  DateTime @db.Timestamptz
  createdAt   DateTime @default(now()) @db.Timestamptz

  @@unique([userId, deviceToken])
  @@index([userId])
}

// ============================================================================
// AUDIT MODEL
// ============================================================================

model AuditEvent {
  id           String   @id @default(cuid())
  action       String // e.g., "user.login", "team.settings.updated"
  userId       String? // Null for system actions
  user         User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  teamId       String? // If action is team-scoped
  team         Team?    @relation(fields: [teamId], references: [id], onDelete: SetNull)
  resourceType String? // e.g., "user", "team", "incident"
  resourceId   String? // ID of affected resource
  metadata     Json     @default("{}") // Flexible JSON for action-specific data
  ipAddress    String?
  userAgent    String?
  severity     String // "INFO", "WARN", "HIGH"
  timestamp    DateTime @default(now()) @db.Timestamptz

  @@index([userId, timestamp])
  @@index([teamId, timestamp])
  @@index([action, timestamp])
  @@index([timestamp])
  @@index([severity, timestamp])
}

// ============================================================================
// SESSION MODEL (for connect-pg-simple)
// ============================================================================

model Session {
  sid    String   @id
  sess   Json
  expire DateTime @db.Timestamptz

  @@index([expire])
}

// ============================================================================
// API KEY MODEL
// ============================================================================

model ApiKey {
  id        String @id @default(cuid())
  name      String // Descriptive name (e.g., "DataDog Production")
  keyHash   String @unique // SHA-256 hash of the API key
  keyPrefix String // First 8 chars for identification (e.g., "sk_prod_")

  // Service metadata
  service     String // Service name: datadog, newrelic, custom
  description String? // Optional description

  // Scopes define what the key can access
  scopes String[] // e.g., ["webhooks:write", "alerts:write"]

  // Ownership and lifecycle
  createdById String
  createdBy   User    @relation(fields: [createdById], references: [id])
  isActive    Boolean @default(true)

  // Usage tracking
  lastUsedAt DateTime? @db.Timestamptz
  usageCount Int       @default(0)

  // Expiry (optional)
  expiresAt DateTime? @db.Timestamptz

  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  @@index([keyHash])
  @@index([keyPrefix])
  @@index([service])
}

// ============================================================================
// SCHEDULING MODELS (Phase 3)
// ============================================================================

model Schedule {
  id                   String    @id @default(cuid())
  teamId               String
  team                 Team      @relation(fields: [teamId], references: [id])
  name                 String
  description          String?
  timezone             String // IANA timezone (e.g., "America/New_York")
  startDate            DateTime  @db.Timestamptz
  endDate              DateTime? @db.Timestamptz
  handoffTime          String // HH:MM format (e.g., "09:00")
  rotationType         String // daily, weekly, custom
  rotationIntervalDays Int       @default(7)
  recurrenceRule       String // RRULE format from rrule library
  rotationUserIds      String[] // Ordered list of users in rotation
  isActive             Boolean   @default(true)
  createdAt            DateTime  @default(now()) @db.Timestamptz
  updatedAt            DateTime  @updatedAt @db.Timestamptz

  // Relations
  layers    ScheduleLayer[]
  overrides ScheduleOverride[]

  @@index([teamId])
  @@index([isActive])
}

model ScheduleLayer {
  id              String    @id @default(cuid())
  scheduleId      String
  schedule        Schedule  @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  name            String // e.g., "Primary", "Backup", "Weekend"
  priority        Int // Higher number = higher precedence
  timezone        String // IANA timezone
  startDate       DateTime  @db.Timestamptz
  endDate         DateTime? @db.Timestamptz
  handoffTime     String // HH:MM format
  recurrenceRule  String // RRULE format
  rotationUserIds String[] // Ordered list of users in rotation
  restrictions    Json? // e.g., {"daysOfWeek": ["SAT", "SUN"]}
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now()) @db.Timestamptz
  updatedAt       DateTime  @updatedAt @db.Timestamptz

  @@index([scheduleId, priority])
  @@index([scheduleId, isActive])
}

model ScheduleOverride {
  id             String   @id @default(cuid())
  scheduleId     String
  schedule       Schedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  userId         String // Who is covering
  user           User     @relation("ScheduleOverrideUser", fields: [userId], references: [id])
  originalUserId String? // Who was originally scheduled (for shift swaps)
  originalUser   User?    @relation("ScheduleOverrideOriginalUser", fields: [originalUserId], references: [id])
  startTime      DateTime @db.Timestamptz
  endTime        DateTime @db.Timestamptz
  reason         String? // e.g., "Vacation coverage", "Shift swap with John"
  overrideType   String   @default("manual") // manual, swap
  createdById    String
  createdBy      User     @relation("ScheduleOverrideCreatedBy", fields: [createdById], references: [id])
  createdAt      DateTime @default(now()) @db.Timestamptz

  @@index([scheduleId, startTime, endTime])
  @@index([userId])
  @@index([scheduleId])
}

model CalendarSync {
  id             String    @id @default(cuid())
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider       String // google, microsoft
  accessToken    String // Encrypted in production
  refreshToken   String // Encrypted in production
  tokenExpiresAt DateTime  @db.Timestamptz
  calendarId     String // External calendar ID to sync to
  calendarName   String?
  isActive       Boolean   @default(true)
  syncedUntil    DateTime? @db.Timestamptz // Last synced shift end
  lastSyncAt     DateTime? @db.Timestamptz
  lastSyncError  String?
  createdAt      DateTime  @default(now()) @db.Timestamptz
  updatedAt      DateTime  @updatedAt @db.Timestamptz

  @@unique([userId, provider])
  @@index([isActive, syncedUntil])
}

// ============================================================================
// ALERT INGESTION MODELS (Phase 2)
// ============================================================================

model Integration {
  id            String  @id @default(cuid())
  name          String  @unique // e.g., "datadog-production"
  type          String // datadog, newrelic, pagerduty, generic
  webhookSecret String // HMAC secret for signature verification
  isActive      Boolean @default(true)

  // Signature configuration
  signatureHeader    String  @default("X-Webhook-Signature")
  signatureAlgorithm String  @default("sha256")
  signatureFormat    String  @default("hex") // hex, base64
  signaturePrefix    String? // e.g., "sha256="

  // Idempotency configuration
  deduplicationWindowMinutes Int @default(15)

  // Relations
  alerts            Alert[]
  webhookDeliveries WebhookDelivery[]

  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  @@index([type])
  @@index([isActive])
}

model Alert {
  id String @id @default(cuid())

  // Normalized fields (extracted from payload)
  title       String
  description String?
  severity    AlertSeverity
  status      AlertStatus   @default(OPEN)
  source      String // Integration name
  externalId  String? // ID from monitoring tool

  // Timestamps (all UTC per Phase 1 decision)
  triggeredAt    DateTime  @db.Timestamptz // When alert fired (from payload)
  acknowledgedAt DateTime? @db.Timestamptz
  resolvedAt     DateTime? @db.Timestamptz
  closedAt       DateTime? @db.Timestamptz

  // Metadata (flexible JSON for integration-specific fields)
  metadata Json @default("{}")

  // Relations
  integrationId String?
  integration   Integration?      @relation(fields: [integrationId], references: [id])
  deliveries    WebhookDelivery[]
  incidentId    String?
  incident      Incident?         @relation(fields: [incidentId], references: [id])

  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  @@index([integrationId, triggeredAt])
  @@index([status, triggeredAt])
  @@index([severity, triggeredAt])
  @@index([externalId])
  @@index([incidentId])
}

model WebhookDelivery {
  id String @id @default(cuid())

  // Idempotency tracking
  idempotencyKey     String? // External key if provided (X-Request-ID, etc.)
  contentFingerprint String // SHA-256 hash of normalized payload

  // Raw data preservation
  rawPayload Json // Original webhook body
  headers    Json // Sanitized headers (exclude secrets)

  // Processing result
  statusCode   Int // HTTP status returned
  errorMessage String? // If processing failed
  processedAt  DateTime @db.Timestamptz

  // Relations
  integrationId String
  integration   Integration @relation(fields: [integrationId], references: [id])
  alertId       String? // Null if duplicate or failed validation
  alert         Alert?      @relation(fields: [alertId], references: [id])

  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([integrationId, idempotencyKey])
  @@index([integrationId, contentFingerprint, createdAt])
  @@index([integrationId, createdAt])
  @@index([alertId])
}

// ============================================================================
// INCIDENT & ESCALATION MODELS (Phase 4)
// ============================================================================

model EscalationPolicy {
  id          String  @id @default(cuid())
  teamId      String
  team        Team    @relation(fields: [teamId], references: [id])
  name        String
  description String?
  isDefault   Boolean @default(false) // Default policy for team
  repeatCount Int     @default(1) // Repeat policy N times before stopping (max 9)
  isActive    Boolean @default(true)

  // Relations
  levels    EscalationLevel[]
  incidents Incident[]

  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  @@index([teamId])
  @@index([teamId, isDefault])
}

model EscalationLevel {
  id                 String           @id @default(cuid())
  escalationPolicyId String
  escalationPolicy   EscalationPolicy @relation(fields: [escalationPolicyId], references: [id], onDelete: Cascade)

  levelNumber    Int // Order of escalation (1, 2, 3...)
  targetType     String // 'user', 'schedule', 'entire_team'
  targetId       String? // User ID or Schedule ID, null for entire_team
  timeoutMinutes Int     @default(30) // Wait before escalating

  createdAt DateTime @default(now()) @db.Timestamptz

  @@unique([escalationPolicyId, levelNumber])
  @@index([escalationPolicyId, levelNumber])
}

model Incident {
  id          String @id @default(cuid())
  fingerprint String // Deduplication key from alert

  // Routing
  teamId             String
  team               Team             @relation(fields: [teamId], references: [id])
  escalationPolicyId String
  escalationPolicy   EscalationPolicy @relation(fields: [escalationPolicyId], references: [id])
  currentLevel       Int              @default(1) // Current escalation level
  currentRepeat      Int              @default(1) // Current repeat cycle

  // Assignment
  assignedUserId String?
  assignedUser   User?   @relation(fields: [assignedUserId], references: [id])

  // Status
  status     String // OPEN, ACKNOWLEDGED, RESOLVED, CLOSED
  priority   String // From first alert severity
  alertCount Int    @default(1) // Count of grouped alerts

  // Timestamps
  createdAt       DateTime  @default(now()) @db.Timestamptz
  acknowledgedAt  DateTime? @db.Timestamptz
  resolvedAt      DateTime? @db.Timestamptz
  closedAt        DateTime? @db.Timestamptz
  lastEscalatedAt DateTime? @db.Timestamptz

  // Relations
  alerts             Alert[]
  escalationJobs     EscalationJob[]
  notificationLogs   NotificationLog[]
  magicLinkTokens    MagicLinkToken[]
  workflowExecutions WorkflowExecution[]
  statusIncidents    StatusIncident[]

  @@index([teamId, status])
  @@index([fingerprint, status, createdAt])
  @@index([assignedUserId, status])
  @@index([status, createdAt])
}

model EscalationJob {
  id             String    @id @default(cuid())
  incidentId     String
  incident       Incident  @relation(fields: [incidentId], references: [id])
  bullJobId      String    @unique // BullMQ job ID for cancellation
  scheduledLevel Int // Which level this escalates to
  scheduledFor   DateTime  @db.Timestamptz
  completed      Boolean   @default(false)
  cancelledAt    DateTime? @db.Timestamptz
  executedAt     DateTime? @db.Timestamptz

  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([incidentId, completed])
}

// ============================================================================
// NOTIFICATION DELIVERY MODELS (Phase 5)
// ============================================================================

model NotificationLog {
  id         String              @id @default(cuid())
  incidentId String
  incident   Incident            @relation(fields: [incidentId], references: [id])
  userId     String
  user       User                @relation(fields: [userId], references: [id])
  channel    NotificationChannel

  // Delivery tracking
  status       String // QUEUED, SENDING, SENT, DELIVERED, FAILED
  providerId   String? // External message ID from provider
  error        String? // Error message if failed
  attemptCount Int     @default(0)

  // Escalation context
  escalationLevel Int? // Which escalation level triggered this

  // Timestamps
  queuedAt      DateTime  @db.Timestamptz
  sentAt        DateTime? @db.Timestamptz
  deliveredAt   DateTime? @db.Timestamptz
  lastAttemptAt DateTime? @db.Timestamptz

  createdAt DateTime @default(now()) @db.Timestamptz

  @@index([incidentId, channel])
  @@index([userId, status])
  @@index([incidentId, userId, channel])
}

model MagicLinkToken {
  id         String    @id @default(cuid())
  tokenHash  String    @unique // SHA-256 hash (never store plaintext)
  incidentId String
  incident   Incident  @relation(fields: [incidentId], references: [id])
  action     String // 'acknowledge' or 'resolve'
  used       Boolean   @default(false)
  usedAt     DateTime? @db.Timestamptz
  expiresAt  DateTime  @db.Timestamptz
  createdAt  DateTime  @default(now()) @db.Timestamptz

  @@index([tokenHash])
  @@index([incidentId, action])
  @@index([expiresAt])
}

model SlackConnection {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // OAuth tokens (encrypted in production)
  accessToken    String
  refreshToken   String?
  tokenExpiresAt DateTime? @db.Timestamptz

  // User's Slack identity
  slackUserId String  @unique
  slackTeamId String
  slackEmail  String?

  isActive   Boolean   @default(true)
  lastUsedAt DateTime? @db.Timestamptz
  createdAt  DateTime  @default(now()) @db.Timestamptz
  updatedAt  DateTime  @updatedAt @db.Timestamptz

  @@unique([userId])
  @@index([slackUserId])
}

model TeamsConnection {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // OAuth tokens (encrypted in production)
  accessToken    String
  refreshToken   String?
  tokenExpiresAt DateTime? @db.Timestamptz

  // User's Teams identity
  teamsUserId   String  @unique
  teamsTenantId String
  teamsEmail    String?

  isActive   Boolean   @default(true)
  lastUsedAt DateTime? @db.Timestamptz
  createdAt  DateTime  @default(now()) @db.Timestamptz
  updatedAt  DateTime  @updatedAt @db.Timestamptz

  @@unique([userId])
  @@index([teamsUserId])
}

// ============================================================================
// WORKFLOW AUTOMATION MODELS (Phase 8)
// ============================================================================

model Workflow {
  id          String @id @default(cuid())
  name        String
  description String
  version     Int    @default(1)

  // Definition (JSON blob) - stores WorkflowDefinition structure
  definition Json

  // Scope
  scopeType String // 'team' or 'global'
  teamId    String?
  team      Team?   @relation(fields: [teamId], references: [id])

  // State
  isEnabled        Boolean @default(false)
  isTemplate       Boolean @default(false)
  templateCategory String? // 'Ticketing', 'Communication', 'Auto-resolution'

  // Ownership
  createdById String
  createdBy   User   @relation("WorkflowCreatedBy", fields: [createdById], references: [id])

  // Timestamps
  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  // Relations
  versions      WorkflowVersion[]
  executions    WorkflowExecution[]
  actionSecrets WorkflowActionSecret[]

  @@index([teamId, isEnabled])
  @@index([isTemplate, templateCategory])
  @@index([scopeType])
}

model WorkflowVersion {
  id          String   @id @default(cuid())
  workflowId  String
  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  version     Int
  definition  Json // Snapshot of definition at this version
  changedById String
  changedBy   User     @relation(fields: [changedById], references: [id])
  changeNote  String?
  createdAt   DateTime @default(now()) @db.Timestamptz

  @@unique([workflowId, version])
  @@index([workflowId, version])
}

model WorkflowExecution {
  id              String   @id @default(cuid())
  workflowId      String
  workflow        Workflow @relation(fields: [workflowId], references: [id])
  workflowVersion Int

  // Frozen definition at execution time (in-flight uses old version)
  definitionSnapshot Json

  // Incident link
  incidentId String
  incident   Incident @relation(fields: [incidentId], references: [id])

  // Trigger info
  triggeredBy  String // 'event' | 'manual'
  triggerEvent String? // 'incident_created', 'state_changed', 'escalation', 'age'

  // Execution state
  status         String // 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED'
  currentNodeId  String? // Currently executing node
  completedNodes Json    @default("[]") // Array of completed node results
  error          String? // Error message if failed

  // Timestamps
  startedAt   DateTime? @db.Timestamptz
  completedAt DateTime? @db.Timestamptz
  failedAt    DateTime? @db.Timestamptz
  createdAt   DateTime  @default(now()) @db.Timestamptz

  @@index([workflowId, status])
  @@index([incidentId])
  @@index([status, createdAt])
}

model WorkflowActionSecret {
  id         String   @id @default(cuid())
  workflowId String
  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  name       String // e.g., 'jira_api_token', 'linear_api_key'
  valueHash  String // Encrypted value
  createdAt  DateTime @default(now()) @db.Timestamptz

  @@unique([workflowId, name])
}

// ============================================================================
// STATUS PAGE MODELS (Phase 9)
// ============================================================================

model StatusPage {
  id          String  @id @default(cuid())
  name        String // e.g., "Internal Services Status"
  description String?
  slug        String  @unique // URL-friendly identifier

  // Access control
  isPublic    Boolean @default(false) // If false, requires accessToken
  accessToken String? @unique // For private page access

  // Ownership
  teamId      String
  team        Team    @relation(fields: [teamId], references: [id])
  createdById String

  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  // Relations
  components         StatusPageComponent[]
  subscribers        StatusSubscriber[]
  maintenanceWindows MaintenanceWindow[]
  statusIncidents    StatusIncident[]

  @@index([teamId])
  @@index([slug])
}

model StatusPageComponent {
  id           String     @id @default(cuid())
  statusPageId String
  statusPage   StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  name         String // e.g., "API Gateway", "Database Cluster"
  description  String?
  displayOrder Int    @default(0)

  // Incident mapping
  teamId            String? // If set, incidents from this team affect this component
  serviceIdentifier String? // If set, only incidents with matching source/service

  // Current status (cached, computed from incidents + maintenance)
  currentStatus   String   @default("OPERATIONAL") // Cache field for quick reads
  statusUpdatedAt DateTime @default(now()) @db.Timestamptz

  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  // Relations
  maintenanceWindows MaintenanceWindow[] @relation("ComponentMaintenance")

  @@unique([statusPageId, name])
  @@index([statusPageId, displayOrder])
}

model StatusSubscriber {
  id           String     @id @default(cuid())
  statusPageId String
  statusPage   StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  // Subscriber contact
  channel     String // EMAIL, SLACK, WEBHOOK
  destination String // Email address, webhook URL, Slack channel

  // Subscription preferences
  componentIds String[] // Empty = all components
  notifyOn     String[] // ['degraded', 'outage', 'maintenance', 'resolved']

  // Verification
  isVerified  Boolean @default(false) // Email requires verification
  verifyToken String? @unique

  isActive Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz

  @@unique([statusPageId, channel, destination])
  @@index([statusPageId, isActive])
}

model MaintenanceWindow {
  id           String     @id @default(cuid())
  statusPageId String
  statusPage   StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  title       String
  description String?

  startTime      DateTime @db.Timestamptz
  endTime        DateTime @db.Timestamptz
  recurrenceRule String? // RRULE for recurring maintenance

  // Behavior
  autoUpdateStatus  Boolean @default(true) // Set components to UNDER_MAINTENANCE
  notifySubscribers Boolean @default(true)

  status String @default("SCHEDULED") // SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED

  // Affected components
  components StatusPageComponent[] @relation("ComponentMaintenance")

  createdById String
  createdAt   DateTime @default(now()) @db.Timestamptz
  updatedAt   DateTime @updatedAt @db.Timestamptz

  @@index([statusPageId, startTime])
  @@index([status, startTime])
}

model StatusIncident {
  id           String     @id @default(cuid())
  statusPageId String
  statusPage   StatusPage @relation(fields: [statusPageId], references: [id], onDelete: Cascade)

  // Link to platform incident
  incidentId String?
  incident   Incident? @relation(fields: [incidentId], references: [id])

  // Status page-specific fields
  title    String // User-facing title (may differ from internal incident)
  message  String? // Public message about the issue
  severity String // MINOR, MAJOR, CRITICAL (for display)
  status   String // INVESTIGATING, IDENTIFIED, MONITORING, RESOLVED

  affectedComponentIds String[]

  createdAt  DateTime  @default(now()) @db.Timestamptz
  updatedAt  DateTime  @updatedAt @db.Timestamptz
  resolvedAt DateTime? @db.Timestamptz

  // Updates history (stored as JSON for simplicity)
  updates Json @default("[]") // Array of { timestamp, status, message }

  @@index([statusPageId, status])
  @@index([incidentId])
}

// ============================================================================
// POSTMORTEM MODELS (Phase 10)
// ============================================================================

enum PostmortemStatus {
  DRAFT // Initial state, editable
  PUBLISHED // Finalized, read-only except by team admin
}

enum ActionItemStatus {
  OPEN // Initial state
  IN_PROGRESS // Work started
  COMPLETED // Done
}

model Postmortem {
  id          String           @id @default(cuid())
  title       String
  content     String           @default("") // Markdown content
  incidentIds String[] // Array of linked incident IDs for multi-incident support
  status      PostmortemStatus @default(DRAFT)

  // Ownership
  teamId      String
  team        Team             @relation(fields: [teamId], references: [id])
  createdById String
  createdBy   User             @relation("PostmortemCreatedBy", fields: [createdById], references: [id])

  // Timestamps
  publishedAt DateTime? @db.Timestamptz // When status changed to PUBLISHED
  createdAt   DateTime  @default(now()) @db.Timestamptz
  updatedAt   DateTime  @updatedAt @db.Timestamptz

  // Relations
  actionItems ActionItem[]

  @@index([teamId, status])
  @@index([createdById])
}

model ActionItem {
  id           String           @id @default(cuid())
  postmortemId String
  postmortem   Postmortem       @relation(fields: [postmortemId], references: [id], onDelete: Cascade)

  title       String // What needs to be done
  description String? // Optional details
  status      ActionItemStatus @default(OPEN)
  priority    String           @default("MEDIUM") // HIGH/MEDIUM/LOW

  // Assignment (every action needs owner)
  assigneeId String
  assignee   User   @relation(fields: [assigneeId], references: [id])

  // Tracking
  dueDate     DateTime? @db.Timestamptz
  completedAt DateTime? @db.Timestamptz

  // Timestamps
  createdAt DateTime @default(now()) @db.Timestamptz
  updatedAt DateTime @updatedAt @db.Timestamptz

  @@index([postmortemId])
  @@index([assigneeId, status])
}

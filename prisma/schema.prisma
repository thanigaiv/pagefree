// OnCall Platform Database Schema
// Phase 1: Foundation & User Management

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum PlatformRole {
  PLATFORM_ADMIN  // Global admin with complete control
  USER            // Regular user
}

enum TeamRole {
  TEAM_ADMIN      // Full team control (manage users, configure settings)
  RESPONDER       // Can acknowledge and resolve incidents
  OBSERVER        // Read-only access
}

enum TagType {
  ORGANIZATIONAL  // Engineering, Product, SRE, Security
  TECHNICAL       // Backend, Frontend, Mobile, Payments, Auth
}

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
  SLACK
  VOICE
}

enum AlertSeverity {
  CRITICAL
  HIGH
  MEDIUM
  LOW
  INFO
}

enum AlertStatus {
  OPEN
  ACKNOWLEDGED
  RESOLVED
  CLOSED
}

// ============================================================================
// USER MODEL
// ============================================================================

model User {
  id                    String        @id @default(cuid())
  oktaId                String?       @unique // Null for break-glass accounts
  email                 String        @unique
  firstName             String
  lastName              String
  phone                 String?
  isActive              Boolean       @default(true)
  isBreakGlassAccount   Boolean       @default(false)
  passwordHash          String?       // Only for break-glass accounts
  platformRole          PlatformRole  @default(USER)
  emailVerified         Boolean       @default(false)
  phoneVerified         Boolean       @default(false)
  pushEnabled           Boolean       @default(false)
  syncedFromOkta        Boolean       @default(false)
  deactivatedAt         DateTime?     @db.Timestamptz
  createdAt             DateTime      @default(now()) @db.Timestamptz
  updatedAt             DateTime      @updatedAt @db.Timestamptz

  // Relations
  teamMembers           TeamMember[]
  auditEvents           AuditEvent[]
  notificationPreferences NotificationPreference[]
  contactVerifications  ContactVerification[]
  refreshTokens         RefreshToken[]
  devices               UserDevice[]
  apiKeysCreated        ApiKey[]

  @@index([email])
  @@index([oktaId])
  @@index([isActive])
}

// ============================================================================
// TEAM MODELS
// ============================================================================

model Team {
  id                    String        @id @default(cuid())
  name                  String        @unique
  description           String?
  isActive              Boolean       @default(true)
  syncedFromOkta        Boolean       @default(false)
  oktaGroupId           String?       @unique
  slackChannel          String?
  notificationDefaults  Json?         // Team-level notification settings
  escalationDefaults    Json?         // Team-level escalation settings
  maintenanceMode       Boolean       @default(false)
  archivedAt            DateTime?     @db.Timestamptz
  createdAt             DateTime      @default(now()) @db.Timestamptz
  updatedAt             DateTime      @updatedAt @db.Timestamptz

  // Relations
  members               TeamMember[]
  tags                  TeamTag[]
  auditEvents           AuditEvent[]

  @@index([name])
  @@index([isActive])
  @@index([oktaGroupId])
}

model TeamMember {
  id                    String        @id @default(cuid())
  userId                String
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId                String
  team                  Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  role                  TeamRole
  joinedAt              DateTime      @default(now()) @db.Timestamptz

  @@unique([userId, teamId])
  @@index([userId])
  @@index([teamId])
  @@index([role])
}

model TeamTag {
  id                    String        @id @default(cuid())
  teamId                String
  team                  Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  tagType               TagType
  tagValue              String        // e.g., "Engineering", "Backend"

  @@unique([teamId, tagType, tagValue])
  @@index([tagType, tagValue])
  @@index([teamId])
}

// ============================================================================
// NOTIFICATION & CONTACT MODELS
// ============================================================================

model NotificationPreference {
  id                    String               @id @default(cuid())
  userId                String
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  channel               NotificationChannel
  enabled               Boolean              @default(true)
  priority              Int                  // Order of preference (1 = highest)
  createdAt             DateTime             @default(now()) @db.Timestamptz
  updatedAt             DateTime             @updatedAt @db.Timestamptz

  @@unique([userId, channel])
  @@index([userId])
  @@index([userId, priority])
}

model ContactVerification {
  id                    String        @id @default(cuid())
  userId                String
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  method                String        // "email", "sms", "push"
  value                 String        // Email address, phone number, or device token
  code                  String        // 6-digit verification code
  verified              Boolean       @default(false)
  expiresAt             DateTime      @db.Timestamptz
  verifiedAt            DateTime?     @db.Timestamptz
  createdAt             DateTime      @default(now()) @db.Timestamptz

  @@index([userId, method])
  @@index([expiresAt])
}

// ============================================================================
// MOBILE & AUTHENTICATION MODELS
// ============================================================================

model RefreshToken {
  id                    String        @id @default(cuid())
  userId                String
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  token                 String        @unique // Hashed token
  deviceInfo            String        // Device information for tracking
  expiresAt             DateTime      @db.Timestamptz
  lastUsedAt            DateTime      @db.Timestamptz
  createdAt             DateTime      @default(now()) @db.Timestamptz

  @@index([userId])
  @@index([expiresAt])
}

model UserDevice {
  id                    String        @id @default(cuid())
  userId                String
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  platform              String        // "ios", "android", "web"
  deviceToken           String        // Push notification token
  deviceName            String?       // User-friendly device name
  lastSeenAt            DateTime      @db.Timestamptz
  createdAt             DateTime      @default(now()) @db.Timestamptz

  @@unique([userId, deviceToken])
  @@index([userId])
}

// ============================================================================
// AUDIT MODEL
// ============================================================================

model AuditEvent {
  id                    String        @id @default(cuid())
  action                String        // e.g., "user.login", "team.settings.updated"
  userId                String?       // Null for system actions
  user                  User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  teamId                String?       // If action is team-scoped
  team                  Team?         @relation(fields: [teamId], references: [id], onDelete: SetNull)
  resourceType          String?       // e.g., "user", "team", "incident"
  resourceId            String?       // ID of affected resource
  metadata              Json          @default("{}")  // Flexible JSON for action-specific data
  ipAddress             String?
  userAgent             String?
  severity              String        // "INFO", "WARN", "HIGH"
  timestamp             DateTime      @default(now()) @db.Timestamptz

  @@index([userId, timestamp])
  @@index([teamId, timestamp])
  @@index([action, timestamp])
  @@index([timestamp])
  @@index([severity, timestamp])
}

// ============================================================================
// SESSION MODEL (for connect-pg-simple)
// ============================================================================

model Session {
  sid                   String        @id
  sess                  Json
  expire                DateTime      @db.Timestamptz

  @@index([expire])
}

// ============================================================================
// API KEY MODEL
// ============================================================================

model ApiKey {
  id          String   @id @default(cuid())
  name        String   // Descriptive name (e.g., "DataDog Production")
  keyHash     String   @unique  // SHA-256 hash of the API key
  keyPrefix   String   // First 8 chars for identification (e.g., "sk_prod_")

  // Service metadata
  service     String   // Service name: datadog, newrelic, custom
  description String?  // Optional description

  // Scopes define what the key can access
  scopes      String[] // e.g., ["webhooks:write", "alerts:write"]

  // Ownership and lifecycle
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])
  isActive    Boolean  @default(true)

  // Usage tracking
  lastUsedAt  DateTime? @db.Timestamptz
  usageCount  Int       @default(0)

  // Expiry (optional)
  expiresAt   DateTime? @db.Timestamptz

  createdAt   DateTime  @default(now()) @db.Timestamptz
  updatedAt   DateTime  @updatedAt @db.Timestamptz

  @@index([keyHash])
  @@index([keyPrefix])
  @@index([service])
}

// ============================================================================
// ALERT INGESTION MODELS (Phase 2)
// ============================================================================

model Integration {
  id                          String   @id @default(cuid())
  name                        String   @unique  // e.g., "datadog-production"
  type                        String   // datadog, newrelic, pagerduty, generic
  webhookSecret               String   // HMAC secret for signature verification
  isActive                    Boolean  @default(true)

  // Signature configuration
  signatureHeader             String   @default("X-Webhook-Signature")
  signatureAlgorithm          String   @default("sha256")
  signatureFormat             String   @default("hex") // hex, base64
  signaturePrefix             String?  // e.g., "sha256="

  // Idempotency configuration
  deduplicationWindowMinutes  Int      @default(15)

  // Relations
  alerts                      Alert[]
  webhookDeliveries           WebhookDelivery[]

  createdAt                   DateTime @default(now()) @db.Timestamptz
  updatedAt                   DateTime @updatedAt @db.Timestamptz

  @@index([type])
  @@index([isActive])
}

model Alert {
  id                String        @id @default(cuid())

  // Normalized fields (extracted from payload)
  title             String
  description       String?
  severity          AlertSeverity
  status            AlertStatus   @default(OPEN)
  source            String        // Integration name
  externalId        String?       // ID from monitoring tool

  // Timestamps (all UTC per Phase 1 decision)
  triggeredAt       DateTime      @db.Timestamptz  // When alert fired (from payload)
  acknowledgedAt    DateTime?     @db.Timestamptz
  resolvedAt        DateTime?     @db.Timestamptz
  closedAt          DateTime?     @db.Timestamptz

  // Metadata (flexible JSON for integration-specific fields)
  metadata          Json          @default("{}")

  // Relations
  integrationId     String
  integration       Integration   @relation(fields: [integrationId], references: [id])
  deliveries        WebhookDelivery[]

  createdAt         DateTime      @default(now()) @db.Timestamptz
  updatedAt         DateTime      @updatedAt @db.Timestamptz

  @@index([integrationId, triggeredAt])
  @@index([status, triggeredAt])
  @@index([severity, triggeredAt])
  @@index([externalId])
}

model WebhookDelivery {
  id                  String    @id @default(cuid())

  // Idempotency tracking
  idempotencyKey      String?   // External key if provided (X-Request-ID, etc.)
  contentFingerprint  String    // SHA-256 hash of normalized payload

  // Raw data preservation
  rawPayload          Json      // Original webhook body
  headers             Json      // Sanitized headers (exclude secrets)

  // Processing result
  statusCode          Int       // HTTP status returned
  errorMessage        String?   // If processing failed
  processedAt         DateTime  @db.Timestamptz

  // Relations
  integrationId       String
  integration         Integration @relation(fields: [integrationId], references: [id])
  alertId             String?   // Null if duplicate or failed validation
  alert               Alert?    @relation(fields: [alertId], references: [id])

  createdAt           DateTime  @default(now()) @db.Timestamptz

  @@index([integrationId, idempotencyKey])
  @@index([integrationId, contentFingerprint, createdAt])
  @@index([integrationId, createdAt])
  @@index([alertId])
}
